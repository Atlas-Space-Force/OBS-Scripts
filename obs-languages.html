<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/i18next/dist/umd/i18next.min.js"></script>
    <script src="https://unpkg.com/i18next-http-backend/i18nextHttpBackend.js"></script>
    <title data-i18n="pageTitle">VDO.Ninja OBS Control Dock</title>
    <style>
      body {
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        padding: 15px;
        background-color: #181a1b;
        color: #e0e0e0;
        font-size: 14px;
        line-height: 1.6;
      }
      .language-switcher {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .language-switcher label {
        margin-right: 0;
        color: #c0c0c0;
        font-size: 0.9em;
        margin-bottom: 0;
      }
      .language-switcher select {
        padding: 5px 8px;
        border-radius: 4px;
        background-color: #25272c;
        color: #e0e0e0;
        border: 1px solid #4a4d54;
        font-size: 0.9em;
        margin-bottom: 0;
        width: auto;
        min-width: 120px;
      }
      h1 {
        color: #d0d0d0;
        margin: 20px 0 20px 0;
        padding-bottom: 15px;
        font-size: 1.8em;
        font-weight: 600;
        border-bottom: 1px solid #3e4147;
      }
      .container {
        margin-bottom: 15px;
        padding: 15px;
        background-color: #2c2e33;
        border-radius: 8px;
        border: 1px solid #3e4147;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
      .collapsible {
        cursor: pointer;
        user-select: none;
        padding: 12px 15px;
        position: relative;
        font-weight: 600;
        font-size: 1.1em;
        background: #35383d;
        margin: -15px -15px 10px -15px;
        padding-left: 15px;
        border-bottom: 1px solid #3e4147;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        transition: background-color 0.2s ease;
      }
      .collapsible.collapsed {
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        margin-bottom: 0;
        border-bottom: none;
      }
      .container .collapsible:last-child.collapsed {
        margin-bottom: -15px;
      }
      .collapsible[data-state="expand"]::after {
        content: "▼";
      }
      .collapsible[data-state="collapse"]::after {
        content: "▲";
      }
      .collapsible::after {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 14px;
        color: #a0a0b0;
        transition: transform 0.2s ease;
      }
      .collapsible[data-state="expand"]::before {
      }
      .collapsible[data-state="collapse"]::before {
      }
      .collapsible::before {
        content: var(--before-text, "Click");
        position: absolute;
        right: 40px;
        font-size: 10px;
        color: #666;
        font-weight: normal;
      }
      .collapsible:hover {
        background: #404348;
      }
      .collapsible-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out, padding-top 0.3s ease-in-out,
          opacity 0.3s ease-in-out;
        padding-top: 10px;
        opacity: 1;
      }
      .collapsible-content.collapsed {
        max-height: 0;
        padding-top: 0;
        opacity: 0;
        overflow: hidden;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500;
        color: #c0c0c0;
      }
      input[type="text"],
      input[type="password"],
      input[type="number"],
      select,
      textarea {
        width: calc(
          100% - 22px
        );
        padding: 10px;
        margin-bottom: 12px;
        border: 1px solid #4a4d54;
        border-radius: 6px;
        background-color: #25272c;
        color: #e0e0e0;
        font-size: 1em;
        box-sizing: border-box;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      textarea {
        min-height: 80px;
        resize: vertical;
      }
      input[type="text"]:focus,
      input[type="password"]:focus,
      input[type="number"]:focus,
      select:focus,
      textarea:focus {
        border-color: #007aff;
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25);
        outline: none;
      }
      select {
        padding-right: 30px;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23A0A0B0'%3E%3Cpath d='M8 11L3 6h10L8 11z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 12px;
      }
      button {
        padding: 10px 15px;
        background-color: #4a5060;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        margin-right: 5px;
        margin-bottom: 5px;
        font-size: 0.95em;
        font-weight: 500;
        transition: background-color 0.2s ease, transform 0.1s ease;
      }
      button:hover {
        background-color: #5a6070;
      }
      button:active {
        transform: translateY(1px);
      }
      button.connected {
        background-color: #007aff;
      }
      button.connected:hover {
        background-color: #0056b3;
      }
      button.disconnected {
        background-color: #6c757d;
      }
      button.disconnected:hover {
        background-color: #5a6268;
      }
      .blur-field {
        filter: blur(5px);
        transition: filter 0.2s ease;
      }
      .blur-field:focus {
        filter: blur(0);
      }
      #vdoNinjaIframe {
        width: 1px;
        height: 1px;
        position: absolute;
        left: -1000px;
        top: -1000px;
        border: 0;
      }
      .log-area {
        height: 120px;
        background-color: #202225;
        color: #b0b0b0;
        border: 1px solid #4a4d54;
        border-radius: 6px;
        overflow-y: scroll;
        padding: 10px;
        font-family: "Consolas", "Monaco", "Lucida Console", monospace;
        font-size: 0.9em;
        margin-top: 10px;
        white-space: pre-wrap;
      }
      .status-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-left: 8px;
        background-color: #555;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }
      .status-indicator.connected {
        background-color: #007aff;
        box-shadow: 0 0 8px rgba(0, 122, 255, 0.7);
      }
      .status-indicator.error {
        background-color: #dc3545;
        box-shadow: 0 0 8px rgba(220, 53, 69, 0.7);
      }
      .stream-list {
        background-color: #202225;
        border: 1px solid #4a4d54;
        border-radius: 6px;
        padding: 5px;
        margin-top: 5px;
        transition: max-height 0.3s ease;
      }
      .stream-list:empty {
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #888;
        padding: 10px;
      }
      .stream-item {
        padding: 10px 12px;
        border-bottom: 1px solid #383b40;
        font-size: 1em;
        word-break: break-word;
        background-color: #2c2e33;
        margin: 0 0 8px 0;
        border-radius: 4px;
      }
      .stream-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
      }
      h2 {
        color: #c8c8c8;
        margin: 5px 0;
        font-size: 1.1em;
      }
      small {
        color: #9090a0;
        font-size: 0.88em;
        display: block;
        margin-top: 3px;
        line-height: 1.4;
      }
      .add-stream-btn {
        background-color: #28a745 !important;
      }
      .add-stream-btn:hover {
        background-color: #218838 !important;
      }
      button.add-stream-btn[style*="rgb(244, 67, 54)"],
      button.add-stream-btn[style*="#F44336"] {
        background-color: #dc3545 !important;
      }
      button.add-stream-btn[style*="rgb(244, 67, 54)"]:hover,
      button.add-stream-btn[style*="#F44336"]:hover {
        background-color: #c82333 !important;
      }
      .highlight-btn {
        background-color: #17a2b8 !important;
      }
      .highlight-btn:hover {
        background-color: #138496 !important;
      }
      button.highlight-btn[style*="rgb(244, 67, 54)"],
      button.highlight-btn[style*="#F44336"] {
        background-color: #ffc107 !important;
        color: #212529 !important;
      }
      button.highlight-btn[style*="rgb(244, 67, 54)"]:hover,
      button.highlight-btn[style*="#F44336"]:hover {
        background-color: #e0a800 !important;
      }
      .screen-share-btn {
        background-color: #6f42c1 !important;
      }
      .screen-share-btn:hover {
        background-color: #5a2aa8 !important;
      }
      button.screen-share-btn[style*="rgb(244, 67, 54)"],
      button.screen-share-btn[style*="#F44336"] {
        background-color: #fd7e14 !important;
      }
      button.screen-share-btn[style*="rgb(244, 67, 54)"]:hover,
      button.screen-share-btn[style*="#F44336"]:hover {
        background-color: #e66c00 !important;
      }
      .status-line {
        font-size: 1em;
        margin-top: 10px;
        display: flex;
        align-items: center;
      }
      #obsConnectionStatus,
      #vdoNinjaConnectionStatus {
        margin-left: 8px;
        color: #b0b0b0;
      }
      input[type="checkbox"] {
        accent-color: #007aff;
        margin-right: 8px;
        width: 15px;
        height: 15px;
        vertical-align: middle;
        flex-shrink: 0;
      }
      .checkbox-label {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        color: #c0c0c0;
        font-size: 0.95em;
      }
      .checkbox-label input {
        margin-bottom: 0;
        margin-right: 8px;
      }
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: #202225;
        border-radius: 5px;
      }
      ::-webkit-scrollbar-thumb {
        background: #4a4d54;
        border-radius: 5px;
        border: 2px solid #202225;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #007aff;
      }
      * {
        scrollbar-width: auto;
        scrollbar-color: #4a4d54 #202225;
      }
      .flex-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      #obsSceneNameInput {
        display: none !important;
      }
      #loadScenesBtn {
        margin-left: 5px;
        vertical-align: top;
      }
      .container:nth-child(6)
        .collapsible-content:not(.collapsed) {
      }
      .prefix-input-label {
        margin-bottom: 4px;
        display: block;
        font-size: 0.9em;
        color: #a0a0b0;
      }
      .prefix-group {
        margin-bottom: 10px;
      }
      a[href^="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"] {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        color: #a0a0b0;
        font-size: 12px;
        border: 1px solid #a0a0b0;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        font-weight: bold;
        vertical-align: middle;
        margin-left: 4px;
        margin-bottom: 0;
        transition: background-color 0.2s ease, color 0.2s ease,
          border-color 0.2s ease;
      }
      a[href^="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"]:hover {
        background-color: #007aff;
        color: white;
        border-color: #007aff;
      }
      .stream-mapping {
        background-color: #25272c;
        padding: 12px;
        border: 1px solid #383b40;
        border-radius: 6px;
        margin-bottom: 10px;
      }
      .stream-mapping .flex-row {
        margin-bottom: 8px;
      }
      .stream-mapping .flex-row:last-child {
        margin-bottom: 0;
      }
      .stream-mapping input[type="text"],
      .stream-mapping select {
        margin-bottom: 0;
        font-size: 0.9em;
        padding: 8px;
      }
      .stream-mapping .remove-mapping-btn {
        padding: 6px 8px;
        background-color: #c82333 !important;
        font-size: 0.9em;
        margin-left: auto;
      }
      .stream-mapping .remove-mapping-btn:hover {
        background-color: #a01c28 !important;
      }
      .stream-mapping small {
        font-size: 0.8em;
        margin-top: 5px;
      }
      .mapping-stream-id {
        flex-basis: 100px;
        flex-grow: 1;
        min-width: 80px;
      }
      .mapping-label {
        flex-basis: 140px;
        flex-grow: 2;
        min-width: 100px;
      }
      .mapping-match-type {
        flex-basis: 100px;
        flex-grow: 1;
        min-width: 90px;
      }
      .mapping-scene-name {
        flex-basis: 150px;
        flex-grow: 2;
        min-width: 120px;
      }
      .remove-mapping-btn {
        flex-shrink: 0;
      }
      #addStreamMappingBtn {
        background-color: #0069d9;
        border-color: #0062cc;
      }
      #addStreamMappingBtn:hover {
        background-color: #005cbf;
        border-color: #0056b3;
      }
      .stream-mapping .checkbox-label {
        font-size: 0.9em;
        margin-bottom: 0;
      }
      #obsTargetSettingsFlexContainer > div:first-child {
        flex-grow: 1;
      }
      #obsTargetSettingsFlexContainer > button {
        flex-shrink: 0;
      }
      .settings-group {
        margin-top: 15px;
        border-top: 1px solid #3e4147;
        padding-top: 15px;
      }
      .settings-group:first-child {
        margin-top: 0;
        border-top: none;
        padding-top: 0;
      }
    </style>
    <style id="customUserCss"></style>
  </head>
  <body>
    <h1 data-i18n="mainHeading">VDO.Ninja OBS Control</h1>

    <div class="container">
      <div class="language-switcher">
        <label for="languageSelector" data-i18n="languageSwitcher.label">Language:</label>
        <select id="languageSelector">
          <option value="en">English</option>
          <option value="pt">Português</option>
        </select>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="expand" data-i18n="obsConnection.title">OBS WebSocket Connection</h2>
      <div class="collapsible-content">
        <label for="obsWsUrl" data-i18n="obsConnection.websocketUrlLabel">WebSocket URL:</label>
        <input type="text" id="obsWsUrl" value="ws://localhost:4455" />
        <label for="obsWsPassword" data-i18n="obsConnection.passwordLabel">Password:</label>
        <input type="password" id="obsWsPassword" value="" />
        <div class="prefix-group">
          <label
            for="cameraPrefix"
            id="cameraSubPrefixLabelText"
            class="prefix-input-label"
            data-i18n="obsConnection.cameraPrefixLabel"
            >General Camera prefix:</label
          >
          <input type="text" id="cameraPrefix" value="VDO" />
        </div>
        <div class="prefix-group">
          <label
            for="reactionSubPrefix"
            id="reactionSubPrefixLabelText"
            class="prefix-input-label"
            data-i18n="obsConnection.reactionPrefixLabel"
            >Reaction prefix: VDO.</label
          >
          <input type="text" id="reactionSubPrefix" value="Screen" />
        </div>
        <div class="prefix-group">
          <label
            for="highlightSubPrefix"
            id="highlightSubPrefixLabelText"
            class="prefix-input-label"
            data-i18n="obsConnection.highlightPrefixLabel"
            >Highlight prefix: VDO.</label
          >
          <input type="text" id="highlightSubPrefix" value="Highlight" />
        </div>
        <div class="status-line">
          <button id="obsConnectBtn" data-i18n="obsConnection.connectButton">Connect</button>
          <span id="obsConnectionStatus" data-i18n="obsConnection.statusDisconnected">Status: Disconnected</span>
          <span id="obsStatusIndicator" class="status-indicator"></span>
        </div>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="expand" data-i18n="vdoNinjaSettings.title">VDO.Ninja Settings</h2>
      <div class="collapsible-content">
        <label for="vdoNinjaBaseUrl" data-i18n="vdoNinjaSettings.baseUrlLabel">VDO.Ninja Base URL:</label>
        <input
          type="text"
          id="vdoNinjaBaseUrl"
          data-i18n="[placeholder]vdoNinjaSettings.baseUrlPlaceholder"
          placeholder="https://vdo.ninja"
          value="https://vdo.ninja"
        />
        <label for="vdoNinjaRoom" data-i18n="vdoNinjaSettings.roomNameLabel">Room Name:</label>
        <input
          type="text"
          id="vdoNinjaRoom"
          data-i18n="[placeholder]vdoNinjaSettings.roomNamePlaceholder"
          placeholder="e.g., MyNinjaRoom"
          class="blur-field"
        />
        <label for="vdoNinjaPassword" data-i18n="vdoNinjaSettings.passwordLabel">Password:</label>
        <input
          type="password"
          id="vdoNinjaPassword"
          data-i18n="[placeholder]vdoNinjaSettings.passwordPlaceholder"
          placeholder="Room or &password"
        />
        <label for="vdoNinjaStreamIds" data-i18n="vdoNinjaSettings.streamIdsLabel">Stream IDs:</label>
        <input
          type="text"
          id="vdoNinjaStreamIds"
          data-i18n="[placeholder]vdoNinjaSettings.streamIdsPlaceholder"
          placeholder="streamId1,streamId2"
          class="blur-field"
        />
        <small data-i18n="vdoNinjaSettings.roomOrStreamIdsNeeded">Room Name or Stream ID(s) needed</small>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="collapse" data-i18n="streamIdMappings.title">Stream ID Mappings</h2>
      <div class="collapsible-content collapsed">
        <div id="streamMappingContainer">
          <div id="streamMappings"></div>
          <button id="addStreamMappingBtn" style="margin-top: 10px" data-i18n="streamIdMappings.addNewMappingButton">
            Add New Mapping
          </button>
        </div>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="expand" data-i18n="obsTargetSettings.title">OBS Target Settings</h2>
      <div class="collapsible-content">
        <div class="settings-group">
          <label for="obsSceneSelect" data-i18n="obsTargetSettings.targetSceneLabel">Target Scene:</label>
          <div
            class="flex-row"
            style="gap: 10px"
            id="obsTargetSettingsFlexContainer"
          >
            <select id="obsSceneSelect" style="width: 300px; flex-grow: 1">
              <option value="" data-i18n="obsTargetSettings.selectSceneOption">Select a scene...</option>
            </select>
            <button id="loadScenesBtn" data-i18n="obsTargetSettings.refetchScenesButton">Re-Fetch Scenes</button>
          </div>
        </div>
        <div
          id="otherScenesContainer"
          class="settings-group"
          style="display: none"
        >
          <label data-i18n="obsTargetSettings.copySourcesLabel">Copy sources to other scenes (reference):</label>
          <div id="otherScenesList" style="margin-top: 5px"></div>
        </div>
        <input type="text" id="obsSceneNameInput" style="display: none" />
        <div class="settings-group">
          <label style="font-weight: 600; font-size: 1.05em" data-i18n="obsTargetSettings.screenShareSettings.title">Screen Sharing Settings:</label>
          <div
            class="flex-row"
            style="gap: 15px; align-items: flex-start"
          >
            <div>
              <label for="screenShareSceneSelect" style="font-size: 0.95em" data-i18n="obsTargetSettings.screenShareSettings.targetSceneLabel">Target Scene:</label>
              <select id="screenShareSceneSelect" style="width: 300px">
                <option value="" data-i18n="obsTargetSettings.screenShareSettings.sameAsMainOption">Same as main</option>
              </select>
            </div>
            <div class="flex-row" style="gap: 8px">
              <div>
                <label for="screenShareWidth" style="font-size: 0.95em" data-i18n="obsTargetSettings.screenShareSettings.widthLabel">Width:</label>
                <input
                  type="number"
                  id="screenShareWidth"
                  value="1920"
                  style="width: 100px"
                />
              </div>
              <div>
                <label for="screenShareHeight" style="font-size: 0.95em" data-i18n="obsTargetSettings.screenShareSettings.heightLabel">Height:</label>
                <input
                  type="number"
                  id="screenShareHeight"
                  value="1080"
                  style="width: 100px"
                />
              </div>
            </div>
          </div>
        </div>
        <div class="settings-group">
          <label for="highlightSceneSelect" style="font-weight: 600; font-size: 1.05em" data-i18n="obsTargetSettings.highlightScene.title">Highlight Scene:</label>
          <select id="highlightSceneSelect" style="width: 300px">
            <option value="" data-i18n="obsTargetSettings.highlightScene.selectSceneOption">Select a scene for highlights...</option>
          </select>
        </div>
        <div
          id="autoSourceOptions"
          class="settings-group flex-row"
          style="gap: 15px"
        >
          <label class="checkbox-label">
            <input type="checkbox" id="autoAddSources" checked />
            <span data-i18n="obsTargetSettings.autoAddSourcesLabel">Auto-add new streams as sources</span>
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="autoRemoveSources" checked />
            <span data-i18n="obsTargetSettings.autoRemoveSourcesLabel">Auto-remove sources on disconnect</span>
          </label>
        </div>
        <div class="settings-group">
          <div class="flex-row" style="align-items: flex-end; gap: 15px">
            <div>
              <label for="sourceSizing" data-i18n="obsTargetSettings.newSourceSizing.label">New Source Sizing:</label>
              <select id="sourceSizing" style="width: 250px">
                <option value="defaultSize" data-i18n="obsTargetSettings.newSourceSizing.defaultSizeOption">Default (1920x1080 at 0,0)</option>
                <option value="bestFit" data-i18n="obsTargetSettings.newSourceSizing.bestFitOption">Best Fit (Preserve Aspect)</option>
                <option value="stretchToFill" data-i18n="obsTargetSettings.newSourceSizing.stretchToFillOption">Stretch to Fill Screen</option>
                <option value="autoGrid" data-i18n="obsTargetSettings.newSourceSizing.autoGridOption">Auto Grid Layout</option>
              </select>
            </div>
            <div>
              <label for="sourceCodec" data-i18n="obsTargetSettings.codec.label">Codec:</label>
              <div class="flex-row" style="gap: 2px">
                <select id="sourceCodec" style="width: 150px">
                  <option value="" data-i18n="obsTargetSettings.codec.noneOption">none</option>
                  <option value="h264">h264</option>
                  <option value="vp8">vp8</option>
                  <option value="vp9">vp9</option>
                  <option value="av1">av1</option>
                  <option value="h265">h265</option>
                  <option value="webp">webp</option>
                  <option value="hardware">hardware</option>
                </select>
                <a
                  href="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"
                  target="_blank"
                  data-i18n="[title]obsTargetSettings.codec.learnMoreTitle"
                  title="Learn more about codec options"
                  >?</a
                >
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="expand" data-i18n="activeStreams.title">Active Streams</h2>
      <div class="collapsible-content">
        <div id="streamList" class="stream-list">
          <div
            class="stream-item"
            style="
              text-align: center;
              background-color: transparent;
              border: none;
              color: #888;
            "
            data-i18n="activeStreams.noActiveStreams"
          >
            No active streams
          </div>
        </div>
      </div>
    </div>

    <div class="container">
        <h2 class="collapsible" data-state="collapse" data-i18n="customCss.title">Custom CSS</h2>
        <div class="collapsible-content collapsed">
            <label for="customCssInput" data-i18n="customCss.label">Enter your custom CSS here:</label>
            <textarea id="customCssInput" rows="10"></textarea>
            <small data-i18n="customCss.description">This CSS will be applied to the page and saved locally.</small>
        </div>
    </div>

    <iframe
      id="vdoNinjaIframe"
      allow="encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;midi *;geolocation;camera *;microphone *;fullscreen;picture-in-picture;display-capture;accelerometer;autoplay;gyroscope;screen-wake-lock;"
    ></iframe>

    <div class="container">
      <h2 class="collapsible" data-state="expand" data-i18n="log.title">Log</h2>
      <div class="collapsible-content">
        <div id="logArea" class="log-area"></div>
      </div>
    </div>

    <script>
      const loadPath = 'https://raw.githubusercontent.com/MorseTheCode/OBS-Scripts/refs/heads/main/locales/{{lng}}.json';
      let logEntries = [];
      const languageSelector = document.getElementById('languageSelector');

      function initializeApp() {
        let savedLanguage = localStorage.getItem('vdoNinjaObsControlLanguage') || 'en';
        languageSelector.value = savedLanguage;

        i18next
          .use(i18nextHttpBackend)
          .init({
            lng: savedLanguage,
            fallbackLng: 'en',
            debug: true,
            backend: {
              loadPath: loadPath
            }
          }, function(err, t) {
            if (err) return console.error('Error initializing i18next:', err);
            loadSettings();
            updateContent();
            logMessage("VDO.Ninja OBS Control Dock Initialized. Welcome!", "logMessages.appInitialized");
            updateVdoNinjaButtonState(false);
            toggleVdoNinjaInputs(false);
            setupSecureFieldsBlur();
            startVdoNinjaConnectionMonitor();
          });
      }


      function updateContent() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n');
          if (key.startsWith('[placeholder]')) {
            element.placeholder = i18next.t(key.substring('[placeholder]'.length));
          } else if (key.startsWith('[title]')) {
            element.title = i18next.t(key.substring('[title]'.length));
          }
           else {
            element.innerHTML = i18next.t(key);
          }
        });

        document.querySelectorAll('.stream-mapping .mapping-stream-id').forEach(input => {
            input.placeholder = i18next.t('streamIdMappings.streamIdPlaceholder');
            input.title = i18next.t('streamIdMappings.streamIdTooltip');
        });
        document.querySelectorAll('.stream-mapping .mapping-label').forEach(input => {
            input.placeholder = i18next.t('streamIdMappings.labelPlaceholder');
            input.title = i18next.t('streamIdMappings.labelTooltip');
        });

        updateObsConnectButtonText();
        updateVdoNinjaButtonState(vdoNinjaConnected);
        updateStreamList();
        updatePrefixLabels();
        setupCollapsibleTooltips();
        updateSceneDropdowns();
        renderLog();
      }

      function setupCollapsibleTooltips() {
          document.querySelectorAll(".collapsible").forEach(header => {
              const isCollapsed = header.classList.contains("collapsed");
              const tooltipKey = isCollapsed ? "collapsible.clickToExpand" : "collapsible.clickToCollapse";
              header.style.setProperty('--before-text', `"${i18next.t(tooltipKey)}"`);
              header.setAttribute('aria-label', i18next.t(tooltipKey));
          });
      }

      languageSelector.addEventListener('change', (event) => {
        const newLang = event.target.value;
        i18next.changeLanguage(newLang, (err, t) => {
          if (err) return console.error('Error changing language:', err);
          localStorage.setItem('vdoNinjaObsControlLanguage', newLang);
          updateContent();
        });
      });

      const obsWsUrlInput = document.getElementById("obsWsUrl");
      const obsWsPasswordInput = document.getElementById("obsWsPassword");
      const obsConnectBtn = document.getElementById("obsConnectBtn");
      const obsConnectionStatus = document.getElementById("obsConnectionStatus");
      const obsStatusIndicator = document.getElementById("obsStatusIndicator");

      const cameraPrefixInput = document.getElementById("cameraPrefix");
      const reactionSubPrefixInput =document.getElementById("reactionSubPrefix");
      const highlightSubPrefixInput = document.getElementById("highlightSubPrefix");
      const cameraSubPrefixLabelText = document.getElementById("cameraSubPrefixLabelText");
      const reactionSubPrefixLabelText = document.getElementById("reactionSubPrefixLabelText");
      const highlightSubPrefixLabelText = document.getElementById("highlightSubPrefixLabelText");

      const vdoNinjaBaseUrlInput = document.getElementById("vdoNinjaBaseUrl");
      const vdoNinjaRoomInput = document.getElementById("vdoNinjaRoom");
      const vdoNinjaPasswordInput = document.getElementById("vdoNinjaPassword");
      const vdoNinjaStreamIdsInput = document.getElementById("vdoNinjaStreamIds");
      const vdoNinjaIframe = document.getElementById("vdoNinjaIframe");

      const obsSceneNameInput = document.getElementById("obsSceneNameInput");
      const obsSceneSelect = document.getElementById("obsSceneSelect");
      const sourceSizingSelect = document.getElementById("sourceSizing");
      const sourceCodecSelect = document.getElementById("sourceCodec");
      const autoAddSourcesCheckbox = document.getElementById("autoAddSources");
      const autoRemoveSourcesCheckbox = document.getElementById("autoRemoveSources");

      const streamListContainer = document.getElementById("streamList");

      const logArea = document.getElementById("logArea");
      const loadScenesBtn = document.getElementById("loadScenesBtn");
      const highlightSceneSelect = document.getElementById("highlightSceneSelect");
      const customCssInput = document.getElementById("customCssInput");
      const customUserCssStyleTag = document.getElementById("customUserCss");


      let obs = null;
      let obsConnected = false;
      let vdoNinjaConnected = false;
      let activeStreams = {};
      let obsScenes = [];
      let requestCallbacks = {};
      let vdoNinjaLastActivityTime = 0;
      let vdoNinjaConnectionCheckTimer = null;
      let screenShareId = null;
      let highlightedStreamId = null;
      let loadedSelectedOtherScenes = [];

      document.querySelectorAll(".collapsible").forEach((header) => {
        const content = header.nextElementSibling;
        const startsExpanded = header.dataset.state === "expand";

        if (startsExpanded) {
          header.classList.remove("collapsed");
          content.classList.remove("collapsed");
          header.setAttribute("data-state", "collapse");
        } else {
          header.classList.add("collapsed");
          content.classList.add("collapsed");
          header.setAttribute("data-state", "expand");
        }

        header.addEventListener("click", function () {
          const isCollapsed = header.classList.toggle("collapsed");
          content.classList.toggle("collapsed");
          const newState = isCollapsed ? "expand" : "collapse";
          header.setAttribute("data-state", newState);
          setupCollapsibleTooltips();
        });
      });


      const vdoNinjaConnectBtn = document.createElement("button");
      vdoNinjaConnectBtn.id = "vdoNinjaConnectBtn";
      vdoNinjaConnectBtn.style.marginTop = "5px";

      const vdoNinjaStatusIndicator = document.createElement("span");
      vdoNinjaStatusIndicator.id = "vdoNinjaStatusIndicator";
      vdoNinjaStatusIndicator.className = "status-indicator";

      const vdoNinjaConnectionStatus = document.createElement("span");
      vdoNinjaConnectionStatus.id = "vdoNinjaConnectionStatus";
      vdoNinjaConnectionStatus.style.marginLeft = "5px";

      const vdoNinjaSettingsContainer = document.querySelector(
        "div.container:nth-child(4) .collapsible-content"
      );
      const buttonsDiv = document.createElement("div");
      buttonsDiv.style.marginTop = "10px";
      buttonsDiv.className = "status-line";
      buttonsDiv.appendChild(vdoNinjaConnectBtn);
      buttonsDiv.appendChild(vdoNinjaConnectionStatus);
      buttonsDiv.appendChild(vdoNinjaStatusIndicator);
      if (vdoNinjaSettingsContainer) {
        vdoNinjaSettingsContainer.appendChild(buttonsDiv);
      } else {
        console.error("VDO.Ninja settings container not found for injecting connect button.");
      }


      vdoNinjaConnectBtn.addEventListener("click", () => {
        if (vdoNinjaConnected) {
          disconnectFromVdoNinja();
        } else {
          connectToVdoNinja();
        }
      });
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function logMessage(fallbackMessage, i18nKey, i18nParams = {}) {
          const timestamp = new Date().toLocaleTimeString();
          logEntries.push({
              timestamp,
              i18nKey,
              i18nParams,
              fallbackMessage
          });
          renderLog();
      }

      function renderLog() {
          if (!logArea || (typeof i18next !== 'undefined' && !i18next.isInitialized)) {
             return;
          }
          let logContent = "";
          logEntries.forEach(entry => {
              let translatedMessage = entry.fallbackMessage;
              if (entry.i18nKey && i18next.exists(entry.i18nKey)) {
                  translatedMessage = i18next.t(entry.i18nKey, entry.i18nParams);
              } else if (entry.i18nKey) {
                // console.warn(`i18n key not found: ${entry.i18nKey}. Using fallback: "${entry.fallbackMessage}"`);
              }
              // Sanitize message before inserting into HTML to prevent XSS
              const safeTranslatedMessage = translatedMessage.replace(/</g, "&lt;").replace(/>/g, "&gt;");
              logContent += `[${entry.timestamp}] ${safeTranslatedMessage}\n`;
          });
          logArea.innerHTML = logContent;
          logArea.scrollTop = logArea.scrollHeight;
      }


      function generateRequestId(type) {
        return `${type}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      }

      function getVdoNinjaBaseUrl() {
        const customUrl = vdoNinjaBaseUrlInput.value.trim();
        return customUrl || "https://vdo.ninja";
      }

      function getFullCameraPrefix() {
        return cameraPrefixInput.value.trim();
      }
      function getFullReactionPrefix() {
        return `${cameraPrefixInput.value.trim()}.${reactionSubPrefixInput.value.trim()}`;
      }
      function getFullHighlightPrefix() {
        return `${cameraPrefixInput.value.trim()}.${highlightSubPrefixInput.value.trim()}`;
      }

      function updatePrefixLabels() {
        if (!i18next.isInitialized) return;
        const cameraPrefixVal = getFullCameraPrefix();
        const reactionSubPrefixVal = reactionSubPrefixInput.value.trim();
        const highlightSubPrefixVal = highlightSubPrefixInput.value.trim();

        cameraSubPrefixLabelText.textContent = i18next.t("obsConnection.cameraPrefixLabel");
        reactionSubPrefixLabelText.textContent = i18next.t("obsConnection.reactionPrefixDynamicLabel", {
            prefix: cameraPrefixVal || "", // Provide a default empty string if prefix is empty
            separator: (cameraPrefixVal && reactionSubPrefixVal) ? "." : "",
            subPrefix: reactionSubPrefixVal || ""
        });
        highlightSubPrefixLabelText.textContent = i18next.t("obsConnection.highlightPrefixDynamicLabel", {
            prefix: cameraPrefixVal || "VDO", // Provide a default if prefix is empty
            separator: (cameraPrefixVal && highlightSubPrefixVal) ? "." : "",
            subPrefix: highlightSubPrefixVal || ""
        });
      }

      cameraPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });
      reactionSubPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });
      highlightSubPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });

      function toggleVdoNinjaInputs(disabled) {
        vdoNinjaBaseUrlInput.disabled = disabled;
        vdoNinjaRoomInput.disabled = disabled;
        vdoNinjaPasswordInput.disabled = disabled;
        vdoNinjaStreamIdsInput.disabled = disabled;
      }

      function updateObsConnectButtonText() {
        if (obsConnectBtn && i18next.isInitialized) {
            obsConnectBtn.textContent = obsConnected ? i18next.t("obsConnection.disconnectButton") : i18next.t("obsConnection.connectButton");
        }
      }


      function updateVdoNinjaButtonState(isVdoConnected) {
        vdoNinjaConnected = isVdoConnected;
        if (!i18next.isInitialized) return;

        if (vdoNinjaConnected) {
          vdoNinjaConnectBtn.textContent = i18next.t("vdoNinjaSettings.disconnectButton");
          vdoNinjaConnectBtn.classList.remove("disconnected");
          vdoNinjaConnectBtn.classList.add("connected");
          vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusConnected");
          vdoNinjaStatusIndicator.classList.add("connected");
          vdoNinjaStatusIndicator.classList.remove("error");
        } else {
          vdoNinjaConnectBtn.textContent = i18next.t("vdoNinjaSettings.connectButton");
          vdoNinjaConnectBtn.classList.remove("connected");
          vdoNinjaConnectBtn.classList.add("disconnected");
          vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusDisconnected");
          vdoNinjaStatusIndicator.classList.remove("connected", "error");
        }
        toggleVdoNinjaInputs(vdoNinjaConnected);
      }

      function applyCustomCss(cssString) {
        if (customUserCssStyleTag) {
            customUserCssStyleTag.textContent = cssString;
        }
      }

      // MODIFICADO: O event listener de 'input' para customCssInput agora apenas salva as configurações
      // e loga uma mensagem. A aplicação do CSS ocorrerá em addStreamToObs, addScreenShareToObs, etc.
      customCssInput.addEventListener('input', () => {
        saveSettings(); // Salva o CSS no localStorage
        logMessage("Custom CSS input changed. It will be applied when a source is next created/updated in OBS.", "logMessages.customCssChangedWillApply");
      });

      function saveSettings() {
        const otherSceneCheckboxes = document.querySelectorAll(
          ".other-scene-checkbox:checked"
        );
        const selectedOtherScenes = Array.from(otherSceneCheckboxes).map(
          (cb) => cb.value
        );

        const settings = {
          obsWsUrl: obsWsUrlInput.value,
          obsWsPassword: obsWsPasswordInput.value,
          cameraPrefix: cameraPrefixInput.value,
          reactionSubPrefix: reactionSubPrefixInput.value,
          highlightSubPrefix: highlightSubPrefixInput.value,
          vdoNinjaBaseUrl: vdoNinjaBaseUrlInput.value,
          vdoNinjaRoom: vdoNinjaRoomInput.value,
          vdoNinjaPassword: vdoNinjaPasswordInput.value,
          vdoNinjaStreamIds: vdoNinjaStreamIdsInput.value,
          obsSceneName: obsSceneSelect.value, // Salva o valor do select, não do input escondido
          selectedOtherScenes: selectedOtherScenes,
          sourceSizing: sourceSizingSelect.value,
          sourceCodec: sourceCodecSelect.value,
          autoAddSources: autoAddSourcesCheckbox.checked,
          autoRemoveSources: autoRemoveSourcesCheckbox.checked,
          screenShareWidth: document.getElementById("screenShareWidth").value,
          screenShareHeight: document.getElementById("screenShareHeight").value,
          screenShareScene:
            document.getElementById("screenShareSceneSelect").value,
          highlightScene: highlightSceneSelect.value,
          language: i18next.language, // Salva o idioma atual
          customCSS: customCssInput.value // Salva o CSS personalizado
        };
        localStorage.setItem("obsNinjaSettings", JSON.stringify(settings));

        const mappings = getStreamMappings();
        localStorage.setItem("obsNinjaStreamMappings", JSON.stringify(mappings));
      }

      function calculateGridPositions(totalSources, canvasWidth, canvasHeight) {
        const positions = [];
        if (totalSources === 0) return positions;

        let cols = Math.ceil(Math.sqrt(totalSources));
        let rows = Math.ceil(totalSources / cols);

        // Ajustes para layouts específicos (ex: 3 fontes em uma linha)
        if (totalSources === 3) {
          cols = 3;
          rows = 1;
        }
        // Adicione mais lógica de ajuste se necessário para outros números

        const cellWidth = canvasWidth / cols;
        const cellHeight = canvasHeight / rows;

        // Centralizar a última linha se não estiver completa
        const itemsInLastRow = totalSources - (rows - 1) * cols;
        let lastRowHorizontalOffset = 0;
        if (rows > 1 && itemsInLastRow > 0 && itemsInLastRow < cols) {
          lastRowHorizontalOffset = ((cols - itemsInLastRow) * cellWidth) / 2;
        }

        for (let i = 0; i < totalSources; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;

          let x = col * cellWidth;
          if (row === rows - 1) { // Se for a última linha
            x += lastRowHorizontalOffset;
          }
          const y = row * cellHeight;
          positions.push({ x, y, width: cellWidth, height: cellHeight });
        }
        return positions;
      }

      function disconnectFromVdoNinja() {
        vdoNinjaIframe.src = "about:blank";
        if (vdoNinjaConnectionCheckTimer) {
          clearTimeout(vdoNinjaConnectionCheckTimer);
          vdoNinjaConnectionCheckTimer = null;
        }
        activeStreams = {}; // Limpa os streams ativos
        updateStreamList();
        updateVdoNinjaButtonState(false); // Atualiza o estado do botão e inputs
        logMessage("Disconnected from VDO.Ninja.", "logMessages.vdoNinja.disconnected");
      }

      function connectToVdoNinja() {
        if (vdoNinjaConnected) {
          logMessage("Already connected to VDO.Ninja.", "logMessages.vdoNinja.alreadyConnected");
          return;
        }

        const room = vdoNinjaRoomInput.value.trim();
        const streamIds = vdoNinjaStreamIdsInput.value.trim();

        if (!room && !streamIds) {
          logMessage(
            "VDO.Ninja Error: Room Name or Stream ID(s) must be provided.",
            "logMessages.vdoNinja.errorRoomOrStreamIdNeeded"
          );
          return;
        }

        initializeVdoNinjaIframe(); // Configura e carrega o iframe
        if (i18next.isInitialized) {
            vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusConnecting");
            vdoNinjaConnectBtn.textContent = i18next.t("vdoNinjaSettings.cancelButton"); // Ou "Connecting..."
        }


        // Inicia um timer para verificar se a conexão foi estabelecida
        if (vdoNinjaConnectionCheckTimer) {
          clearTimeout(vdoNinjaConnectionCheckTimer);
        }
        vdoNinjaConnectionCheckTimer = setTimeout(() => {
          if (
            !vdoNinjaConnected &&
            Date.now() - vdoNinjaLastActivityTime > 10000
          ) {
            // 10 segundos sem atividade
            logMessage(
              "VDO.Ninja connection timed out. No activity received from iframe.",
              "logMessages.vdoNinja.connectionTimeout"
            );
            if (i18next.isInitialized) {
                vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusConnectionFailed");
                vdoNinjaConnectBtn.textContent = i18next.t("vdoNinjaSettings.connectButton");
            }
            vdoNinjaStatusIndicator.classList.add("error");
            toggleVdoNinjaInputs(false); // Reabilita inputs se a conexão falhar
          }
        }, 10000); // Timeout de 10 segundos

        toggleVdoNinjaInputs(true); // Desabilita inputs durante a tentativa de conexão
        saveSettings();
      }

      function addNewStreamMapping(
        streamId = "",
        label = "",
        sceneName = "",
        matchType = "streamId",
        shouldClone = true,
        shouldSwitch = false
      ) {
        const streamMappingsDiv = document.getElementById("streamMappings");
        const mappingDiv = document.createElement("div");
        mappingDiv.className = "stream-mapping";

        // Garante que streamId não seja um objeto de evento se chamado por um event listener
        const initialStreamId =
          streamId instanceof PointerEvent ||
          (typeof streamId === "object" && streamId !== null && streamId.target)
            ? ""
            : streamId;

        mappingDiv.innerHTML = `
              <div style="margin-bottom: 5px;">
                  <label style="font-size: 1em; margin-bottom: 6px; display: block; font-weight:500;" data-i18n="streamIdMappings.ruleTitle">Stream Mapping Rule</label>
                  <div class="flex-row" style="align-items: center; margin-bottom: 6px;">
                      <input type="text" value="${initialStreamId}" class="mapping-stream-id">
                      <input type="text" value="${label}" class="mapping-label">
                      <select class="mapping-match-type" data-i18n="[title]streamIdMappings.matchTypeTooltip" title="How to match stream">
                          <option value="streamId" ${matchType === "streamId" ? "selected" : ""} data-i18n="streamIdMappings.matchType.idOnly">ID Only</option>
                          <option value="label" ${matchType === "label" ? "selected" : ""} data-i18n="streamIdMappings.matchType.labelOnly">Label Only</option>
                          <option value="both" ${matchType === "both" ? "selected" : ""} data-i18n="streamIdMappings.matchType.bothRequired">Both Required</option>
                          <option value="either" ${matchType === "either" ? "selected" : ""} data-i18n="streamIdMappings.matchType.eitherMatch">Either Match</option>
                      </select>
                      <select class="mapping-scene-name" data-i18n="[title]streamIdMappings.targetSceneTooltip" title="Target OBS Scene">
                          </select>
                      <button class="remove-mapping-btn" data-i18n="[title]streamIdMappings.removeRuleTooltip" title="Remove this mapping rule">×</button>
                  </div>
                  <div class="flex-row" style="gap: 15px;">
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-clone-to-main" ${shouldClone ? "checked" : ""}>
                          <span data-i18n="streamIdMappings.cloneToMainSceneLabel">Clone to main scene</span>
                      </label>
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-switch-to-scene" ${shouldSwitch ? "checked" : ""}>
                          <span data-i18n="streamIdMappings.switchToSceneOnAddLabel">Switch to scene on add</span>
                      </label>
                  </div>
                  <small style="color: #8a8a9a; font-size: 0.85em; display: block; margin-top: 4px;" data-i18n="streamIdMappings.ruleDescription">
                      Define how incoming streams are routed to OBS scenes.
                  </small>
              </div>
          `;
        if (i18next.isInitialized) {
            // Traduz elementos dentro do HTML recém-criado
            mappingDiv.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (key.startsWith('[placeholder]')) {
                    element.placeholder = i18next.t(key.substring('[placeholder]'.length));
                } else if (key.startsWith('[title]')) {
                    element.title = i18next.t(key.substring('[title]'.length));
                } else {
                    element.innerHTML = i18next.t(key);
                }
            });

            // Placeholders e tooltips específicos que podem não ser cobertos pelo loop geral
            const streamIdInputElement = mappingDiv.querySelector('.mapping-stream-id');
            if (streamIdInputElement) {
                streamIdInputElement.placeholder = i18next.t('streamIdMappings.streamIdPlaceholder');
                streamIdInputElement.title = i18next.t('streamIdMappings.streamIdTooltip');
            }

            const labelInputElement = mappingDiv.querySelector('.mapping-label');
            if (labelInputElement) {
                labelInputElement.placeholder = i18next.t('streamIdMappings.labelPlaceholder');
                labelInputElement.title = i18next.t('streamIdMappings.labelTooltip');
            }
        }


        streamMappingsDiv.appendChild(mappingDiv);
        const sceneDropdown = mappingDiv.querySelector(".mapping-scene-name");

        populateSceneDropdown(obsScenes, sceneDropdown); // Popula o dropdown de cenas
        if (
          sceneName &&
          obsScenes.some((scene) => scene.sceneName === sceneName)
        ) {
          sceneDropdown.value = sceneName; // Define o valor se uma cena válida foi passada
        }

        const removeBtn = mappingDiv.querySelector(".remove-mapping-btn");
        removeBtn.addEventListener("click", () => {
          mappingDiv.remove();
          saveSettings(); // Salva as configurações após remover um mapeamento
        });

        // Adiciona event listeners para salvar automaticamente ao alterar qualquer input/select no mapeamento
        const inputs = mappingDiv.querySelectorAll("input, select");
        inputs.forEach((input) => {
          input.addEventListener("change", saveSettings);
        });
      }

      function setupStreamMappingUI() {
        const addStreamMappingBtn = document.getElementById(
          "addStreamMappingBtn"
        );
        addStreamMappingBtn.addEventListener("click", () => {
          addNewStreamMapping(); // Adiciona um novo mapeamento em branco
        });
        loadStreamMappings(); // Carrega mapeamentos salvos
      }

      function loadSettings() {
        const settingsJson = localStorage.getItem("obsNinjaSettings");
        let savedLanguage = 'en'; // Default language

        if (settingsJson) {
          try {
            const settings = JSON.parse(settingsJson);
            obsWsUrlInput.value = settings.obsWsUrl || "ws://localhost:4455";
            obsWsPasswordInput.value = settings.obsWsPassword || "";

            cameraPrefixInput.value = settings.cameraPrefix || "VDO";
            reactionSubPrefixInput.value = settings.reactionSubPrefix || "Screen";
            highlightSubPrefixInput.value =
              settings.highlightSubPrefix || "Highlight";

            vdoNinjaBaseUrlInput.value =
              settings.vdoNinjaBaseUrl || "https://vdo.ninja";
            vdoNinjaRoomInput.value = settings.vdoNinjaRoom || "";
            vdoNinjaPasswordInput.value = settings.vdoNinjaPassword || "";
            vdoNinjaStreamIdsInput.value = settings.vdoNinjaStreamIds || "";

            // obsSceneNameInput.value = settings.obsSceneName || ""; // Input escondido
            // obsSceneSelect.value = settings.obsSceneName || ""; // O select principal
            // A seleção do obsSceneSelect será feita após fetchObsScenes

            loadedSelectedOtherScenes = settings.selectedOtherScenes || []; // Carrega cenas selecionadas

            sourceSizingSelect.value = settings.sourceSizing || "defaultSize";
            sourceCodecSelect.value = settings.sourceCodec || "";
            autoAddSourcesCheckbox.checked =
              settings.autoAddSources !== false; // Default true
            autoRemoveSourcesCheckbox.checked =
              settings.autoRemoveSources !== false; // Default true

            const screenShareWidthInput =
              document.getElementById("screenShareWidth");
            const screenShareHeightInput =
              document.getElementById("screenShareHeight");
            // const screenShareSceneSelect = document.getElementById("screenShareSceneSelect"); // Será definido após fetchObsScenes
            // const highlightSceneSelectElement = document.getElementById("highlightSceneSelect"); // Será definido após fetchObsScenes

            if (screenShareWidthInput)
              screenShareWidthInput.value = settings.screenShareWidth || "1920";
            if (screenShareHeightInput)
              screenShareHeightInput.value =
                settings.screenShareHeight || "1080";
            // if (screenShareSceneSelect) screenShareSceneSelect.value = settings.screenShareScene || "";
            // if (highlightSceneSelectElement) highlightSceneSelectElement.value = settings.highlightScene || "";

            savedLanguage = settings.language || 'en';
            languageSelector.value = savedLanguage; // Define o seletor de idioma

            // Carrega e aplica o CSS personalizado
            if (settings.customCSS && customCssInput && customUserCssStyleTag) {
                customCssInput.value = settings.customCSS;
                applyCustomCss(settings.customCSS); // Aplica o CSS na carga
            }


            // Loga apenas se i18next estiver pronto
            if (i18next.isInitialized) {
                logMessage("Settings loaded from localStorage.", "logMessages.settingsLoaded");
            } else {
                console.log("Settings loaded from localStorage (i18next not ready for log).");
            }

          } catch (e) {
            // Loga apenas se i18next estiver pronto
            if (i18next.isInitialized) {
                logMessage(
                `Error loading settings from localStorage: ${e.message}. Using defaults.`,
                "logMessages.errorLoadingSettings", { message: e.message }
                );
            } else {
                console.error(`Error loading settings from localStorage: ${e.message}. Using defaults.`);
            }
            // Define padrões se houver erro
            cameraPrefixInput.value = "VDO";
            reactionSubPrefixInput.value = "Screen";
            highlightSubPrefixInput.value = "Highlight";
            vdoNinjaBaseUrlInput.value = "https://vdo.ninja";
            sourceSizingSelect.value = "defaultSize";
            sourceCodecSelect.value = "";
          }
        } else {
           // Loga apenas se i18next estiver pronto
           if (i18next.isInitialized) {
                logMessage("No saved settings found. Using default values.", "logMessages.noSavedSettings");
           } else {
                console.log("No saved settings found. Using default values.");
           }
          // Define padrões se não houver configurações salvas
          cameraPrefixInput.value = "VDO";
          reactionSubPrefixInput.value = "Screen";
          highlightSubPrefixInput.value = "Highlight";
          vdoNinjaBaseUrlInput.value = "https://vdo.ninja";
          sourceSizingSelect.value = "defaultSize";
          sourceCodecSelect.value = "";
        }

        setupStreamMappingUI(); // Configura a UI de mapeamento de streams
        return savedLanguage; // Retorna o idioma carregado para i18next
      }

      function updateOtherScenesList() {
        const mainSceneName = obsSceneSelect.value;
        const otherScenesListDiv = document.getElementById("otherScenesList");
        const container = document.getElementById("otherScenesContainer");

        otherScenesListDiv.innerHTML = ""; // Limpa a lista existente

        if (mainSceneName && obsScenes && obsScenes.length > 1) {
          container.style.display = "block"; // Mostra o container
          obsScenes.forEach((scene) => {
            if (scene.sceneName !== mainSceneName) {
              const checkboxId = `otherScene_${scene.sceneName.replace(
                /\s+/g,
                "_"
              )}`; // ID único para o checkbox
              const listItem = document.createElement("div");
              listItem.className = "checkbox-label";
              listItem.style.marginBottom = "8px";

              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.id = checkboxId;
              checkbox.value = scene.sceneName;
              checkbox.className = "other-scene-checkbox";

              // Verifica se esta cena estava selecionada anteriormente
              if (loadedSelectedOtherScenes.includes(scene.sceneName)) {
                checkbox.checked = true;
              }
              checkbox.addEventListener("change", saveSettings); // Salva ao alterar

              const label = document.createElement("label");
              label.htmlFor = checkboxId;
              label.textContent = scene.sceneName;
              label.style.marginLeft = "0"; // Ajuste para o label do checkbox

              listItem.appendChild(checkbox);
              listItem.appendChild(label);
              otherScenesListDiv.appendChild(listItem);
            }
          });
          // Esconde o container se não houver outras cenas para listar
          if (otherScenesListDiv.childElementCount === 0) {
            container.style.display = "none";
          }
        } else {
          container.style.display = "none"; // Esconde se não houver cena principal ou outras cenas
        }
      }

      function updateStreamList() {
        if (!i18next.isInitialized) return; // Garante que i18next está pronto
        if (Object.keys(activeStreams).length === 0) {
          streamListContainer.innerHTML =
            `<div class="stream-item" style="text-align:center; background-color:transparent; border:none; color:#888;">${i18next.t("activeStreams.noActiveStreams")}</div>`;
          return;
        }
        streamListContainer.innerHTML = ""; // Limpa a lista

        for (const streamId in activeStreams) {
          if (Object.hasOwnProperty.call(activeStreams, streamId)) {
            const stream = activeStreams[streamId];
            const streamDiv = document.createElement("div");
            streamDiv.className = "stream-item";

            const targetInfo = getTargetSceneForStream(streamId, stream.label);
            const targetSceneName = targetInfo.scene;
            const isDefaultScene = targetSceneName === getTargetScene(); // Cena principal

            const isHighlighted = highlightedStreamId === streamId;
            const isCurrentlyScreenSharingThisStream = screenShareId === streamId;

            let streamItemHTML = `
                      <div style="font-weight: 600; font-size: 1.05em; color: #E0E0E0;">${
                        stream.label || streamId
                      }</div>
                      <small>${i18next.t("activeStreams.streamIdLabel", {id: streamId})}${
              stream.label ? ` | ${i18next.t("activeStreams.labelLabel", {label: stream.label})}` : ""
            }</small>
                      <small style="display: block; color: #A0A0B0;">
                          → ${i18next.t("activeStreams.targetSceneLabelText", {sceneName: targetSceneName || i18next.t("activeStreams.notSet")})}
                          ${
                            isDefaultScene && targetSceneName
                              ? `(${i18next.t("activeStreams.defaultSceneTag")})`
                              : targetSceneName
                              ? `(${i18next.t("activeStreams.mappedSceneTag")})`
                              : ""
                          }
                      </small>
                      <div style="margin-top: 2px; font-size: 0.9em;">
                        ${
                          stream.sourceCreated
                            ? `<span style="color:#28A745">${i18next.t("activeStreams.addedToObs")}</span>`
                            : `<span style="color:#FFC107">${i18next.t("activeStreams.notInObs")}</span>`
                        }
                      </div>
                      <div style="margin-top: 8px;" class="flex-row">`; // flex-row para botões

            // Botão Adicionar/Remover do OBS
            streamItemHTML += `
                      <button class="add-stream-btn" data-stream-id="${streamId}"
                          style="background-color: ${
                            stream.sourceCreated ? "#F44336" : "#4C80AF"
                          };">
                              ${
                                stream.sourceCreated
                                  ? i18next.t("activeStreams.buttons.removeFromObs")
                                  : i18next.t("activeStreams.buttons.addToObs")
                              }
                      </button>`;

            // Botão Highlight (apenas se a fonte foi criada)
            if (stream.sourceCreated) {
              streamItemHTML += `
                          <button class="highlight-btn" data-stream-id="${streamId}"
                              style="background-color: ${
                                isHighlighted ? "#F44336" : "#4CAF50"
                              };">
                                  ${
                                    isHighlighted
                                      ? i18next.t("activeStreams.buttons.unhighlight")
                                      : i18next.t("activeStreams.buttons.highlight")
                                  }
                          </button>`;
            }

            // Botão Screen Share (apenas se a fonte foi criada)
            if (stream.sourceCreated) {
              streamItemHTML += `
                          <button class="screen-share-btn" data-stream-id="${streamId}"
                                  style="background-color: ${
                                    isCurrentlyScreenSharingThisStream
                                      ? "#F44336"
                                      : "#9C27B0"
                                  };">
                              ${
                                isCurrentlyScreenSharingThisStream
                                  ? i18next.t("activeStreams.buttons.stopScreenShare")
                                  : i18next.t("activeStreams.buttons.screenShare")
                              }
                          </button>`;
            }
            streamItemHTML += `</div>`; // Fecha flex-row
            streamDiv.innerHTML = streamItemHTML;
            streamListContainer.appendChild(streamDiv);

            // Adiciona event listeners aos botões
            const addRemoveBtn = streamDiv.querySelector(".add-stream-btn");
            if (addRemoveBtn) {
              addRemoveBtn.addEventListener("click", () => {
                if (stream.sourceCreated) {
                  removeStreamFromObs(streamId);
                } else {
                  addStreamToObs(streamId, stream.label, targetInfo);
                }
              });
            }
            const highlightBtn = streamDiv.querySelector(".highlight-btn");
            if (highlightBtn) {
              highlightBtn.addEventListener("click", async () => {
                await handleHighlightClick(streamId, stream.label, targetInfo);
              });
            }
            const screenShareBtn = streamDiv.querySelector(".screen-share-btn");
            if (screenShareBtn) {
              screenShareBtn.addEventListener("click", async () => {
                await handleScreenShareClick(streamId, stream.label);
              });
            }
          }
        }
      }

      async function handleHighlightClick(
        clickedStreamId,
        clickedStreamLabel,
        clickedTargetInfo
      ) {
        if (!obsConnected || !obs) {
          logMessage("Cannot highlight: Not connected to OBS.", "logMessages.obs.cannotHighlightNotConnected");
          return;
        }

        // Se um screen share estiver ativo, pare-o antes de destacar
        if (screenShareId) {
          logMessage(
            `A screen share is active (${screenShareId}). Stopping it before highlighting.`,
            "logMessages.obs.stoppingScreenShareForHighlight", { id: screenShareId }
          );
          await removeScreenShareFromObs(screenShareId); // Remove o screen share existente
        }

        const newHighlightScene = highlightSceneSelect.value; // Cena de highlight selecionada
        await toggleHighlight(
          clickedStreamId,
          clickedStreamLabel,
          clickedTargetInfo
        ); // Lógica principal de highlight

        // Se um stream foi destacado E uma cena de highlight está definida, mude para ela
        if (highlightedStreamId && newHighlightScene) {
          try {
            const studio = await sendRequest("GetStudioModeEnabled");
            if (studio.studioModeEnabled) {
              logMessage(
                `Studio Mode Enabled - Triggering scene switch to Highlight Scene: '${newHighlightScene}'.`,
                "logMessages.obs.studioModeSwitchHighlight", { sceneName: newHighlightScene }
              );
              await sendRequest("SetCurrentPreviewScene", {
                sceneName: newHighlightScene,
              });
              await sleep(100); // Pequena pausa para garantir que a preview foi definida
              await sendRequest("TriggerStudioModeTransition");
            } else {
              logMessage(
                `Triggering scene switch to Highlight Scene: '${newHighlightScene}'.`,
                "logMessages.obs.switchingToHighlightScene", { sceneName: newHighlightScene }
              );
              await sendRequest("SetCurrentProgramScene", {
                sceneName: newHighlightScene,
              });
            }
          } catch (e) {
            logMessage(
              `Error switching to highlight scene '${newHighlightScene}': ${e.message}`,
              "logMessages.obs.errorSwitchingHighlightScene", { sceneName: newHighlightScene, message: e.message }
            );
          }
        }
      }

      async function handleScreenShareClick(streamId, streamLabel) {
        const clickedStreamIdForScreenShare = streamId;
        const currentActiveScreenShareGlobal = screenShareId; // ID do screen share ativo globalmente

        if (currentActiveScreenShareGlobal === clickedStreamIdForScreenShare) {
          // Se clicou no stream que já está compartilhando, pare o compartilhamento
          await removeScreenShareFromObs(clickedStreamIdForScreenShare);
        } else {
          // Iniciar um novo screen share ou trocar para um novo
          if (!obsConnected || !obs) {
            logMessage("Cannot start screen share: Not connected to OBS.", "logMessages.obs.cannotScreenShareNotConnected");
            return;
          }

          // Se uma câmera estiver destacada, desfaça o destaque antes de iniciar o screen share
          if (highlightedStreamId) {
            logMessage(
              `A camera is highlighted (${highlightedStreamId}). Unhighlighting it before starting screen share.`,
              "logMessages.obs.unhighlightingForScreenShare", { id: highlightedStreamId }
            );
            const oldHighlightDetails = activeStreams[highlightedStreamId];
            const oldHighlightLabel = oldHighlightDetails
              ? oldHighlightDetails.label
              : "";
            const oldHighlightTargetInfo = getTargetSceneForStream(
              highlightedStreamId,
              oldHighlightLabel
            );
            await toggleHighlight(
              highlightedStreamId,
              oldHighlightLabel,
              oldHighlightTargetInfo
            ); // Desfaz o highlight
          }

          // Adiciona/atualiza a fonte de screen share no OBS
          const screenShareScene =
            document.getElementById("screenShareSceneSelect").value ||
            getTargetScene(); // Usa a cena de screen share ou a principal

          await addScreenShareToObs(clickedStreamIdForScreenShare, streamLabel);

          // Se o screen share foi configurado com sucesso E uma cena de screen share está definida, mude para ela
          if (screenShareId && screenShareScene) {
            try {
              const studio = await sendRequest("GetStudioModeEnabled");
              if (studio.studioModeEnabled) {
                logMessage(
                  `Studio Mode Enabled - Triggering scene switch to Screen Share Scene: '${screenShareScene}'.`,
                  "logMessages.obs.studioModeSwitchScreenShare", { sceneName: screenShareScene }
                );
                await sendRequest("SetCurrentPreviewScene", {
                  sceneName: screenShareScene,
                });
                await sleep(100);
                await sendRequest("TriggerStudioModeTransition");
              } else {
                logMessage(
                  `Triggering scene switch to Screen Share Scene: '${screenShareScene}'.`,
                  "logMessages.obs.switchingToScreenShareScene", { sceneName: screenShareScene }
                );
                await sendRequest("SetCurrentProgramScene", {
                  sceneName: screenShareScene,
                });
              }
            } catch (e) {
              logMessage(
                `Error switching to screen share scene '${screenShareScene}': ${e.message}`,
                "logMessages.obs.errorSwitchingScreenShareScene", { sceneName: screenShareScene, message: e.message }
              );
            }
          }
        }
      }

      async function addScreenShareToObs(streamId, streamLabel) {
        const previousGlobalScreenShareId = screenShareId; // Salva o ID anterior para rollback em caso de erro

        if (!obsConnected || !obs) {
          logMessage("Cannot add screen share: Not connected to OBS.", "logMessages.obs.cannotAddScreenShareNotConnected");
          updateStreamList(); // Atualiza a UI para refletir o estado
          return;
        }

        const room = vdoNinjaRoomInput.value.trim();
        if (!room) {
          logMessage(
            "Cannot add screen share: VDO.Ninja Room name is required for screen sharing URLs.",
            "logMessages.obs.cannotAddScreenShareNoRoom"
          );
          updateStreamList();
          return;
        }

        screenShareId = streamId; // Define o streamId globalmente como o que está compartilhando tela

        const width =
          parseInt(document.getElementById("screenShareWidth").value) || 1920;
        const height =
          parseInt(document.getElementById("screenShareHeight").value) || 1080;
        const screenShareSceneSelect = document.getElementById(
          "screenShareSceneSelect"
        );
        let targetSceneName =
          screenShareSceneSelect.value || getTargetScene(); // Usa a cena de screen share ou a principal

        if (!targetSceneName) {
          logMessage(
            "Cannot add screen share: Target OBS scene is required.",
            "logMessages.obs.cannotAddScreenShareNoTargetScene"
          );
          screenShareId = previousGlobalScreenShareId; // Restaura o ID anterior
          updateStreamList();
          return;
        }

        const sourceName = `${getFullReactionPrefix()}_${streamId}:s`; // Nome da fonte de screen share
        const baseUrl = getVdoNinjaBaseUrl();
        const selectedCodec = sourceCodecSelect.value;

        // Constrói a URL de screen share do VDO.Ninja
        let screenShareUrl = `${baseUrl}/?view=${encodeURIComponent(
          streamId
        )}:s&solo&room=${encodeURIComponent(room)}`;
        if (selectedCodec && selectedCodec !== "") {
          screenShareUrl += `&codec=${encodeURIComponent(selectedCodec)}`;
        } else {
          screenShareUrl += `&codec=vp9`; // Default codec para screen share se nenhum for selecionado
        }

        if (vdoNinjaPasswordInput.value) {
          screenShareUrl += `&password=${encodeURIComponent(
            vdoNinjaPasswordInput.value
          )}`;
        }
        screenShareUrl += "&cleanoutput&transparent&proaudio"; // Parâmetros comuns

        const inputSettings = {
          url: screenShareUrl,
          width: width,
          height: height,
          fps: 30, // FPS padrão
          reroute_audio: true,
          restart_when_active: false, // Não reiniciar ao se tornar ativo
          shutdown: false, // Não desligar a fonte quando não estiver visível
        };

        logMessage(
          `Adding/Updating screen share source '${sourceName}' (URL: ${screenShareUrl}) to scene '${targetSceneName}'`,
          "logMessages.obs.addingUpdatingScreenShare", { sourceName, url: screenShareUrl, sceneName: targetSceneName }
        );

        try {
          // Verifica se já existe uma fonte de screen share com o mesmo prefixo (de outro stream)
          const sourcesResponse = await sendRequest("GetInputList", {}, { suppressNotFound: true });
          const existingSourceWithSamePrefix = sourcesResponse.inputs.find(
            (input) =>
              input.inputName.startsWith(getFullReactionPrefix() + "_") &&
              input.inputName.endsWith(":s") && // Garante que é um sufixo de screen share
              input.inputName !== sourceName && // Não é a fonte atual
              input.inputKind === "browser_source"
          );

          if (existingSourceWithSamePrefix) {
            // Se existir, reconfigura a fonte antiga para a nova URL e renomeia
            logMessage(
              `Reconfiguring existing screen share source '${existingSourceWithSamePrefix.inputName}' to be '${sourceName}'.`,
              "logMessages.obs.reconfiguringExistingScreenShare", { oldName: existingSourceWithSamePrefix.inputName, newName: sourceName }
            );
            await sendRequest("SetInputSettings", {
              inputName: existingSourceWithSamePrefix.inputName,
              inputSettings: inputSettings,
            });
            if (existingSourceWithSamePrefix.inputName !== sourceName) {
              await sendRequest("SetInputName", {
                inputName: existingSourceWithSamePrefix.inputName,
                newInputName: sourceName,
              });
            }
            logMessage(
              `Reconfigured and renamed existing screen share source to '${sourceName}'.`,
              "logMessages.obs.reconfiguredRenamedScreenShare", { sourceName }
            );
          } else {
            // Se não houver outra fonte de screen share, verifica se a fonte exata já existe
            const exactSourceExists = sourcesResponse.inputs.find(
              (input) =>
                input.inputName === sourceName &&
                input.inputKind === "browser_source"
            );
            if (exactSourceExists) {
              // Se a fonte exata já existe, apenas atualiza suas configurações
              logMessage(
                `Screen share source '${sourceName}' already exists. Updating its settings.`,
                "logMessages.obs.screenShareExistsUpdating", { sourceName }
              );
              await sendRequest("SetInputSettings", {
                inputName: sourceName,
                inputSettings: inputSettings,
              });
            } else {
              // Se a fonte não existe, cria uma nova
              logMessage(`Creating new screen share source '${sourceName}'.`, "logMessages.obs.creatingNewScreenShare", { sourceName });
              await sendRequest("CreateInput", {
                sceneName: targetSceneName,
                inputName: sourceName,
                inputKind: "browser_source",
                inputSettings,
                sceneItemEnabled: true, // Torna visível por padrão
              });
            }
          }

          // Garante que o item da cena existe e está habilitado
          let sceneItemId;
          try {
            const itemInfo = await sendRequest(
              "GetSceneItemId",
              { sceneName: targetSceneName, sourceName: sourceName },
              { suppressNotFound: true } // Não logar erro se não encontrar
            );
            sceneItemId = itemInfo.sceneItemId;
            logMessage(
              `Source '${sourceName}' found in scene '${targetSceneName}', item ID: ${sceneItemId}. Ensuring it's enabled.`,
              "logMessages.obs.sourceFoundInSceneEnabled", { sourceName, sceneName: targetSceneName, itemId: sceneItemId }
            );
            await sendRequest("SetSceneItemEnabled", {
              sceneName: targetSceneName,
              sceneItemId: sceneItemId,
              sceneItemEnabled: true,
            });
          } catch (e) {
            // Se o item da cena não for encontrado, cria-o
            if (
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("600") // Código de erro para "não encontrado"
            ) {
              logMessage(
                `Source '${sourceName}' not found as an item in scene '${targetSceneName}'. Creating scene item.`,
                "logMessages.obs.sourceNotFoundCreatingItem", { sourceName, sceneName: targetSceneName }
              );
              const createItemResponse = await sendRequest("CreateSceneItem", {
                sceneName: targetSceneName,
                sourceName: sourceName,
              });
              sceneItemId = createItemResponse.sceneItemId;
              logMessage(
                `Created scene item for '${sourceName}' in '${targetSceneName}', item ID: ${sceneItemId}.`,
                "logMessages.obs.createdSceneItem", { sourceName, sceneName: targetSceneName, itemId: sceneItemId }
              );
            } else {
              throw e; // Relança outros erros
            }
          }

          // Aplica a transformação (tamanho e posição)
          if (sceneItemId) {
            const transform = calculateTransform(
              "defaultSize", // Ou outro modo de dimensionamento se necessário para screen share
              width,
              height,
              width, // Usando a largura/altura da fonte para o canvas aqui, pois é um screen share
              height
            );
            await sendRequest("SetSceneItemTransform", {
              sceneName: targetSceneName,
              sceneItemId: sceneItemId,
              sceneItemTransform: transform,
            });
            logMessage(
              `Applied transform to screen share source '${sourceName}' in '${targetSceneName}'.`,
              "logMessages.obs.appliedTransformScreenShare", { sourceName, sceneName: targetSceneName }
            );
          }
          logMessage(
            `Successfully configured screen share for stream ${streamId} (${streamLabel}).`,
            "logMessages.obs.successConfigScreenShare", { streamId, label: streamLabel }
          );

          // MODIFICADO: Aplicar CSS personalizado após a configuração da fonte de screen share
          if (customCssInput.value.trim() !== "") {
            applyCustomCss(customCssInput.value);
            logMessage("Custom CSS applied after screen share configuration.", "logMessages.customCssAppliedAfterScreenShare");
          }

        } catch (error) {
          logMessage(
            `Error adding/updating screen share source '${sourceName}': ${error.message}.`,
            "logMessages.obs.errorAddingUpdatingScreenShare", { sourceName, message: error.message }
          );
          screenShareId = previousGlobalScreenShareId; // Restaura o ID global em caso de erro
        } finally {
          updateStreamList(); // Atualiza a UI
        }
      }

      async function toggleHighlight(
        clickedStreamId,
        clickedStreamLabel,
        clickedTargetInfo
      ) {
        if (!obsConnected || !obs) {
          logMessage("Cannot toggle highlight: Not connected to OBS.", "logMessages.obs.cannotToggleHighlightNotConnected");
          return;
        }

        const previouslyGlobalHighlightedStreamId = highlightedStreamId;
        const camPrefix = getFullCameraPrefix();
        const hlPrefix = getFullHighlightPrefix();

        // 1. Se outro stream estava destacado, desfaça o highlight dele primeiro
        if (
          previouslyGlobalHighlightedStreamId &&
          previouslyGlobalHighlightedStreamId !== clickedStreamId
        ) {
          logMessage(
            `Switching highlight: Unhighlighting previous stream ${previouslyGlobalHighlightedStreamId}.`,
            "logMessages.obs.switchingHighlightUnhighlightPrevious", { id: previouslyGlobalHighlightedStreamId }
          );
          const oldStreamDetails =
            activeStreams[previouslyGlobalHighlightedStreamId];
          const oldStreamLabel = oldStreamDetails ? oldStreamDetails.label : "";
          const oldTargetInfo = getTargetSceneForStream(
            previouslyGlobalHighlightedStreamId,
            oldStreamLabel
          ); // Pega as informações de cena do stream antigo

          const oldHighlightedSourceName = `${hlPrefix}_${previouslyGlobalHighlightedStreamId}`;
          const oldOriginalSourceName = `${camPrefix}_${previouslyGlobalHighlightedStreamId}`;

          try {
            // Tenta renomear de volta para o nome original
            await sendRequest(
              "GetInputSettings",
              { inputName: oldHighlightedSourceName },
              { suppressNotFound: true }
            ); // Verifica se a fonte destacada existe
            await sendRequest("SetInputName", {
              inputName: oldHighlightedSourceName,
              newInputName: oldOriginalSourceName,
            });
            logMessage(
              `Stream ${previouslyGlobalHighlightedStreamId} unhighlighted (renamed from ${oldHighlightedSourceName} to ${oldOriginalSourceName}).`,
              "logMessages.obs.streamUnhighlighted", { id: previouslyGlobalHighlightedStreamId, oldName: oldHighlightedSourceName, newName: oldOriginalSourceName }
            );

            // Se estiver usando autoGrid, rearranje as fontes na cena do stream antigo
            if (sourceSizingSelect.value === "autoGrid") {
              if (oldTargetInfo.scene)
                await rearrangeAllStreamsInScene(oldTargetInfo.scene);
              // E na cena principal se clonado
              if (
                oldTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== oldTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600")); // Código de erro para "não encontrado"
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error unhighlighting previous stream ${previouslyGlobalHighlightedStreamId} (from ${oldHighlightedSourceName}): ${e.message}`,
                "logMessages.obs.errorUnhighlightingPrevious", { id: previouslyGlobalHighlightedStreamId, sourceName: oldHighlightedSourceName, message: e.message }
              );
            }
            // Mesmo com erro, continue, pois o objetivo é destacar o novo
          }
        }

        // 2. Lida com o stream clicado
        const clickedOriginalSourceName = `${camPrefix}_${clickedStreamId}`;
        const clickedNewHighlightedSourceName = `${hlPrefix}_${clickedStreamId}`;

        if (previouslyGlobalHighlightedStreamId === clickedStreamId) {
          // Clicou no stream que já estava destacado: Desfaça o highlight
          logMessage(`Unhighlighting clicked stream ${clickedStreamId}.`, "logMessages.obs.unhighlightingClicked", { id: clickedStreamId });
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: clickedNewHighlightedSourceName },
              { suppressNotFound: true }
            );
            await sendRequest("SetInputName", {
              inputName: clickedNewHighlightedSourceName,
              newInputName: clickedOriginalSourceName,
            });
            highlightedStreamId = null; // Limpa o ID global de highlight
            logMessage(
              `Stream ${clickedStreamId} successfully unhighlighted (renamed to ${clickedOriginalSourceName}).`,
              "logMessages.obs.streamSuccessfullyUnhighlighted", { id: clickedStreamId, newName: clickedOriginalSourceName }
            );

            if (sourceSizingSelect.value === "autoGrid") {
              if (clickedTargetInfo.scene)
                await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
              if (
                clickedTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== clickedTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error unhighlighting ${clickedStreamId} (from ${clickedNewHighlightedSourceName}): ${e.message}`,
                "logMessages.obs.errorUnhighlightingClicked", { id: clickedStreamId, sourceName: clickedNewHighlightedSourceName, message: e.message }
              );
            }
            highlightedStreamId = null; // Garante que está limpo mesmo em erro
          }
        } else {
          // Clicou em um novo stream para destacar (ou nenhum estava destacado antes)
          logMessage(`Highlighting clicked stream ${clickedStreamId}.`, "logMessages.obs.highlightingClicked", { id: clickedStreamId });
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: clickedOriginalSourceName },
              { suppressNotFound: true }
            ); // Verifica se a fonte original existe
            await sendRequest("SetInputName", {
              inputName: clickedOriginalSourceName,
              newInputName: clickedNewHighlightedSourceName,
            });
            highlightedStreamId = clickedStreamId; // Define o novo ID global de highlight
            logMessage(
              `Stream ${clickedStreamId} successfully highlighted (renamed to ${clickedNewHighlightedSourceName}).`,
              "logMessages.obs.streamSuccessfullyHighlighted", { id: clickedStreamId, newName: clickedNewHighlightedSourceName }
            );

            if (sourceSizingSelect.value === "autoGrid") {
              if (clickedTargetInfo.scene)
                await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
              if (
                clickedTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== clickedTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error highlighting ${clickedStreamId} (from ${clickedOriginalSourceName}): ${e.message}`,
                "logMessages.obs.errorHighlightingClicked", { id: clickedStreamId, sourceName: clickedOriginalSourceName, message: e.message }
              );
            } else {
              // Se a fonte original não foi encontrada, mas a destacada talvez já exista (estado inconsistente?)
              // Verifica se a fonte destacada já existe para definir o highlightedStreamId corretamente
              try {
                await sendRequest(
                  "GetInputSettings",
                  { inputName: clickedNewHighlightedSourceName },
                  { suppressNotFound: true }
                );
                highlightedStreamId = clickedStreamId; // Assume que já estava destacada
              } catch (e2) {
                // Se nem a original nem a destacada existem, limpa o highlight
                if (highlightedStreamId === clickedStreamId)
                  highlightedStreamId = null;
              }
            }
            // Se o erro não foi "não encontrado", mas o ID de highlight foi definido, limpe-o
            if (
              highlightedStreamId === clickedStreamId &&
              isNotFoundOrDoesNotExist
            ) {
              // Mantém, pois pode ser que a fonte já estava destacada
            } else if (highlightedStreamId === clickedStreamId) {
              highlightedStreamId = null; // Limpa se houve outro erro
            }
          }
        }
        updateStreamList();
        saveSettings(); // Salva o estado do highlightedStreamId implicitamente através da UI
        
        // MODIFICADO: Aplicar CSS personalizado após a operação de highlight/unhighlight
        if (customCssInput.value.trim() !== "") {
            applyCustomCss(customCssInput.value);
            logMessage("Custom CSS applied after highlight toggle.", "logMessages.customCssAppliedAfterHighlight");
        }
      }

      obsConnectBtn.addEventListener("click", () => {
        if (obsConnected && obs) {
          logMessage("Disconnecting from OBS WebSocket...", "logMessages.obs.disconnecting");
          if (obs) {
            obs.onclose = null; // Remove o handler para evitar reconexão ou logs duplicados
            obs.close();
            obs = null;
          }
          onObsDisconnected(); // Chama a função de limpeza de desconexão
        } else {
          connectToOBS();
        }
      });

      function getTargetSceneForStream(streamId, streamLabel = "") {
        const mappings = getStreamMappings();
        const defaultTargetScene = getTargetScene(); // Cena principal definida nas configurações

        for (const mapping of mappings) {
          let isMatch = false;
          switch (mapping.matchType) {
            case "streamId":
              isMatch = mapping.streamId && streamId === mapping.streamId;
              break;
            case "label":
              isMatch =
                mapping.label && streamLabel && streamLabel === mapping.label;
              break;
            case "both":
              isMatch =
                mapping.streamId &&
                mapping.label &&
                streamId === mapping.streamId &&
                streamLabel === mapping.label;
              break;
            case "either":
              isMatch =
                (mapping.streamId && streamId === mapping.streamId) ||
                (mapping.label &&
                  streamLabel &&
                  streamLabel === mapping.label);
              break;
          }
          if (isMatch && mapping.sceneName) {
            return { scene: mapping.sceneName, mapping: mapping }; // Retorna a cena mapeada e a regra
          }
        }
        return { scene: defaultTargetScene, mapping: null }; // Retorna a cena padrão se nenhum mapeamento corresponder
      }

      function updateSceneDropdowns() {
        if (!i18next.isInitialized) return;

        // Salva os valores atuais para tentar restaurá-los
        const currentMainSceneValue = obsSceneSelect.value;
        const currentScreenShareSceneValue = document.getElementById(
          "screenShareSceneSelect"
        ).value;
        const currentHighlightSceneValue = highlightSceneSelect.value;
        const mappingSceneSelects =
          document.querySelectorAll(".mapping-scene-name");
        const currentMappingSceneValues = Array.from(mappingSceneSelects).map(
          (select) => select.value
        );

        // Popula todos os dropdowns de cena
        populateSceneDropdown(obsScenes, obsSceneSelect);
        populateSceneDropdown(obsScenes, document.getElementById("screenShareSceneSelect"));
        populateSceneDropdown(obsScenes, highlightSceneSelect);

        // Restaura os valores se ainda forem válidos
        if (
          currentMainSceneValue &&
          obsScenes.some((scene) => scene.sceneName === currentMainSceneValue)
        ) {
          obsSceneSelect.value = currentMainSceneValue;
        }
        if (
          currentScreenShareSceneValue === "" || // Permite "Same as main"
          (currentScreenShareSceneValue &&
            obsScenes.some(
              (scene) => scene.sceneName === currentScreenShareSceneValue
            ))
        ) {
          document.getElementById("screenShareSceneSelect").value =
            currentScreenShareSceneValue;
        }
        if (
          currentHighlightSceneValue &&
          obsScenes.some(
            (scene) => scene.sceneName === currentHighlightSceneValue
          )
        ) {
          highlightSceneSelect.value = currentHighlightSceneValue;
        }

        // Restaura valores para os dropdowns de mapeamento
        mappingSceneSelects.forEach((select, index) => {
          populateSceneDropdown(obsScenes, select); // Popula primeiro
          if (
            currentMappingSceneValues[index] &&
            obsScenes.some(
              (scene) => scene.sceneName === currentMappingSceneValues[index]
            )
          ) {
            select.value = currentMappingSceneValues[index];
          }
        });
        updateOtherScenesList(); // Atualiza a lista de "outras cenas" baseada na cena principal
      }

      function loadStreamMappings() {
        const mappingsJson = localStorage.getItem("obsNinjaStreamMappings");
        if (mappingsJson) {
          try {
            const mappings = JSON.parse(mappingsJson);
            mappings.forEach((mapping) => {
              addNewStreamMapping(
                mapping.streamId,
                mapping.label,
                mapping.sceneName,
                mapping.matchType,
                mapping.cloneToMain !== undefined ? mapping.cloneToMain : true, // Default true
                mapping.switchToScene !== undefined
                  ? mapping.switchToScene
                  : false // Default false
              );
            });
            // Se as cenas do OBS já foram carregadas, atualize os dropdowns dos mapeamentos
            if (obsScenes && obsScenes.length > 0) {
              updateSceneDropdowns(); // Isso repopulará e tentará selecionar os valores corretos
            }
            if (i18next.isInitialized) {
                logMessage(`Loaded ${mappings.length} stream mappings.`, "logMessages.loadedStreamMappings", { count: mappings.length });
            } else {
                console.log(`Loaded ${mappings.length} stream mappings (i18next not ready for log).`);
            }
          } catch (e) {
             if (i18next.isInitialized) {
                logMessage(
                `Error loading stream mappings from localStorage: ${e.message}`,
                "logMessages.errorLoadingStreamMappings", { message: e.message }
                );
            } else {
                console.error(`Error loading stream mappings from localStorage: ${e.message}`);
            }
          }
        }
      }
      function getStreamMappings() {
        const mappings = [];
        document.querySelectorAll(".stream-mapping").forEach((div) => {
          const streamIdInput = div.querySelector(".mapping-stream-id");
          const labelInput = div.querySelector(".mapping-label");
          const matchTypeSelect = div.querySelector(".mapping-match-type");
          const sceneNameSelect = div.querySelector(".mapping-scene-name");
          const cloneToMainCheckbox = div.querySelector(
            ".mapping-clone-to-main"
          );
          const switchToSceneCheckbox = div.querySelector(
            ".mapping-switch-to-scene"
          );

          if (
            streamIdInput &&
            labelInput &&
            matchTypeSelect &&
            sceneNameSelect &&
            cloneToMainCheckbox &&
            switchToSceneCheckbox
          ) {
            const streamId = streamIdInput.value.trim();
            const label = labelInput.value.trim();
            const matchType = matchTypeSelect.value;
            const sceneName = sceneNameSelect.value.trim();
            const cloneToMain = cloneToMainCheckbox.checked;
            const switchToScene = switchToSceneCheckbox.checked;

            // Um mapeamento é válido se tiver uma cena e pelo menos um Stream ID ou Label
            if (sceneName && (streamId || label)) {
              mappings.push({
                streamId,
                label,
                matchType,
                sceneName,
                cloneToMain,
                switchToScene,
              });
            }
          } else {
            logMessage(
              "Warning: Could not find all expected elements in a stream mapping UI div.",
              "logMessages.warningStreamMappingElementsNotFound"
            );
          }
        });
        return mappings;
      }

      async function connectToOBS() {
        // Validação dos prefixos
        if (
          cameraPrefixInput.value.trim() === "" ||
          reactionSubPrefixInput.value.trim() === "" ||
          highlightSubPrefixInput.value.trim() === ""
        ) {
          logMessage(
            "Error: Camera, Reaction, and Highlight prefixes are required for OBS connection.",
            "logMessages.obs.errorPrefixesRequired"
          );
          obsStatusIndicator.classList.add("error");
          if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusErrorPrefixesMissing");
          return;
        }

        let url = obsWsUrlInput.value.trim();
        const password = obsWsPasswordInput.value;

        if (!url) {
          logMessage("Error: OBS WebSocket URL is required.", "logMessages.obs.errorUrlRequired");
          obsStatusIndicator.classList.add("error");
          if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusErrorUrlMissing");
          return;
        }
        // Adiciona ws:// ou wss:// se não estiver presente
        if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
          url = "ws://" + url; // Default para ws não seguro
          obsWsUrlInput.value = url; // Atualiza o input
        }
        if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusConnecting");
        obsStatusIndicator.classList.remove("connected", "error"); // Reseta o indicador
        logMessage(`Attempting to connect to OBS WebSocket at ${url}...`, "logMessages.obs.attemptingConnection", { url });

        // Timeout para a tentativa de conexão
        const connectionTimeoutId = setTimeout(() => {
          if (
            obs &&
            obs.readyState !== WebSocket.OPEN &&
            obs.readyState !== WebSocket.CONNECTING
          ) {
            logMessage("OBS WebSocket connection attempt timed out.", "logMessages.obs.connectionTimeout");
            if (obs) {
              try {
                obs.close();
              } catch (e) {} // Ignora erros ao fechar
              obs = null;
            }
            // Atualiza UI para estado de falha por timeout
            if (i18next.isInitialized) {
                obsConnectionStatus.textContent = i18next.t("obsConnection.statusErrorTimeout");
                obsConnectBtn.textContent = i18next.t("obsConnection.connectButton");
            }
            obsStatusIndicator.classList.add("error");
            obsConnectBtn.classList.remove("connected");
            obsConnectBtn.classList.add("disconnected");
          }
        }, 10000); // 10 segundos de timeout

        try {
          obs = new WebSocket(url);

          obs.onopen = () => {
            logMessage(
              "OBS WebSocket connection opened. Waiting for Server Hello...",
              "logMessages.obs.connectionOpenedWaitingHello"
            );
            // Não muda o estado para conectado aqui, espera pelo Hello e Identify
          };

          obs.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);
              // console.debug("OBS RX:", message); // Log para debug

              if (message.op === 0) {
                // Hello
                logMessage("Received Hello from OBS. Sending Identify...", "logMessages.obs.receivedHelloSendingIdentify");
                const identifyPayload = {
                  op: 1, // Identify
                  d: {
                    rpcVersion: 1,
                    eventSubscriptions:
                      (1 << 0) | // General
                      (1 << 1) | // Config
                      (1 << 2) | // Scenes
                      (1 << 3) | // Inputs
                      // (1 << 4) | // Transitions (não usado ativamente)
                      // (1 << 5) | // Filters (não usado ativamente)
                      (1 << 6) | // Outputs
                      (1 << 7) | // SceneItems
                      (1 << 8) | // MediaInputs
                      (1 << 9), // Vendors (pode ser útil)
                    // Adicione mais flags de evento conforme necessário
                  },
                };
                if (message.d && message.d.authentication) {
                  // Se o servidor requer autenticação
                  const { challenge, salt } = message.d.authentication;
                  if (password) {
                    identifyPayload.d.authentication =
                      await generateAuthResponse(password, salt, challenge);
                    logMessage(
                      "Authentication data prepared for Identify message.",
                      "logMessages.obs.authDataPrepared"
                    );
                  } else {
                    logMessage(
                      "Warning: OBS server requires authentication, but no password provided.",
                      "logMessages.obs.warningAuthRequiredNoPassword"
                    );
                    // A conexão provavelmente falhará aqui se a senha for necessária e não fornecida
                  }
                }
                obs.send(JSON.stringify(identifyPayload));
              } else if (message.op === 2) {
                // Identified (Autenticação bem-sucedida)
                clearTimeout(connectionTimeoutId); // Cancela o timeout de conexão
                logMessage(
                  "OBS WebSocket Authentication successful! Connection established.",
                  "logMessages.obs.authSuccessConnected"
                );
                obsConnected = true;
                updateObsConnectButtonText();
                obsConnectBtn.classList.add("connected");
                obsConnectBtn.classList.remove("disconnected");
                if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusConnected");
                obsStatusIndicator.classList.add("connected");
                obsStatusIndicator.classList.remove("error");
                onObsConnected(); // Chama a função pós-conexão
              } else if (message.op === 7) {
                // RequestResponse
                const entry =
                  message.d && message.d.requestId
                    ? requestCallbacks[message.d.requestId]
                    : null;

                if (entry) {
                  const responseData = message.d;
                  const requestStatus = responseData.requestStatus;
                  const requestType =
                    responseData.requestType || entry.requestType; // Usa o tipo da resposta ou do callback

                  if (requestStatus && requestStatus.code === 100) {
                    // Sucesso (Código 100)
                    entry.resolve(responseData.responseData || {}); // Resolve com os dados da resposta
                  } else {
                    // Erro na requisição
                    const errorMessage = requestStatus
                      ? requestStatus.comment
                      : "Unknown error";
                    const errorCode = requestStatus ? requestStatus.code : "N/A";

                    // Suprime o log para erros "não encontrado" se a opção suppressNotFound estiver ativa
                    const suppressLog =
                      entry.suppressNotFound && errorCode === 600; // 600 = ResourceNotFound

                    if (!suppressLog) {
                      logMessage(
                        `OBS Request Error (Type: ${requestType}, ID: ${responseData.requestId}): ${errorMessage} (Code: ${errorCode})`,
                        "logMessages.obs.requestError", { type: requestType, id: responseData.requestId, error: errorMessage, code: errorCode }
                      );
                    }
                    entry.reject(
                      new Error(
                        `Request ${requestType} failed: ${errorMessage} (Code: ${errorCode})`
                      )
                    );
                  }
                  delete requestCallbacks[responseData.requestId]; // Remove o callback
                }
              } else if (message.op === 5) {
                // Event
                // console.debug("OBS Event:", message.d.eventType, message.d.eventData);
                if (message.d && message.d.eventType === "SceneListChanged") {
                  logMessage(
                    "OBS Event: Scene list changed. Re-fetching scenes.",
                    "logMessages.obs.eventSceneListChanged"
                  );
                  fetchObsScenes(); // Atualiza a lista de cenas
                }
                // Adicione mais handlers de evento aqui conforme necessário
              }
            } catch (error) {
              logMessage(
                `Error processing OBS WebSocket message: ${error.message}. Data: ${event.data}`,
                "logMessages.obs.errorProcessingMessage", { message: error.message, data: event.data }
              );
            }
          };

          obs.onerror = (errorEvent) => {
            clearTimeout(connectionTimeoutId);
            let errorMsg = "Unknown WebSocket error";
            if (errorEvent && errorEvent.message) {
              errorMsg = errorEvent.message;
            } else if (typeof errorEvent === "string") {
              // Alguns navegadores podem passar uma string simples
              errorMsg = errorEvent;
            }
            logMessage(`OBS WebSocket Error: ${errorMsg}`, "logMessages.obs.webSocketError", { error: errorMsg });
            obsStatusIndicator.classList.add("error");
            if (i18next.isInitialized) {
                obsConnectionStatus.textContent = i18next.t("obsConnection.statusError");
                obsConnectBtn.textContent = i18next.t("obsConnection.connectButton");
            }
            obsConnectBtn.classList.remove("connected");
            obsConnectBtn.classList.add("disconnected");
            obsConnected = false;
          };

          obs.onclose = (event) => {
            clearTimeout(connectionTimeoutId);
            let reason = "";
            if (i18next.isInitialized) {
                if (event.code === 4009) {
                // Código específico para falha de autenticação
                reason =
                    i18next.t("logMessages.obs.authFailedReason"); // "Authentication failed."
                } else if (event.reason) {
                reason = event.reason;
                } else {
                reason = i18next.t("logMessages.obs.connectionClosedReasonCode", {code: event.code || "Unknown", wasClean: event.wasClean ? "" : i18next.t("logMessages.obs.uncleanDisconnection") });
                }
            } else {
                reason = `Code ${event.code}`; // Fallback se i18next não estiver pronto
            }
            logMessage(`OBS WebSocket Connection Closed. Reason: ${reason}`, "logMessages.obs.connectionClosed", { reason });
            onObsDisconnected(); // Chama a função de limpeza
          };
        } catch (error) {
          clearTimeout(connectionTimeoutId);
          logMessage(
            `Error creating OBS WebSocket connection: ${error.message}`,
            "logMessages.obs.errorCreatingConnection", { message: error.message }
          );
          if (i18next.isInitialized) {
            obsConnectionStatus.textContent = i18next.t("obsConnection.statusError");
            obsConnectBtn.textContent = i18next.t("obsConnection.connectButton");
          }
          obsStatusIndicator.classList.add("error");
          obsConnectBtn.classList.remove("connected");
          obsConnectBtn.classList.add("disconnected");
          obsConnected = false;
        }
      }

      async function generateAuthResponse(password, salt, challenge) {
        const encoder = new TextEncoder();
        try {
          // Passo 1: Concatenar senha e salt
          const secretString = password + salt;
          const secretData = encoder.encode(secretString);
          let secretHash;

          // Passo 2: Hash SHA-256 de (senha + salt)
          if (window.crypto && window.crypto.subtle) {
            // Usa Web Crypto API se disponível (mais seguro)
            const hashBuffer = await window.crypto.subtle.digest(
              "SHA-256",
              secretData
            );
            secretHash = new Uint8Array(hashBuffer);
          } else {
            // Fallback para jsSHA se Web Crypto não estiver disponível
            await loadJsShaLibrary(); // Garante que jsSHA está carregado
            const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
            shaObj.update(secretString);
            const hashHex = shaObj.getHash("HEX");
            // Converte o hash hexadecimal para Uint8Array
            secretHash = new Uint8Array(
              hashHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
            );
          }

          // Passo 3: Codificar o hash em Base64
          const secretBase64 = btoa(String.fromCharCode.apply(null, secretHash));

          // Passo 4: Concatenar o hash Base64 com o challenge
          const authString = secretBase64 + challenge;
          const authData = encoder.encode(authString);
          let authHash;

          // Passo 5: Hash SHA-256 de (hash_base64 + challenge)
          if (window.crypto && window.crypto.subtle) {
            const hashBuffer = await window.crypto.subtle.digest(
              "SHA-256",
              authData
            );
            authHash = new Uint8Array(hashBuffer);
          } else {
            const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
            shaObj.update(authString);
            const hashHex = shaObj.getHash("HEX");
            authHash = new Uint8Array(
              hashHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
            );
          }

          // Passo 6: Codificar o hash final em Base64 - esta é a resposta de autenticação
          return btoa(String.fromCharCode.apply(null, authHash));
        } catch (error) {
          logMessage(`OBS Authentication generation error: ${error.message}`, "logMessages.obs.authGenerationError", { message: error.message });
          throw error; // Relança o erro para ser tratado pelo chamador
        }
      }

      function sendRequest(requestType, requestData = {}, options = {}) {
        return new Promise((resolve, reject) => {
          if (!obsConnected || !obs) {
            logMessage(
              `Cannot send request '${requestType}': Not connected to OBS.`,
              "logMessages.obs.cannotSendRequestNotConnected", { requestType }
            );
            reject(new Error("Not connected to OBS"));
            return;
          }
          const requestId = generateRequestId(requestType); // Gera um ID único para a requisição

          // Armazena os callbacks para esta requisição
          requestCallbacks[requestId] = {
            resolve,
            reject,
            requestType,
            suppressNotFound: !!options.suppressNotFound, // Opção para não logar erros "não encontrado"
          };

          const requestPayload = {
            op: 6, // Request
            d: {
              requestType,
              requestId,
              requestData,
            },
          };

          try {
            // console.debug("OBS TX:", requestPayload); // Log para debug
            obs.send(JSON.stringify(requestPayload));
          } catch (error) {
            logMessage(
              `Error sending OBS request '${requestType}': ${error.message}`,
              "logMessages.obs.errorSendingRequest", { requestType, message: error.message }
            );
            // Se o envio falhar, rejeita a promessa e remove o callback
            if (requestCallbacks[requestId]) {
              const failedEntry = requestCallbacks[requestId];
              delete requestCallbacks[requestId];
              failedEntry.reject(error);
            } else {
              reject(error); // Caso raro onde o callback já foi removido
            }
          }

          // Timeout para a requisição
          setTimeout(() => {
            if (requestCallbacks[requestId]) {
              const entry = requestCallbacks[requestId];
              delete requestCallbacks[requestId]; // Remove o callback
              logMessage(
                `OBS Request '${entry.requestType}' (ID: ${requestId}) timed out.`,
                "logMessages.obs.requestTimeout", { requestType: entry.requestType, id: requestId }
              );
              entry.reject(new Error(`Request timeout for ${entry.requestType}`));
            }
          }, 5000); // Timeout de 5 segundos
        });
      }

      function onObsConnected() {
        logMessage(
          "OBS Connection fully established. Fetching initial data...",
          "logMessages.obs.connectionEstablishedFetchingData"
        );
        fetchObsScenes()
          .then(() => {
            // Após buscar as cenas, se autoGrid estiver ativo, rearranje a cena principal
            if (sourceSizingSelect.value === "autoGrid" && getTargetScene()) {
              logMessage(
                "Initial rearrange for auto-grid on main target scene after OBS connection.",
                "logMessages.obs.initialRearrangeAutoGrid"
              );
              setTimeout(
                () => rearrangeAllStreamsInScene(getTargetScene()),
                1000
              ); // Pequeno delay para garantir que tudo está pronto
            }
          })
          .catch((error) => {
            logMessage(
              `Error during post-OBS connection setup (fetching scenes): ${error.message}`,
              "logMessages.obs.errorPostConnectionSetup", { message: error.message }
            );
          });
        // Outras ações pós-conexão podem ser adicionadas aqui
      }

      function onObsDisconnected() {
        logMessage("OBS Connection has been closed or lost.", "logMessages.obs.connectionClosedOrLost");
        obsConnected = false;
        updateObsConnectButtonText();
        obsConnectBtn.classList.remove("connected");
        obsConnectBtn.classList.add("disconnected");
        if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusDisconnected");
        obsStatusIndicator.classList.remove("connected", "error");

        // Marca todas as fontes como não criadas na UI, mas não remove dos activeStreams
        Object.values(activeStreams).forEach(
          (stream) => (stream.sourceCreated = false)
        );
        updateStreamList(); // Atualiza a lista de streams para refletir o estado

        // Limpa a lista de cenas do OBS e atualiza os dropdowns
        obsScenes = [];
        updateSceneDropdowns();
        updateOtherScenesList(); // Também depende de obsScenes
      }

      async function fetchObsScenes() {
        if (!obsConnected || !obs) {
          logMessage("Cannot fetch OBS scenes: Not connected to OBS.", "logMessages.obs.cannotFetchScenesNotConnected");
          return;
        }
        logMessage("Fetching OBS scenes...", "logMessages.obs.fetchingScenes");
        try {
          const response = await sendRequest("GetSceneList");
          const settingsJson = localStorage.getItem("obsNinjaSettings"); // Para restaurar seleções
          const settings = settingsJson ? JSON.parse(settingsJson) : {};

          if (response && response.scenes) {
            obsScenes = response.scenes; // Armazena a lista de cenas globalmente
            logMessage(`Fetched ${obsScenes.length} scenes from OBS.`, "logMessages.obs.fetchedScenesCount", { count: obsScenes.length });

            updateSceneDropdowns(); // Atualiza todos os dropdowns de cena

            // Tenta restaurar a cena principal selecionada anteriormente
            if (
              settings.obsSceneName &&
              obsScenes.some((s) => s.sceneName === settings.obsSceneName)
            ) {
              obsSceneSelect.value = settings.obsSceneName;
            } else if (settings.obsSceneName) {
              logMessage(
                `Previously selected main scene "${settings.obsSceneName}" no longer found. Please reselect.`,
                "logMessages.obs.mainSceneNotFound", { sceneName: settings.obsSceneName }
              );
            }

            // Tenta restaurar a cena de screen share
            if (
              settings.screenShareScene === "" || // "Same as main"
              (settings.screenShareScene &&
                obsScenes.some((s) => s.sceneName === settings.screenShareScene))
            ) {
              document.getElementById("screenShareSceneSelect").value =
                settings.screenShareScene;
            } else if (settings.screenShareScene) {
              logMessage(
                `Previously selected screen share scene "${settings.screenShareScene}" no longer found. Defaulting to "Same as main".`,
                "logMessages.obs.screenShareSceneNotFound", { sceneName: settings.screenShareScene }
              );
               document.getElementById("screenShareSceneSelect").value = ""; // Default para "Same as main"
            }


            // Tenta restaurar a cena de highlight
            if (
              settings.highlightScene &&
              obsScenes.some((s) => s.sceneName === settings.highlightScene)
            ) {
              highlightSceneSelect.value = settings.highlightScene;
            } else if (settings.highlightScene) {
              logMessage(
                `Previously selected highlight scene "${settings.highlightScene}" no longer found. Please reselect.`,
                "logMessages.obs.highlightSceneNotFound", { sceneName: settings.highlightScene }
              );
            }

            updateOtherScenesList(); // Atualiza a lista de "outras cenas"

            // Restaura seleções de cena nos mapeamentos de stream
            const savedMappingsJson =
              localStorage.getItem("obsNinjaStreamMappings");
            if (savedMappingsJson) {
              try {
                const mappings = JSON.parse(savedMappingsJson);
                document
                  .querySelectorAll(".mapping-scene-name")
                  .forEach((select, index) => {
                    if (mappings[index] && mappings[index].sceneName) {
                      if (
                        obsScenes.some(
                          (scene) =>
                            scene.sceneName === mappings[index].sceneName
                        )
                      ) {
                        select.value = mappings[index].sceneName;
                      }
                    }
                  });
              } catch (e) {
                logMessage(
                  `Error applying saved scene selections to stream mappings: ${e.message}`,
                  "logMessages.obs.errorApplyingSavedMappings", { message: e.message }
                );
              }
            }
            obsSceneNameInput.value = obsSceneSelect.value; // Atualiza o input escondido (se ainda usado)
          } else {
            logMessage("Failed to fetch OBS scenes or no scenes returned.", "logMessages.obs.failedToFetchScenes");
            obsScenes = [];
            updateSceneDropdowns();
            updateOtherScenesList();
          }
        } catch (error) {
          logMessage(`Error fetching OBS scenes: ${error.message}`, "logMessages.obs.errorFetchingScenes", { message: error.message });
          obsScenes = []; // Limpa em caso de erro
          updateSceneDropdowns();
          updateOtherScenesList();
        }
      }

      function populateSceneDropdown(
        scenesData, // Array de cenas do OBS [{ sceneName: "Nome" }, ...]
        selectElement // O elemento <select> a ser populado
      ) {
        if (!i18next.isInitialized) return; // Garante que i18next está pronto
        const currentValue = selectElement.value; // Salva o valor atual para tentar restaurar
        selectElement.innerHTML = ''; // Limpa opções existentes

        let placeholderKeyToUse;

        // Determina a chave de tradução para o placeholder com base no ID/classe do select
        if (selectElement.id === "obsSceneSelect") {
          placeholderKeyToUse = "obsTargetSettings.selectSceneOption";
        } else if (selectElement.id === "screenShareSceneSelect") {
          placeholderKeyToUse = "obsTargetSettings.screenShareSettings.sameAsMainOption";
        } else if (selectElement.id === "highlightSceneSelect") {
          placeholderKeyToUse = "obsTargetSettings.highlightScene.selectSceneOption";
        } else if (selectElement.classList.contains("mapping-scene-name")) {
          placeholderKeyToUse = "streamIdMappings.selectSceneOption";
        } else {
          // Fallback genérico se o select não for reconhecido
          placeholderKeyToUse = "obsTargetSettings.selectSceneOption"; // Ou um placeholder mais genérico
          console.warn("populateSceneDropdown called with an unhandled select element:", selectElement.id || selectElement.className);
        }

        const placeholderOption = document.createElement('option');
        placeholderOption.value = ""; // Valor vazio para o placeholder
        placeholderOption.textContent = i18next.t(placeholderKeyToUse);
        selectElement.appendChild(placeholderOption);

        if (scenesData && scenesData.length > 0) {
          scenesData.forEach((scene) => {
            const option = document.createElement("option");
            option.value = scene.sceneName;
            option.textContent = scene.sceneName;
            selectElement.appendChild(option);
          });
        }

        // Tenta restaurar o valor selecionado anteriormente, se ainda for uma opção válida
        if (currentValue && Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
          selectElement.value = currentValue;
        } else {
           selectElement.value = ""; // Se o valor anterior não for mais válido, seleciona o placeholder
        }
      }


      function getTargetScene() {
        return obsSceneSelect.value || ""; // Retorna o valor da cena principal selecionada
      }

      function getVdoNinjaViewUrl(streamId, includeCommonParams = true) {
        const room = vdoNinjaRoomInput.value.trim();
        const ninjaPassword = vdoNinjaPasswordInput.value;
        const baseUrl = getVdoNinjaBaseUrl();
        const selectedCodec = sourceCodecSelect.value;

        let url = `${baseUrl}/?`;

        if (room) {
          // Se um nome de sala for fornecido, use-o para isolar o view
          url += `view=${encodeURIComponent(
            streamId
          )}&solo&room=${encodeURIComponent(room)}`;
        } else {
          // Se não houver sala, apenas o streamId (pode não funcionar bem para múltiplas conexões sem sala)
          url += `view=${encodeURIComponent(streamId)}`;
        }

        if (ninjaPassword) {
          url += `&password=${encodeURIComponent(ninjaPassword)}`;
        }
        if (selectedCodec && selectedCodec !== "") {
          url += `&codec=${encodeURIComponent(selectedCodec)}`;
        }
        if (includeCommonParams) {
          url +=
            "&cleanoutput&proaudio&ab=160&transparent&autoplay&noheader&webcursor&sl"; // Parâmetros comuns para uma boa visualização no OBS
        }
        return url;
      }

      function initializeVdoNinjaIframe() {
        const room = vdoNinjaRoomInput.value.trim();
        const streamIdsInput = vdoNinjaStreamIdsInput.value.trim();

        if (!room && !streamIdsInput) {
          logMessage(
            "VDO.Ninja: Room Name or specific Stream ID(s) must be provided to connect.",
            "logMessages.vdoNinja.roomOrStreamIdNeededForConnect"
          );
          updateVdoNinjaButtonState(false); // Garante que o botão de conexão reflita o estado
          return;
        }

        const baseUrl = getVdoNinjaBaseUrl();
        let vdoNinjaUrl = `${baseUrl}/?`;

        if (room) {
          vdoNinjaUrl += `room=${encodeURIComponent(room)}`;
          // Se streamIds também forem fornecidos, adicione-os como `view` para filtrar
          if (streamIdsInput) {
            const viewStreamIds = streamIdsInput
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s) // Remove IDs vazios
              .join(",");
            if (viewStreamIds)
              vdoNinjaUrl += `&view=${encodeURIComponent(viewStreamIds)}&solo`; // &solo para isolar os views
          }
        } else if (streamIdsInput) {
          // Se apenas streamIds forem fornecidos (sem sala)
          const viewStreamIds = streamIdsInput
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s)
            .join(",");
          if (viewStreamIds) {
            vdoNinjaUrl += `view=${encodeURIComponent(viewStreamIds)}`;
            // Adicionar &solo aqui também pode ser útil se múltiplos IDs forem listados
            if (viewStreamIds.includes(",")) vdoNinjaUrl += "&solo";
          } else {
            logMessage(
              "VDO.Ninja: Stream IDs provided but were empty after trimming.",
              "logMessages.vdoNinja.streamIdsEmptyAfterTrim"
            );
            updateVdoNinjaButtonState(false);
            return;
          }
        }

        if (vdoNinjaPasswordInput.value) {
          vdoNinjaUrl += `&password=${encodeURIComponent(
            vdoNinjaPasswordInput.value
          )}`;
        }

        // Parâmetros para o iframe de controle/escuta
        vdoNinjaUrl +=
          "&cleanoutput&dataonly&nocursor&nopush&debug&noaudio&novideo&cors=" +
          encodeURIComponent(window.location.origin); // Habilita CORS para mensagens

        logMessage(`Initializing VDO.Ninja iframe with URL: ${vdoNinjaUrl}`, "logMessages.vdoNinja.initializingIframe", { url: vdoNinjaUrl });
        vdoNinjaIframe.src = "about:blank"; // Limpa o iframe antes de carregar
        vdoNinjaIframe.setAttribute("crossorigin", "anonymous"); // Necessário para algumas interações

        // Pequeno delay para garantir que o src="about:blank" foi processado
        setTimeout(() => {
          vdoNinjaIframe.src = vdoNinjaUrl;
          vdoNinjaLastActivityTime = Date.now(); // Reseta o timer de atividade
        }, 100);
      }

      window.addEventListener(
        "message",
        (event) => {
          // Validação da origem do evento
          const expectedOriginBase = getVdoNinjaBaseUrl();
          let parsedExpectedOrigin;
          try {
            parsedExpectedOrigin = new URL(expectedOriginBase);
          } catch (e) {
            logMessage(
              `Invalid VDO.Ninja base URL in settings: ${expectedOriginBase}`,
              "logMessages.vdoNinja.invalidBaseUrl", { url: expectedOriginBase }
            );
            return; // Ignora a mensagem se a URL base for inválida
          }

          if (
            event.origin !== parsedExpectedOrigin.origin || // Verifica a origem
            event.source !== vdoNinjaIframe.contentWindow // Verifica se a mensagem veio do iframe correto
          ) {
            // console.warn("Ignored message from unexpected origin or source:", event.origin, event.source);
            return;
          }

          const data = event.data;
          vdoNinjaLastActivityTime = Date.now(); // Atualiza o tempo da última atividade

          // Se não estava conectado, marca como conectado ao receber a primeira mensagem válida
          if (!vdoNinjaConnected) {
            vdoNinjaConnected = true;
            updateVdoNinjaButtonState(true); // Atualiza UI
            if (vdoNinjaConnectionCheckTimer) {
              clearTimeout(vdoNinjaConnectionCheckTimer); // Cancela o timer de timeout de conexão
              vdoNinjaConnectionCheckTimer = null;
            }
            logMessage("VDO.Ninja iframe connection established and active.", "logMessages.vdoNinja.iframeConnectedActive");
          }

          // Processa os dados da mensagem
          if (data && data.streamID) {
            const streamId = data.streamID;
            const label = data.label || i18next.t("vdoNinja.defaultStreamLabel", {id: streamId}); // Usa o label fornecido ou um padrão


            if (
              (data.action === "view-connection" && data.value === true) || // Stream de view conectado
              data.action === "guest-connected" || // Convidado conectado (geralmente implica um stream)
              (data.action === "push-connection" && data.value === true) // Stream de push conectado
            ) {
              logMessage(
                `VDO.Ninja stream connected/active: "${label}" (ID: ${streamId})`,
                "logMessages.vdoNinja.streamConnectedActive", { label, id: streamId }
              );
              activeStreams[streamId] = {
                label,
                sourceCreated: false, // Inicialmente, a fonte OBS não foi criada/verificada
                streamId, // Adiciona o streamId ao objeto para fácil acesso
                uuid: data.UUID || null, // Pode ser útil para identificação mais granular
                connected: true, // Marca como conectado no VDO.Ninja
              };
              updateStreamList(); // Atualiza a UI

              // Adiciona automaticamente ao OBS se a opção estiver marcada
              if (autoAddSourcesCheckbox.checked) {
                logMessage(`Auto-adding stream ${streamId} to OBS.`, "logMessages.vdoNinja.autoAddingStream", { id: streamId });
                const targetInfo = getTargetSceneForStream(streamId, label);
                addStreamToObs(streamId, label, targetInfo);
              }
            } else if (
              (data.action === "view-connection" && data.value === false) || // Stream de view desconectado
              (data.action === "push-connection" && data.value === false) // Stream de push desconectado
            ) {
              if (activeStreams[streamId]) {
                logMessage(
                  `VDO.Ninja stream disconnected/inactive: "${label}" (ID: ${streamId})`,
                  "logMessages.vdoNinja.streamDisconnectedInactive", { label, id: streamId }
                );
                if (
                  autoRemoveSourcesCheckbox &&
                  autoRemoveSourcesCheckbox.checked
                ) {
                  logMessage(`Auto-removing stream ${streamId} from OBS.`, "logMessages.vdoNinja.autoRemovingStream", { id: streamId });
                  removeStreamFromObs(streamId); // Remove do OBS se a opção estiver marcada
                }
                delete activeStreams[streamId]; // Remove dos streams ativos
                updateStreamList(); // Atualiza a UI
              }
            } else if (
              data.action === "view-connection-info" &&
              data.value &&
              data.value.label // Se receber uma atualização de label
            ) {
              if (activeStreams[streamId]) {
                if (activeStreams[streamId].label !== data.value.label) {
                  logMessage(
                    `VDO.Ninja stream label updated for ID ${streamId}: "${data.value.label}" (was "${activeStreams[streamId].label}")`,
                    "logMessages.vdoNinja.streamLabelUpdated", { id: streamId, newLabel: data.value.label, oldLabel: activeStreams[streamId].label }
                  );
                  activeStreams[streamId].label = data.value.label;
                  updateStreamList(); // Atualiza a UI com o novo label
                }
              }
            }
            // console.debug("VDO.Ninja message processed:", data);
          }
        },
        false
      );

      function startVdoNinjaConnectionMonitor() {
        setInterval(() => {
          if (
            vdoNinjaConnected &&
            Date.now() - vdoNinjaLastActivityTime > 45000
          ) {
            // 45 segundos sem atividade
            logMessage(
              "VDO.Ninja connection lost (no activity from iframe). Attempting to reset.",
              "logMessages.vdoNinja.connectionLostResetting"
            );
            if (i18next.isInitialized) vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusConnectionLost");
            vdoNinjaStatusIndicator.classList.add("error");
            vdoNinjaStatusIndicator.classList.remove("connected");
            disconnectFromVdoNinja(); // Tenta desconectar e limpar
            // Poderia tentar reconectar automaticamente aqui, se desejado
          }
        }, 30000); // Verifica a cada 30 segundos
      }

      async function addStreamToObs(
        streamId,
        streamLabel,
        targetInfo = null // targetInfo pode ser { scene: "NomeCena", mapping: {...} }
      ) {
        if (!obsConnected || !obs) {
          logMessage(
            `Cannot add stream "${streamLabel}" (${streamId}) to OBS: Not connected to OBS.`,
            "logMessages.obs.cannotAddStreamNotConnected", { label: streamLabel, id: streamId }
          );
          return;
        }

        const resolvedTargetInfo =
          targetInfo || getTargetSceneForStream(streamId, streamLabel);
        const targetSceneName = resolvedTargetInfo.scene;
        const mappingRule = resolvedTargetInfo.mapping; // A regra de mapeamento, se houver

        if (!targetSceneName) {
          logMessage(
            `Cannot add stream "${streamLabel}" (${streamId}): Target OBS scene name is required but not set (no default and no mapping).`,
            "logMessages.obs.cannotAddStreamNoTargetSceneName", { label: streamLabel, id: streamId }
          );
          return;
        }

        // Determina o nome da fonte no OBS
        const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
        const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
        let effectiveSourceName = baseSourceName; // Nome a ser usado para criar/atualizar
        let sourceReallyExistsGlobally = false; // Flag para saber se a fonte já existe no OBS

        // Verifica se a versão destacada da fonte já existe
        try {
          await sendRequest(
            "GetInputSettings",
            { inputName: highlightedSourceName },
            { suppressNotFound: true } // Não logar erro se não encontrar
          );
          logMessage(
            `Highlighted version '${highlightedSourceName}' found for stream ${streamId}. This will be managed.`,
            "logMessages.obs.highlightedVersionFound", { sourceName: highlightedSourceName, id: streamId }
          );
          effectiveSourceName = highlightedSourceName; // Usa o nome destacado
          sourceReallyExistsGlobally = true;
          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = true; // Marca como criada
          highlightedStreamId = streamId; // Define como destacado globalmente
        } catch (e) {
          // Se a destacada não existe, verifica a versão base
          if (
            !(
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"))
            )
          ) {
            logMessage(
              `Error checking for highlighted source '${highlightedSourceName}': ${e.message}. Will check for base source.`,
              "logMessages.obs.errorCheckingHighlightedSource", { sourceName: highlightedSourceName, message: e.message }
            );
          }
          // Agora verifica a fonte base
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: baseSourceName },
              { suppressNotFound: true }
            );
            logMessage(
              `Base version '${baseSourceName}' found for stream ${streamId}. This will be managed.`,
              "logMessages.obs.baseVersionFound", { sourceName: baseSourceName, id: streamId }
            );
            effectiveSourceName = baseSourceName; // Usa o nome base
            sourceReallyExistsGlobally = true;
            if (activeStreams[streamId])
              activeStreams[streamId].sourceCreated = true;
          } catch (e2) {
            // Se nem a base existe, será criada
            const isNotFoundE2 =
              e2.message.toLowerCase().includes("not found") ||
              e2.message.toLowerCase().includes("does not exist") ||
              e2.message.toLowerCase().includes("no source") ||
              (e2.message.toLowerCase().includes("code") &&
                e2.message.toLowerCase().includes("600"));
            if (!isNotFoundE2) {
              logMessage(
                `Error checking for base source '${baseSourceName}': ${e2.message}. Will attempt to create.`,
                "logMessages.obs.errorCheckingBaseSource", { sourceName: baseSourceName, message: e2.message }
              );
            }
            effectiveSourceName = baseSourceName; // Usará o nome base para criar
            sourceReallyExistsGlobally = false;
          }
        }

        // Determina se deve clonar para a cena principal e se deve mudar para a cena do stream
        const mainDefaultScene = getTargetScene(); // Cena principal global
        let shouldCloneThisStreamToMain = false;
        if (
          mappingRule &&
          mappingRule.sceneName !== mainDefaultScene && // Se a cena mapeada não é a principal
          mappingRule.cloneToMain // E a regra diz para clonar
        ) {
          shouldCloneThisStreamToMain = true;
        }
        let shouldSwitchToThisScene = false;
        if (mappingRule && mappingRule.switchToScene) {
          shouldSwitchToThisScene = true;
        }

        const vdoNinjaStreamUrl = getVdoNinjaViewUrl(streamId); // URL do VDO.Ninja para a fonte
        let canvasWidth = 1920,
          canvasHeight = 1080; // Tamanho padrão do canvas
        try {
          const videoSettings = await sendRequest("GetVideoSettings");
          if (
            videoSettings &&
            videoSettings.baseWidth &&
            videoSettings.baseHeight
          ) {
            canvasWidth = videoSettings.baseWidth;
            canvasHeight = videoSettings.baseHeight;
          }
        } catch (error) {
          logMessage(
            `Error getting OBS canvas size: ${error.message}. Using default ${canvasWidth}x${canvasHeight}.`,
            "logMessages.obs.errorGettingCanvasSize", { message: error.message, width: canvasWidth, height: canvasHeight }
          );
        }

        const inputSettings = {
          url: vdoNinjaStreamUrl,
          width: canvasWidth, // Usar a largura do canvas para a fonte do navegador
          height: canvasHeight, // Usar a altura do canvas
          fps: 30,
          reroute_audio: true,
          restart_when_active: false,
          shutdown: false,
        };

        logMessage(
          `Managing source '${effectiveSourceName}' (exists: ${sourceReallyExistsGlobally}) for stream "${streamLabel}" in OBS scene '${targetSceneName}'. URL: ${vdoNinjaStreamUrl}`,
          "logMessages.obs.managingSource", { sourceName: effectiveSourceName, exists: sourceReallyExistsGlobally, label: streamLabel, sceneName: targetSceneName, url: vdoNinjaStreamUrl }
        );
        if (shouldCloneThisStreamToMain)
          logMessage(
            ` - Will also clone to main scene '${mainDefaultScene}'.`,
            "logMessages.obs.willCloneToMainScene", { sceneName: mainDefaultScene }
          );
        if (shouldSwitchToThisScene)
          logMessage(
            ` - Will also switch OBS to scene '${targetSceneName}'.`,
            "logMessages.obs.willSwitchToScene", { sceneName: targetSceneName }
          );

        try {
          let initialSceneItemId = null; // ID do item na cena de destino principal (mapeada ou padrão)
          let clonedSceneItemId = null; // ID do item na cena principal global, se clonado

          if (!sourceReallyExistsGlobally) {
            // Se a fonte não existe globalmente, crie-a
            logMessage(
              `Source '${baseSourceName}' does not exist globally. Creating it in scene '${targetSceneName}'.`,
              "logMessages.obs.sourceNotGlobalCreating", { sourceName: baseSourceName, sceneName: targetSceneName }
            );
            await sendRequest("CreateInput", {
              sceneName: targetSceneName, // Cria na cena de destino
              inputName: baseSourceName, // Usa o nome base para criar
              inputKind: "browser_source",
              inputSettings,
              sceneItemEnabled: true, // Habilita por padrão
            });
            effectiveSourceName = baseSourceName; // Garante que estamos usando o nome base
            logMessage(
              `Source '${effectiveSourceName}' created and added to scene '${targetSceneName}'.`,
              "logMessages.obs.sourceCreatedAddedToScene", { sourceName: effectiveSourceName, sceneName: targetSceneName }
            );
            // Pega o ID do item recém-criado
            try {
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: targetSceneName,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              initialSceneItemId = itemInfo.sceneItemId;
            } catch (e) {
              // Erro ao pegar ID, mas a fonte foi criada; log e continue
            }
          } else {
            // Se a fonte já existe globalmente, apenas atualize suas configurações
            logMessage(
              `Source '${effectiveSourceName}' already exists globally. Updating its settings.`,
              "logMessages.obs.sourceGlobalUpdating", { sourceName: effectiveSourceName }
            );
            await sendRequest("SetInputSettings", {
              inputName: effectiveSourceName, // Pode ser o nome base ou destacado
              inputSettings,
            });
            // Verifica se o item existe na cena de destino; se não, cria
            try {
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: targetSceneName,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              initialSceneItemId = itemInfo.sceneItemId;
              logMessage(
                `Source '${effectiveSourceName}' found as item in scene '${targetSceneName}'.`,
                "logMessages.obs.sourceFoundAsItemInScene", { sourceName: effectiveSourceName, sceneName: targetSceneName }
              );
            } catch (e) {
              // Se não encontrado na cena, cria o item da cena
              if (
                e.message.toLowerCase().includes("not found") ||
                (e.message.toLowerCase().includes("code") &&
                  e.message.toLowerCase().includes("600"))
              ) {
                logMessage(
                  `Source '${effectiveSourceName}' exists globally but not in scene '${targetSceneName}'. Adding it.`,
                  "logMessages.obs.sourceGlobalNotInSceneAdding", { sourceName: effectiveSourceName, sceneName: targetSceneName }
                );
                const createItemResponse = await sendRequest(
                  "CreateSceneItem",
                  {
                    sceneName: targetSceneName,
                    sourceName: effectiveSourceName,
                  }
                );
                initialSceneItemId = createItemResponse.sceneItemId;
              } else {
                throw e; // Relança outros erros
              }
            }
          }

          // Clona para a cena principal se necessário
          if (
            shouldCloneThisStreamToMain &&
            mainDefaultScene &&
            mainDefaultScene !== targetSceneName // Evita clonar para a mesma cena
          ) {
            logMessage(
              `Attempting to clone source '${effectiveSourceName}' to main scene '${mainDefaultScene}'.`,
              "logMessages.obs.attemptingCloneToMain", { sourceName: effectiveSourceName, sceneName: mainDefaultScene }
            );
            try {
              // Verifica se já existe na cena principal
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: mainDefaultScene,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              clonedSceneItemId = itemInfo.sceneItemId;
              logMessage(
                `Source '${effectiveSourceName}' already exists as an item in main scene '${mainDefaultScene}'.`,
                "logMessages.obs.sourceExistsInMainScene", { sourceName: effectiveSourceName, sceneName: mainDefaultScene }
              );
            } catch (e) {
              // Se não existe, cria o item na cena principal
              if (
                e.message.toLowerCase().includes("not found") ||
                (e.message.toLowerCase().includes("code") &&
                  e.message.toLowerCase().includes("600"))
              ) {
                logMessage(
                  `Cloning source '${effectiveSourceName}' to main scene '${mainDefaultScene}'.`,
                  "logMessages.obs.cloningToMainScene", { sourceName: effectiveSourceName, sceneName: mainDefaultScene }
                );
                const createCloneResponse = await sendRequest(
                  "CreateSceneItem",
                  {
                    sceneName: mainDefaultScene,
                    sourceName: effectiveSourceName,
                  }
                );
                clonedSceneItemId = createCloneResponse.sceneItemId;
              } else {
                logMessage(
                  `Error checking for '${effectiveSourceName}' in main scene '${mainDefaultScene}' before cloning: ${e.message}`,
                  "logMessages.obs.errorCheckingMainSceneBeforeClone", { sourceName: effectiveSourceName, sceneName: mainDefaultScene, message: e.message }
                );
              }
            }
          }

          // Marca a fonte como criada no estado interno
          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = true;

          // Aplica transformações e grid
          if (initialSceneItemId) {
            await applyTransformAndGrid(
              targetSceneName,
              effectiveSourceName,
              canvasWidth,
              canvasHeight,
              initialSceneItemId
            );
          }
          if (clonedSceneItemId) {
            await applyTransformAndGrid(
              mainDefaultScene,
              effectiveSourceName,
              canvasWidth,
              canvasHeight,
              clonedSceneItemId
            );
          }

          // Adiciona/Clona para "outras cenas" selecionadas
          const otherSceneCheckboxes = document.querySelectorAll(
            ".other-scene-checkbox:checked"
          );
          for (const checkbox of otherSceneCheckboxes) {
            const otherSceneName = checkbox.value;
            // Garante que não está processando a cena de destino principal ou a cena principal global (se já clonada)
            if (
              otherSceneName &&
              otherSceneName !== targetSceneName &&
              (!shouldCloneThisStreamToMain ||
                otherSceneName !== mainDefaultScene)
            ) {
              try {
                let otherSceneItemId = null;
                // Verifica se já existe na "outra cena"
                try {
                  const itemInfo = await sendRequest(
                    "GetSceneItemId",
                    {
                      sceneName: otherSceneName,
                      sourceName: effectiveSourceName,
                    },
                    { suppressNotFound: true }
                  );
                  otherSceneItemId = itemInfo.sceneItemId;
                } catch (e) {
                  // Ignora se não encontrado
                }

                if (!otherSceneItemId) {
                  // Se não existe, cria
                  logMessage(
                    `Adding source '${effectiveSourceName}' as item to other scene '${otherSceneName}'.`,
                    "logMessages.obs.addingSourceToOtherScene", { sourceName: effectiveSourceName, sceneName: otherSceneName }
                  );
                  const createItemResponse = await sendRequest(
                    "CreateSceneItem",
                    {
                      sceneName: otherSceneName,
                      sourceName: effectiveSourceName,
                    }
                  );
                  otherSceneItemId = createItemResponse.sceneItemId;
                  // Aplica transformações se o item foi criado
                  if (otherSceneItemId) {
                    await applyTransformAndGrid(
                      otherSceneName,
                      effectiveSourceName,
                      canvasWidth,
                      canvasHeight,
                      otherSceneItemId
                    );
                  }
                }
              } catch (e) {
                logMessage(
                  `Error adding/cloning source '${effectiveSourceName}' to other scene '${otherSceneName}': ${e.message}`,
                  "logMessages.obs.errorAddingCloningToOtherScene", { sourceName: effectiveSourceName, sceneName: otherSceneName, message: e.message }
                );
              }
            }
          }

          // Muda para a cena se a regra de mapeamento especificar
          if (shouldSwitchToThisScene) {
            logMessage(
              `Switching OBS current program scene to '${targetSceneName}'.`,
              "logMessages.obs.switchingProgramScene", { sceneName: targetSceneName }
            );
            const studio = await sendRequest("GetStudioModeEnabled");
            if (studio.studioModeEnabled) {
              await sendRequest("SetCurrentPreviewScene", {
                sceneName: targetSceneName,
              });
              await sleep(100); // Pequena pausa
              await sendRequest("TriggerStudioModeTransition");
            } else {
              await sendRequest("SetCurrentProgramScene", {
                sceneName: targetSceneName,
              });
            }
          }
          logMessage(
            `Successfully processed stream "${streamLabel}" (${streamId}), effective OBS source: '${effectiveSourceName}'.`,
            "logMessages.obs.successfullyProcessedStream", { label: streamLabel, id: streamId, sourceName: effectiveSourceName }
          );

          // Verifica se há uma fonte de screen share associada e atualiza o estado global `screenShareId`
          const screenShareSourceNameToCheck = `${getFullReactionPrefix()}_${streamId}:s`;
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: screenShareSourceNameToCheck },
              { suppressNotFound: true }
            );
            logMessage(
              `Existing screen share source '${screenShareSourceNameToCheck}' found for stream ${streamId}. Associating it.`,
              "logMessages.obs.existingScreenShareFound", { sourceName: screenShareSourceNameToCheck, id: streamId }
            );
            screenShareId = streamId; // Associa o screen share a este stream
          } catch (e) {
            // Se não encontrado, não faz nada, apenas não associa
            const isNotFound =
              e.message.toLowerCase().includes("not found") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error checking for existing screen share source '${screenShareSourceNameToCheck}': ${e.message}`,
                "logMessages.obs.errorCheckingExistingScreenShare", { sourceName: screenShareSourceNameToCheck, message: e.message }
              );
            }
          }

          // MODIFICADO: Aplicar CSS personalizado após o processamento do stream
          if (customCssInput.value.trim() !== "") {
            applyCustomCss(customCssInput.value);
            logMessage("Custom CSS applied after stream processing.", "logMessages.customCssAppliedAfterStream");
          }

        } catch (error) {
          logMessage(
            `Error managing stream '${effectiveSourceName}' ("${streamLabel}") in OBS: ${error.message}`,
            "logMessages.obs.errorManagingStream", { sourceName: effectiveSourceName, label: streamLabel, message: error.message }
          );
          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = false; // Marca como não criada em caso de erro
        } finally {
          updateStreamList(); // Atualiza a UI
        }
      }

      async function applyTransformAndGrid(
        sceneName,
        sourceName,
        canvasWidth,
        canvasHeight,
        sceneItemId = null // ID do item da cena, se já conhecido
      ) {
        if (!sceneName) {
          logMessage(
            `Cannot apply transform for source '${sourceName}': Scene name not provided.`,
            "logMessages.obs.cannotApplyTransformNoScene", { sourceName }
          );
          return;
        }
        let itemIdToTransform = sceneItemId;

        // Se o ID do item não foi fornecido, tenta obtê-lo
        if (!itemIdToTransform) {
          try {
            const itemInfo = await sendRequest(
              "GetSceneItemId",
              { sceneName, sourceName },
              { suppressNotFound: true } // Não logar erro se não encontrar
            );
            if (itemInfo && itemInfo.sceneItemId) {
              itemIdToTransform = itemInfo.sceneItemId;
            } else {
              // logMessage(`Source '${sourceName}' not found in scene '${sceneName}' for transform. Skipping.`, "logMessages.obs.sourceNotFoundForTransformSkip", { sourceName, sceneName });
              return; // Não pode aplicar transform se o item não existe
            }
          } catch (error) {
            // Se houver erro ao buscar o ID (que não seja "não encontrado"), logue e retorne
            const isNotFound =
              error.message.toLowerCase().includes("not found") ||
              (error.message.toLowerCase().includes("code") &&
                error.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error fetching scene item ID for transform of '${sourceName}' in '${sceneName}': ${error.message}. Cannot apply transform.`,
                "logMessages.obs.errorFetchingItemIdForTransform", { sourceName, sceneName, message: error.message }
              );
            }
            return;
          }
        }

        if (!itemIdToTransform) {
          // console.warn(`No scene item ID to transform for ${sourceName} in ${sceneName}`);
          return; // Ainda não há ID, não pode transformar
        }

        // Se autoGrid estiver selecionado, chame a função de rearranjo para toda a cena
        if (sourceSizingSelect.value === "autoGrid") {
          logMessage(
            `Auto-grid enabled for scene '${sceneName}'. Triggering rearrange.`,
            "logMessages.obs.autoGridEnabledRearranging", { sceneName }
          );
          await rearrangeAllStreamsInScene(sceneName);
        } else {
          // Caso contrário, aplica a transformação individual baseada no modo selecionado
          try {
            const transform = calculateTransform(
              sourceSizingSelect.value, // Modo de dimensionamento (defaultSize, bestFit, stretchToFill)
              canvasWidth, // Largura da fonte (usada como base, pode ser sobrescrita por bounds)
              canvasHeight, // Altura da fonte
              canvasWidth, // Largura do canvas
              canvasHeight // Altura do canvas
            );
            await sendRequest("SetSceneItemTransform", {
              sceneName,
              sceneItemId: itemIdToTransform,
              sceneItemTransform: transform,
            });
            // logMessage(`Applied non-grid transform to '${sourceName}' in '${sceneName}'.`);
          } catch (error) {
            logMessage(
              `Error applying non-grid transform to '${sourceName}' (Item ID: ${itemIdToTransform}) in '${sceneName}': ${error.message}`,
              "logMessages.obs.errorApplyingNonGridTransform", { sourceName, itemId: itemIdToTransform, sceneName, message: error.message }
            );
          }
        }
      }

      async function rearrangeAllStreamsInScene(sceneName) {
        if (
          !obsConnected ||
          !obs ||
          !sceneName ||
          sourceSizingSelect.value !== "autoGrid" // Só executa se autoGrid estiver selecionado
        ) {
          if (sourceSizingSelect.value !== "autoGrid") return; // Não faz nada se não for autoGrid
          logMessage(
            `Cannot rearrange streams in scene '${sceneName}': OBS not connected, scene name missing, or auto-grid not selected.`,
            "logMessages.obs.cannotRearrangeStreams", { sceneName }
          );
          return;
        }
        logMessage(
          `Rearranging VDO.Ninja streams in scene '${sceneName}' using autoGrid layout.`,
          "logMessages.obs.rearrangingStreamsAutoGrid", { sceneName }
        );

        try {
          let canvasWidth = 1920,
            canvasHeight = 1080;
          try {
            const videoSettings = await sendRequest("GetVideoSettings");
            if (
              videoSettings &&
              videoSettings.baseWidth &&
              videoSettings.baseHeight
            ) {
              canvasWidth = videoSettings.baseWidth;
              canvasHeight = videoSettings.baseHeight;
            }
          } catch (error) {
            logMessage(
              `Canvas size error during rearrange for scene '${sceneName}': ${error.message}. Using default ${canvasWidth}x${canvasHeight}.`,
              "logMessages.obs.canvasSizeErrorRearrange", { sceneName, message: error.message, width: canvasWidth, height: canvasHeight }
            );
          }

          const sceneItemsResponse = await sendRequest("GetSceneItemList", {
            sceneName,
          });
          const camPrefixWithUnderscore = getFullCameraPrefix() + "_";
          const hlPrefixWithUnderscore = getFullHighlightPrefix() + "_";

          // Filtra apenas as fontes VDO.Ninja ativas e criadas na cena
          const vdoNinjaSourcesInScene = sceneItemsResponse.sceneItems.filter(
            (item) => {
              const isRegularCameraSource = item.sourceName.startsWith(
                camPrefixWithUnderscore
              );
              const isHighlightedCameraSource = item.sourceName.startsWith(
                hlPrefixWithUnderscore
              );

              let streamIdFromSourceName = null;
              if (isRegularCameraSource) {
                streamIdFromSourceName = item.sourceName.substring(
                  camPrefixWithUnderscore.length
                );
              } else if (isHighlightedCameraSource) {
                streamIdFromSourceName = item.sourceName.substring(
                  hlPrefixWithUnderscore.length
                );
              }

              // Verifica se o streamId extraído existe nos activeStreams e está marcado como conectado e sourceCreated
              return (
                (isRegularCameraSource || isHighlightedCameraSource) && // É uma fonte de câmera ou highlight
                streamIdFromSourceName && // Conseguiu extrair um ID
                activeStreams[streamIdFromSourceName] && // O stream está na lista de ativos
                activeStreams[streamIdFromSourceName].connected && // Está conectado via VDO.Ninja
                activeStreams[streamIdFromSourceName].sourceCreated // A fonte foi marcada como criada no OBS
              );
            }
          );

          if (vdoNinjaSourcesInScene.length === 0) {
            // logMessage(`No active VDO.Ninja sources to rearrange in scene '${sceneName}'.`);
            return;
          }

          const positions = calculateGridPositions(
            vdoNinjaSourcesInScene.length,
            canvasWidth,
            canvasHeight
          );

          for (let i = 0; i < vdoNinjaSourcesInScene.length; i++) {
            const item = vdoNinjaSourcesInScene[i];
            const transform = calculateTransform(
              "autoGrid", // Força o modo autoGrid para esta função
              canvasWidth, // Largura base da fonte (será ajustada pelo grid)
              canvasHeight, // Altura base da fonte
              canvasWidth, // Largura do canvas
              canvasHeight, // Altura do canvas
              positions[i] // Posição calculada do grid
            );
            await sendRequest("SetSceneItemTransform", {
              sceneName,
              sceneItemId: item.sceneItemId,
              sceneItemTransform: transform,
            });
          }
          logMessage(
            `Successfully rearranged ${vdoNinjaSourcesInScene.length} VDO.Ninja sources in scene '${sceneName}'.`,
            "logMessages.obs.successfullyRearrangedSources", { count: vdoNinjaSourcesInScene.length, sceneName }
          );
        } catch (error) {
          logMessage(
            `Error rearranging streams in scene '${sceneName}': ${error.message}`,
            "logMessages.obs.errorRearrangingStreams", { sceneName, message: error.message }
          );
        }
      }

      function calculateTransform(
        sizingMode,
        sourceWidth, // Largura original da fonte (geralmente do canvas do OBS)
        sourceHeight, // Altura original da fonte
        canvasWidth, // Largura do canvas de destino do OBS
        canvasHeight, // Altura do canvas de destino
        gridPosition = null // Objeto { x, y, width, height } para modo grid
      ) {
        let transform = {
          alignment: 5, // Centralizado (OBS_ALIGN_CENTER)
          boundsType: "OBS_BOUNDS_NONE", // Sem bounds por padrão
          boundsAlignment: 0, // Não relevante sem bounds
          boundsWidth: sourceWidth, // Largura dos bounds igual à da fonte
          boundsHeight: sourceHeight, // Altura dos bounds igual à da fonte
          positionX: (canvasWidth - sourceWidth) / 2, // Posição X para centralizar
          positionY: (canvasHeight - sourceHeight) / 2, // Posição Y para centralizar
          scaleX: 1.0,
          scaleY: 1.0,
          rotation: 0.0,
          cropTop: 0,
          cropBottom: 0,
          cropLeft: 0,
          cropRight: 0,
          sourceWidth: sourceWidth, // Largura da fonte original (para referência do OBS)
          sourceHeight: sourceHeight, // Altura da fonte original
          width: sourceWidth, // Largura renderizada (pode ser alterada por bounds/scale)
          height: sourceHeight, // Altura renderizada
        };

        switch (sizingMode) {
          case "stretchToFill":
            transform.boundsType = "OBS_BOUNDS_STRETCH";
            transform.boundsWidth = canvasWidth;
            transform.boundsHeight = canvasHeight;
            transform.width = canvasWidth; // Estica para preencher
            transform.height = canvasHeight;
            transform.positionX = 0; // Alinha no canto superior esquerdo
            transform.positionY = 0;
            break;
          case "bestFit": // Scale to fit (mantendo aspect ratio, pode ter letterbox/pillarbox)
            transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; // OBS_BOUNDS_SCALE_ASPECT_RATIO_FIT
            transform.boundsWidth = canvasWidth;
            transform.boundsHeight = canvasHeight;
            transform.width = canvasWidth; // Define a área de renderização para o canvas inteiro
            transform.height = canvasHeight;
            transform.positionX = 0; // Alinha no canto superior esquerdo
            transform.positionY = 0;
            break;
          case "autoGrid":
            if (gridPosition) {
              transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; // Ou OBS_BOUNDS_STRETCH se preferir preencher a célula
              transform.positionX = gridPosition.x;
              transform.positionY = gridPosition.y;
              transform.boundsWidth = gridPosition.width;
              transform.boundsHeight = gridPosition.height;
              transform.width = gridPosition.width; // Define a largura da célula do grid
              transform.height = gridPosition.height; // Define a altura da célula
            } else {
              // Fallback se gridPosition não for fornecido (deve ser logado como aviso)
              logMessage(
                "Warning: autoGrid sizing mode called without gridPosition. Falling back to 'bestFit'.",
                "logMessages.obs.warningAutoGridNoPosition"
              );
              transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
              transform.boundsWidth = canvasWidth;
              transform.boundsHeight = canvasHeight;
              transform.width = canvasWidth;
              transform.height = canvasHeight;
              transform.positionX = 0;
              transform.positionY = 0;
            }
            break;
          case "defaultSize": // Tamanho padrão (1920x1080) centralizado, ou scaledown se maior que canvas
          default:
            // A posição já está centralizada pelo default de transform
            // Se a fonte for maior que o canvas, ajuste para caber (bestFit implícito para fontes grandes)
            if (sourceWidth > canvasWidth || sourceHeight > canvasHeight) {
                const scaleRatioX = canvasWidth / sourceWidth;
                const scaleRatioY = canvasHeight / sourceHeight;
                const scale = Math.min(scaleRatioX, scaleRatioY);

                transform.width = sourceWidth * scale;
                transform.height = sourceHeight * scale;
                transform.positionX = (canvasWidth - transform.width) / 2;
                transform.positionY = (canvasHeight - transform.height) / 2;
            }
            // Se for menor, já está centralizada com seu tamanho original
            break;
        }
        return transform;
      }

      async function removeStreamFromObs(streamId) {
        if (!obsConnected || !obs) {
          logMessage(
            `Cannot remove stream ${streamId} from OBS: Not connected to OBS.`,
            "logMessages.obs.cannotRemoveStreamNotConnected", { id: streamId }
          );
          return;
        }
        // Mesmo que o stream não esteja em activeStreams (ex: se a página foi recarregada),
        // tente remover a fonte se ela existir no OBS com os prefixos corretos.
        if (
          !activeStreams[streamId] &&
          streamId !== screenShareId && // Não é o screen share ativo
          streamId !== highlightedStreamId // Não é o highlight ativo
        ) {
          // Se não há registro local, não há muito o que fazer a menos que queiramos
          // varrer o OBS por fontes com esse ID, o que pode ser perigoso.
          // Por ora, só remove se houver um registro ou for um dos globais.
          // logMessage(`Stream ${streamId} not found in active local records. Removal might be incomplete if source exists in OBS.`);
        }

        const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
        const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
        logMessage(
          `User or auto-triggered removal of stream '${streamId}' from OBS. Base source: '${baseSourceName}', Highlighted: '${highlightedSourceName}'.`,
          "logMessages.obs.triggeredRemoval", { id: streamId, baseName: baseSourceName, highlightName: highlightedSourceName }
        );

        const streamInfo = activeStreams[streamId];
        const currentLabel = streamInfo
          ? streamInfo.label
          : i18next.t("vdoNinja.defaultStreamLabel", {id: streamId}); // Fallback para label
        const targetInfo = getTargetSceneForStream(streamId, currentLabel);

        // Se o stream a ser removido estiver destacado, desfaça o highlight primeiro
        if (highlightedStreamId === streamId) {
          logMessage(
            `Stream ${streamId} is currently highlighted. Unhighlighting before removal.`,
            "logMessages.obs.streamHighlightedUnhighlightingBeforeRemove", { id: streamId }
          );
          await toggleHighlight(streamId, currentLabel, targetInfo); // Isso deve renomear de volta para baseSourceName
        }

        // Coleta todas as cenas onde a fonte (baseSourceName) pode existir
        const scenesToClean = new Set();
        if (targetInfo && targetInfo.scene) {
          scenesToClean.add(targetInfo.scene); // Cena mapeada/padrão do stream
        }
        const globalMainScene = getTargetScene(); // Cena principal global
        if (globalMainScene) {
          scenesToClean.add(globalMainScene);
        }
        // Adiciona "outras cenas" selecionadas
        document
          .querySelectorAll(".other-scene-checkbox:checked")
          .forEach((checkbox) => {
            if (checkbox.value) scenesToClean.add(checkbox.value);
          });

        let itemRemovedThisRun = false;

        // Tenta remover o item da cena (baseSourceName) de todas as cenas coletadas
        for (const sceneName of scenesToClean) {
          if (!sceneName) continue; // Pula se o nome da cena for inválido

          if (await tryRemoveFromScene(baseSourceName, sceneName)) {
            itemRemovedThisRun = true;
          }
          // Não tentamos remover highlightedSourceName daqui, pois toggleHighlight já deve ter revertido
        }

        // Se o stream era um screen share ativo, remova-o completamente
        if (screenShareId === streamId) {
          logMessage(
            `Stream ${streamId} was actively screen sharing. Initiating screen share removal.`,
            "logMessages.obs.streamScreenSharingRemoving", { id: streamId }
          );
          await removeScreenShareFromObs(streamId); // Função específica para limpar screen share
        }

        // Atualiza o estado local
        if (activeStreams[streamId]) {
          activeStreams[streamId].sourceCreated = false;
        }

        if (itemRemovedThisRun) {
          logMessage(
            `Finished removing source items for stream ${streamId} from specified OBS scenes.`,
            "logMessages.obs.finishedRemovingSourceItems", { id: streamId }
          );
        }

        // Se autoGrid estiver ativo, rearranje as cenas afetadas
        if (sourceSizingSelect.value === "autoGrid") {
          const uniqueScenesProcessed = new Set(
            Array.from(scenesToClean).filter((s) => s) // Filtra nomes de cena válidos
          );
          for (const sceneName of uniqueScenesProcessed) {
            logMessage(
              `Auto-grid: Triggering rearrange for scene '${sceneName}' after stream removal.`,
              "logMessages.obs.autoGridRearrangeAfterRemove", { sceneName }
            );
            setTimeout(() => rearrangeAllStreamsInScene(sceneName), 250); // Pequeno delay
          }
        }

        // Atualiza a lista de streams na UI, a menos que seja um screen share (já tratado)
        if (screenShareId !== streamId) {
          updateStreamList();
        }
        saveSettings(); // Salva o estado (embora não haja mudança direta de settings aqui)
      }

      async function removeScreenShareFromObs(streamIdToRemove) {
        if (!obsConnected || !obs) {
          logMessage("Cannot remove screen share: Not connected to OBS.", "logMessages.obs.cannotRemoveScreenShareNotConnected");
          return;
        }
        if (!streamIdToRemove) {
          // Se nenhum ID for fornecido, mas screenShareId global é igual, limpe o global
          if (screenShareId === streamIdToRemove) { // Isso será true se streamIdToRemove for null/undefined e screenShareId também
            screenShareId = null;
            updateStreamList();
          }
          return;
        }

        const sourceName = `${getFullReactionPrefix()}_${streamIdToRemove}:s`; // Nome da fonte de screen share
        logMessage(
          `Attempting to fully remove screen share source '${sourceName}' from OBS (all scenes and input).`,
          "logMessages.obs.attemptingRemoveScreenShareSource", { sourceName }
        );

        let itemRemovedFromAnyScene = false;
        try {
          // 1. Remove o item de todas as cenas onde possa existir
          const scenesResponse = await sendRequest("GetSceneList");
          if (scenesResponse && scenesResponse.scenes) {
            for (const scene of scenesResponse.scenes) {
              if (await tryRemoveFromScene(sourceName, scene.sceneName)) {
                itemRemovedFromAnyScene = true;
              }
            }
          }

          // 2. Remove a fonte (input) globalmente, se existir e não estiver em uso por outra cena (OBS pode impedir)
          try {
            // Verifica se a fonte existe antes de tentar remover
            await sendRequest(
              "GetInputSettings",
              { inputName: sourceName },
              { suppressNotFound: true } // Não logar erro se não encontrar
            );
            // Se chegou aqui, a fonte existe
            logMessage(`Removing global input '${sourceName}' from OBS.`, "logMessages.obs.removingGlobalInput", { sourceName });
            await sendRequest("RemoveInput", { inputName: sourceName });
            logMessage(`Successfully removed input '${sourceName}'.`, "logMessages.obs.successfullyRemovedInput", { sourceName });
          } catch (e) {
            // Se a fonte não foi encontrada, não há o que remover globalmente.
            // Outros erros podem indicar que a fonte está em uso e não pode ser removida.
            const isNotFound =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));

            if (!isNotFound) {
              logMessage(
                `Global input removal for '${sourceName}' failed (may be in use or other error): ${e.message}`,
                "logMessages.obs.globalInputRemovalFailed", { sourceName, message: e.message }
              );
            }
            // Mesmo que a remoção global falhe, o item da cena pode ter sido removido.
          }
        } catch (error) {
          logMessage(
            `Error during screen share removal process for '${sourceName}': ${error.message}`,
            "logMessages.obs.errorScreenShareRemovalProcess", { sourceName, message: error.message }
          );
        } finally {
          // Limpa o ID global de screen share se for o que foi removido
          if (screenShareId === streamIdToRemove) {
            screenShareId = null;
          }
          updateStreamList(); // Atualiza a UI
        }
      }

      async function tryRemoveFromScene(sourceName, sceneName) {
        if (!sceneName) {
          // logMessage(`Cannot remove source '${sourceName}': Scene name not provided.`);
          return false;
        }
        try {
          const itemInfo = await sendRequest(
            "GetSceneItemId",
            { sceneName, sourceName },
            { suppressNotFound: true } // Não logar erro se não encontrar
          );
          if (itemInfo && itemInfo.sceneItemId) {
            logMessage(
              `Removing source item '${sourceName}' (ID: ${itemInfo.sceneItemId}) from scene '${sceneName}'.`,
              "logMessages.obs.removingSourceItemFromScene", { sourceName, itemId: itemInfo.sceneItemId, sceneName }
            );
            await sendRequest("RemoveSceneItem", {
              sceneName,
              sceneItemId: itemInfo.sceneItemId,
            });
            return true; // Item removido com sucesso
          }
          return false; // Item não encontrado na cena
        } catch (error) {
          // Loga apenas erros que não sejam "não encontrado"
          const isNotFound =
            error.message.toLowerCase().includes("not found") ||
            error.message.toLowerCase().includes("no scene items were found") || // OBS v28+
            error.message.toLowerCase().includes("could not find") || // OBS v27
            (error.message.toLowerCase().includes("code") &&
              error.message.toLowerCase().includes("600")); // Código de erro para "não encontrado"
          if (!isNotFound) {
            logMessage(
              `Error trying to remove source item '${sourceName}' from scene '${sceneName}': ${error.message}`,
              "logMessages.obs.errorTryingRemoveSourceItem", { sourceName, sceneName, message: error.message }
            );
          }
          return false; // Erro ou item não encontrado
        }
      }

      function loadJsShaLibrary() {
        return new Promise((resolve, reject) => {
          if (typeof jsSHA !== "undefined") {
            // Biblioteca já carregada
            resolve();
            return;
          }
          const script = document.createElement("script");
          script.src =
            "https://cdnjs.cloudflare.com/ajax/libs/jsSHA/3.3.0/sha256.js"; // CDN para jsSHA
          script.onload = () => {
            logMessage(
              "jsSHA library loaded successfully (fallback for Web Crypto).",
              "logMessages.jsShaLoaded"
            );
            resolve();
          };
          script.onerror = () => {
            logMessage(
              "Error: Failed to load jsSHA library. OBS authentication might fail if Web Crypto is also unavailable.",
              "logMessages.errorLoadingJsSha"
            );
            reject(new Error("Failed to load jsSHA library"));
          };
          document.head.appendChild(script);
        });
      }

      function setupSecureFieldsBlur() {
        const secureFields = document.querySelectorAll(
          "#vdoNinjaRoom, #vdoNinjaStreamIds"
        ); // Adicione outros IDs se necessário
        secureFields.forEach((field) => {
          field.classList.add("blur-field"); // Aplica o blur inicialmente
          field.addEventListener("focus", () =>
            field.classList.remove("blur-field")
          );
          field.addEventListener("blur", () => {
            // Reaplica o blur se o campo estiver vazio ao perder o foco
            if (field.value === "") field.classList.add("blur-field");
          });
          // Garante que o blur seja aplicado na carga se o campo estiver vazio
          if (field.value === "") {
            field.classList.add("blur-field");
          }
        });
      }


      // Event listeners para salvar configurações em mudanças
      const otherScenesContainer = document.getElementById(
        "otherScenesContainer"
      );
      const otherScenesListDiv = document.getElementById("otherScenesList");
      const screenShareSceneSelect = document.getElementById(
        "screenShareSceneSelect"
      );

      obsSceneSelect.addEventListener("change", () => {
        obsSceneNameInput.value = obsSceneSelect.value; // Atualiza o input escondido (se ainda usado)
        saveSettings();
        updateOtherScenesList(); // Atualiza a lista de "outras cenas"
        updateStreamList(); // Atualiza a lista de streams para refletir a nova cena padrão
        // Se autoGrid estiver ativo, rearranje a nova cena principal
        if (sourceSizingSelect.value === "autoGrid" && getTargetScene()) {
          rearrangeAllStreamsInScene(getTargetScene());
        }
      });

      [
        obsWsUrlInput,
        obsWsPasswordInput,
        // cameraPrefixInput, // Já tem listener individual
        // reactionSubPrefixInput, // Já tem listener individual
        // highlightSubPrefixInput, // Já tem listener individual
        vdoNinjaBaseUrlInput,
        vdoNinjaRoomInput,
        vdoNinjaPasswordInput,
        vdoNinjaStreamIdsInput,
        autoAddSourcesCheckbox,
        autoRemoveSourcesCheckbox,
        highlightSceneSelect,
        screenShareSceneSelect,
        // customCssInput // Já tem listener individual modificado
      ].forEach((el) => {
        if (el) el.addEventListener("change", saveSettings); // 'change' é melhor para selects e checkboxes
      });

      sourceSizingSelect.addEventListener("change", () => {
        saveSettings();
        if (sourceSizingSelect.value === "autoGrid") {
          // Se mudou para autoGrid, rearranje todas as cenas relevantes
          const mainTargetScene = getTargetScene();
          if (mainTargetScene) {
            rearrangeAllStreamsInScene(mainTargetScene);
          }
          // Rearranja "outras cenas" selecionadas
          document
            .querySelectorAll(".other-scene-checkbox:checked")
            .forEach((checkbox) => {
              if (checkbox.value) rearrangeAllStreamsInScene(checkbox.value);
            });
          // Rearranja cenas de mapeamentos
          getStreamMappings().forEach(mapping => {
            if(mapping.sceneName) rearrangeAllStreamsInScene(mapping.sceneName);
          });

        } else {
          // Se mudou de autoGrid para outro modo, aplique a transformação padrão
          // a todas as fontes gerenciadas em todas as cenas relevantes.
          const scenesToUpdate = new Set();
          if (getTargetScene()) scenesToUpdate.add(getTargetScene());
          document
            .querySelectorAll(".other-scene-checkbox:checked")
            .forEach((cb) => scenesToUpdate.add(cb.value));
          getStreamMappings().forEach((m) => scenesToUpdate.add(m.sceneName));

          scenesToUpdate.forEach((sceneName) => {
            if (sceneName)
              applyStandardTransformToAllManagedStreamsInScene(sceneName);
          });
        }
      });

      async function applyStandardTransformToAllManagedStreamsInScene(
        sceneName
      ) {
        if (!obsConnected || !sceneName || sourceSizingSelect.value === "autoGrid")
          return; // Só aplica se não for autoGrid
        logMessage(
          `Applying standard transform ('${sourceSizingSelect.value}') to VDO.Ninja sources in scene '${sceneName}'.`,
          "logMessages.obs.applyingStandardTransform", { sizing: sourceSizingSelect.value, sceneName }
        );

        try {
          let canvasWidth = 1920,
            canvasHeight = 1080;
          const videoSettings = await sendRequest("GetVideoSettings");
          if (
            videoSettings &&
            videoSettings.baseWidth &&
            videoSettings.baseHeight
          ) {
            canvasWidth = videoSettings.baseWidth;
            canvasHeight = videoSettings.baseHeight;
          }

          const sceneItemsResponse = await sendRequest("GetSceneItemList", {
            sceneName,
          });
          const camPrefixWithUnderscore = getFullCameraPrefix() + "_";
          const hlPrefixWithUnderscore = getFullHighlightPrefix() + "_";

          for (const item of sceneItemsResponse.sceneItems) {
            // Verifica se é uma fonte gerenciada por este script
            const isManagedSource =
              (item.sourceName.startsWith(camPrefixWithUnderscore) ||
                item.sourceName.startsWith(hlPrefixWithUnderscore)) &&
              item.inputKind === "browser_source"; // Garante que é uma fonte de navegador

            if (isManagedSource) {
              // Verifica se o stream correspondente está ativo e criado
              const streamIdGuess = item.sourceName
                .replace(camPrefixWithUnderscore, "")
                .replace(hlPrefixWithUnderscore, "");
              if (
                activeStreams[streamIdGuess] &&
                activeStreams[streamIdGuess].sourceCreated
              ) {
                const transform = calculateTransform(
                  sourceSizingSelect.value, // Modo de dimensionamento atual
                  canvasWidth,
                  canvasHeight,
                  canvasWidth,
                  canvasHeight
                );
                await sendRequest("SetSceneItemTransform", {
                  sceneName,
                  sceneItemId: item.sceneItemId,
                  sceneItemTransform: transform,
                });
              }
            }
          }
        } catch (error) {
          logMessage(
            `Error applying standard transform in scene '${sceneName}': ${error.message}`,
            "logMessages.obs.errorApplyingStandardTransform", { sceneName, message: error.message }
          );
        }
      }

      sourceCodecSelect.addEventListener("change", async () => {
        saveSettings();
        const newCodec = sourceCodecSelect.value;
        logMessage(
          `Codec changed to: ${newCodec || "none"}. Updating OBS sources...`,
          "logMessages.obs.codecChangedUpdatingSources", { codec: newCodec || "none" }
        );

        if (!obsConnected) {
          logMessage(
            "OBS is not connected. Sources will not be updated with the new codec until reconnection and a new action.",
            "logMessages.obs.codecChangedNotConnected"
          );
          return;
        }

        // Atualiza todas as fontes de câmera ativas
        for (const streamId in activeStreams) {
          if (
            Object.hasOwnProperty.call(activeStreams, streamId) &&
            activeStreams[streamId].sourceCreated // Só atualiza se a fonte OBS foi criada
          ) {
            let effectiveSourceName = `${getFullCameraPrefix()}_${streamId}`;
            if (highlightedStreamId === streamId) {
              // Se estiver destacada, usa o nome de destaque
              effectiveSourceName = `${getFullHighlightPrefix()}_${streamId}`;
            }

            try {
              const currentSettingsResponse = await sendRequest(
                "GetInputSettings",
                { inputName: effectiveSourceName },
                { suppressNotFound: true } // Não logar erro se não encontrar
              );
              if (
                currentSettingsResponse &&
                currentSettingsResponse.inputSettings
              ) {
                const newViewUrl = getVdoNinjaViewUrl(streamId); // Gera a nova URL com o codec atualizado
                const updatedSettings = {
                  ...currentSettingsResponse.inputSettings,
                  url: newViewUrl, // Atualiza apenas a URL
                };

                await sendRequest("SetInputSettings", {
                  inputName: effectiveSourceName,
                  inputSettings: updatedSettings,
                });
                logMessage(
                  `Source '${effectiveSourceName}' updated with URL: ${newViewUrl}`,
                  "logMessages.obs.sourceUpdatedWithUrl", { sourceName: effectiveSourceName, url: newViewUrl }
                );
              }
            } catch (error) {
              // Loga apenas erros que não sejam "não encontrado"
              const isNotFound =
                error.message.toLowerCase().includes("not found") ||
                (error.message.toLowerCase().includes("code") &&
                  error.message.toLowerCase().includes("600"));
              if (!isNotFound) {
                logMessage(
                  `Error updating codec for source '${effectiveSourceName}': ${error.message}`,
                  "logMessages.obs.errorUpdatingCodecForSource", { sourceName: effectiveSourceName, message: error.message }
                );
              }
            }
          }
        }

        // Atualiza a fonte de screen share ativa, se houver
        if (screenShareId) {
          const screenShareSourceName = `${getFullReactionPrefix()}_${screenShareId}:s`;
          try {
            const currentScreenShareSettingsResponse = await sendRequest(
              "GetInputSettings",
              { inputName: screenShareSourceName },
              { suppressNotFound: true }
            );
            if (
              currentScreenShareSettingsResponse &&
              currentScreenShareSettingsResponse.inputSettings
            ) {
              const room = vdoNinjaRoomInput.value.trim(); // Necessário para URL de screen share
              const baseUrl = getVdoNinjaBaseUrl();
              let newScreenShareUrl = `${baseUrl}/?view=${encodeURIComponent(
                screenShareId
              )}:s&solo&room=${encodeURIComponent(room)}`;

              if (newCodec && newCodec !== "") {
                newScreenShareUrl += `&codec=${encodeURIComponent(newCodec)}`;
              } else {
                newScreenShareUrl += `&codec=vp9`; // Codec padrão para screen share
              }
              if (vdoNinjaPasswordInput.value) {
                newScreenShareUrl += `&password=${encodeURIComponent(
                  vdoNinjaPasswordInput.value
                )}`;
              }
              newScreenShareUrl += "&cleanoutput&transparent&proaudio";

              const updatedScreenShareSettings = {
                ...currentScreenShareSettingsResponse.inputSettings,
                url: newScreenShareUrl,
              };

              await sendRequest("SetInputSettings", {
                inputName: screenShareSourceName,
                inputSettings: updatedScreenShareSettings,
              });
              logMessage(
                `Screen share source '${screenShareSourceName}' updated with URL: ${newScreenShareUrl}`,
                "logMessages.obs.screenShareSourceUpdatedWithUrl", { sourceName: screenShareSourceName, url: newScreenShareUrl }
              );
            }
          } catch (error) {
            const isNotFound =
              error.message.toLowerCase().includes("not found") ||
              (error.message.toLowerCase().includes("code") &&
                error.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error updating codec for screen share source '${screenShareSourceName}': ${error.message}`,
                "logMessages.obs.errorUpdatingCodecForScreenShare", { sourceName: screenShareSourceName, message: error.message }
              );
            }
          }
        }
        logMessage("Codec update for OBS sources complete.", "logMessages.obs.codecUpdateComplete");
      });

      loadScenesBtn.addEventListener("click", fetchObsScenes);

      // Event listeners para salvar configurações de screen share
      if (screenShareSceneSelect) {
        screenShareSceneSelect.addEventListener("change", saveSettings);
      }
      const screenShareWidthInput =
        document.getElementById("screenShareWidth");
      const screenShareHeightInput =
        document.getElementById("screenShareHeight");
      if (screenShareWidthInput)
        screenShareWidthInput.addEventListener("change", saveSettings);
      if (screenShareHeightInput)
        screenShareHeightInput.addEventListener("change", saveSettings);

      // Inicialização da aplicação quando o DOM estiver pronto
      document.addEventListener("DOMContentLoaded", () => {
        initializeApp(); // Função principal de inicialização
      });

      // Função para ofuscar campos seguros (movida para o final para melhor organização)
      function setupSecureFieldsBlur() {
        const secureFields = document.querySelectorAll(
          "#vdoNinjaRoom, #vdoNinjaStreamIds"
        );
        secureFields.forEach((field) => {
          field.classList.add("blur-field");
          field.addEventListener("focus", () =>
            field.classList.remove("blur-field")
          );
          field.addEventListener("blur", () => {
            if (field.value === "") field.classList.add("blur-field");
          });
          if (field.value === "") {
            field.classList.add("blur-field");
          }
        });
      }
    </script>
  </body>
</html>
