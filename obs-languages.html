<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/i18next/dist/umd/i18next.min.js"></script>
    <script src="https://unpkg.com/i18next-http-backend/i18nextHttpBackend.js"></script>
    <title data-i18n="pageTitle">VDO.Ninja OBS Control Dock</title>
    <style>
      body {
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif; /* Modern font stack */
        margin: 0; /* Remove default margin */
        padding: 15px; /* Add some padding around the whole page */
        background-color: #181a1b; /* Slightly different dark */
        color: #e0e0e0;
        font-size: 14px; /* Base font size */
        line-height: 1.6; /* Improved readability */
      }
      .language-switcher {
        display: flex; /* For better alignment of label and select */
        align-items: center;
        gap: 8px; /* Space between label and select */
      }
      .language-switcher label {
        margin-right: 0; /* Reset margin as gap is used */
        color: #c0c0c0;
        font-size: 0.9em;
        margin-bottom: 0; /* Align with select */
      }
      .language-switcher select {
        padding: 5px 8px;
        border-radius: 4px;
        background-color: #25272c;
        color: #e0e0e0;
        border: 1px solid #4a4d54;
        font-size: 0.9em;
        margin-bottom: 0; /* Align with label */
        width: auto; /* Allow select to size based on content */
        min-width: 120px; /* Ensure a minimum decent width */
      }
      h1 {
        color: #d0d0d0;
        margin: 20px 0 20px 0; /* Adjusted h1 margin */
        padding-bottom: 15px;
        font-size: 1.8em; /* h1 size */
        font-weight: 600;
        border-bottom: 1px solid #3e4147; /* Separator for main title */
      }
      .container {
        margin-bottom: 15px; /* Increased spacing */
        padding: 15px; /* Increased padding */
        background-color: #2c2e33; /* Darker, richer container */
        border-radius: 8px; /* More rounded */
        border: 1px solid #3e4147; /* Softer border */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
      }
      .collapsible {
        cursor: pointer;
        user-select: none;
        padding: 12px 15px;
        position: relative;
        font-weight: 600;
        font-size: 1.1em;
        background: #35383d;
        margin: -15px -15px 10px -15px;
        padding-left: 15px;
        border-bottom: 1px solid #3e4147;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        transition: background-color 0.2s ease;
      }
      .collapsible.collapsed {
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        margin-bottom: 0;
        border-bottom: none;
      }
      .container .collapsible:last-child.collapsed {
        margin-bottom: -15px;
      }
      .collapsible[data-state="expand"]::after {
        content: "▼";
      }
      .collapsible[data-state="collapse"]::after {
        content: "▲";
      }
      .collapsible::after {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 14px;
        color: #a0a0b0;
        transition: transform 0.2s ease;
      }
      .collapsible[data-state="expand"]::before {
        /* Will be set by JS */
      }
      .collapsible[data-state="collapse"]::before {
         /* Will be set by JS */
      }
      .collapsible::before {
        content: var(--before-text, "Click"); /* Use CSS variable for dynamic text */
        position: absolute;
        right: 40px;
        font-size: 10px;
        color: #666;
        font-weight: normal;
      }
      .collapsible:hover {
        background: #404348;
      }
      .collapsible-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out, padding-top 0.3s ease-in-out,
          opacity 0.3s ease-in-out;
        padding-top: 10px;
        opacity: 1;
      }
      .collapsible-content.collapsed {
        max-height: 0;
        padding-top: 0;
        opacity: 0;
        overflow: hidden;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500; /* Slightly bolder labels */
        color: #c0c0c0; /* Lighter labels */
      }
      input[type="text"],
      input[type="password"],
      input[type="number"],
      select {
        width: calc(
          100% - 22px
        ); /* Adjusted width calculation for padding (10px each side + 1px border each side) */
        padding: 10px; /* More padding */
        margin-bottom: 12px; /* More spacing */
        border: 1px solid #4a4d54; /* Softer border */
        border-radius: 6px; /* More rounded */
        background-color: #25272c; /* Darker input background */
        color: #e0e0e0;
        font-size: 1em;
        box-sizing: border-box; /* Ensures padding and border don't increase width */
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      input[type="text"]:focus,
      input[type="password"]:focus,
      input[type="number"]:focus,
      select:focus {
        border-color: #007aff; /* Accent color on focus */
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25); /* Focus ring */
        outline: none;
      }
      select {
        padding-right: 30px; /* Make space for the arrow */
        appearance: none; /* For custom arrow */
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23A0A0B0'%3E%3Cpath d='M8 11L3 6h10L8 11z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 12px;
      }
      button {
        padding: 10px 15px; /* Larger padding */
        background-color: #4a5060; /* Default button color */
        color: white;
        border: none;
        border-radius: 6px; /* More rounded */
        cursor: pointer;
        margin-right: 5px;
        margin-bottom: 5px;
        font-size: 0.95em;
        font-weight: 500;
        transition: background-color 0.2s ease, transform 0.1s ease;
      }
      button:hover {
        background-color: #5a6070; /* Darker hover */
      }
      button:active {
        transform: translateY(1px); /* Click effect */
      }
      button.connected {
        background-color: #007aff; /* Modern blue for connected */
      }
      button.connected:hover {
        background-color: #0056b3;
      }
      button.disconnected {
        background-color: #6c757d; /* Grey for disconnected */
      }
      button.disconnected:hover {
        background-color: #5a6268;
      }
      .blur-field {
        filter: blur(5px);
        transition: filter 0.2s ease;
      }
      .blur-field:focus {
        filter: blur(0);
      }
      #vdoNinjaIframe {
        width: 1px;
        height: 1px;
        position: absolute;
        left: -1000px;
        top: -1000px;
        border: 0;
      }
      .log-area {
        height: 120px; /* Slightly taller */
        background-color: #202225; /* Consistent dark background */
        color: #b0b0b0; /* Softer log text */
        border: 1px solid #4a4d54;
        border-radius: 6px; /* Rounded */
        overflow-y: scroll;
        padding: 10px;
        font-family: "Consolas", "Monaco", "Lucida Console", monospace; /* Monospace for logs */
        font-size: 0.9em;
        margin-top: 10px;
        white-space: pre-wrap;
      }
      .status-indicator {
        display: inline-block;
        width: 10px; /* Slightly larger */
        height: 10px; /* Slightly larger */
        border-radius: 50%;
        margin-left: 8px;
        background-color: #555;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }
      .status-indicator.connected {
        background-color: #007aff; /* Consistent blue */
        box-shadow: 0 0 8px rgba(0, 122, 255, 0.7); /* Glow effect */
      }
      .status-indicator.error {
        background-color: #dc3545; /* Standard error red */
        box-shadow: 0 0 8px rgba(220, 53, 69, 0.7); /* Glow effect */
      }
      .stream-list {
        background-color: #202225;
        border: 1px solid #4a4d54;
        border-radius: 6px;
        padding: 5px; /* Reduced overall padding for stream list */
        margin-top: 5px;
        transition: max-height 0.3s ease;
      }
      .stream-list:empty {
        min-height: 40px; /* Adjusted height */
        display: flex;
        align-items: center;
        justify-content: center;
        color: #888; /* Softer text for empty state */
        padding: 10px; /* Padding for empty state text */
      }
      .stream-item {
        padding: 10px 12px; /* More padding */
        border-bottom: 1px solid #383b40; /* Softer separator */
        font-size: 1em; /* Standardized font size */
        word-break: break-word;
        background-color: #2c2e33; /* Slightly different background for items */
        margin: 0 0 8px 0; /* Space between items, remove side margins */
        border-radius: 4px; /* Rounded items */
      }
      .stream-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
      }
      h2 {
        /* Base h2 styles, .collapsible will add more */
        color: #c8c8c8;
        margin: 5px 0;
        font-size: 1.1em;
      }
      small {
        color: #9090a0; /* Softer small text */
        font-size: 0.88em;
        display: block; /* Make small text take its own line often */
        margin-top: 3px;
        line-height: 1.4;
      }
      /* Specific Button Color Overrides */
      /* Note: These rely on the JS setting specific inline background-color styles. */
      .add-stream-btn {
        /* Default "Add to OBS" */
        background-color: #28a745 !important; /* Green for add */
      }
      .add-stream-btn:hover {
        background-color: #218838 !important;
      }
      /* For "Remove from OBS" when JS changes inline style to red */
      button.add-stream-btn[style*="rgb(244, 67, 54)"],
      button.add-stream-btn[style*="#F44336"] {
        background-color: #dc3545 !important; /* Red for remove */
      }
      button.add-stream-btn[style*="rgb(244, 67, 54)"]:hover,
      button.add-stream-btn[style*="#F44336"]:hover {
        background-color: #c82333 !important;
      }
      .highlight-btn {
        /* Default "Highlight" */
        background-color: #17a2b8 !important; /* Info blue/teal */
      }
      .highlight-btn:hover {
        background-color: #138496 !important;
      }
      /* For "Unhighlight" when JS changes inline style to red */
      button.highlight-btn[style*="rgb(244, 67, 54)"],
      button.highlight-btn[style*="#F44336"] {
        background-color: #ffc107 !important; /* Warning yellow */
        color: #212529 !important; /* Dark text for yellow button */
      }
      button.highlight-btn[style*="rgb(244, 67, 54)"]:hover,
      button.highlight-btn[style*="#F44336"]:hover {
        background-color: #e0a800 !important;
      }
      .screen-share-btn {
        /* Default "Screen Share" */
        background-color: #6f42c1 !important; /* Purple */
      }
      .screen-share-btn:hover {
        background-color: #5a2aa8 !important;
      }
      /* For "Stop Screen Share" when JS changes inline style to red */
      button.screen-share-btn[style*="rgb(244, 67, 54)"],
      button.screen-share-btn[style*="#F44336"] {
        background-color: #fd7e14 !important; /* Orange for stop */
      }
      button.screen-share-btn[style*="rgb(244, 67, 54)"]:hover,
      button.screen-share-btn[style*="#F44336"]:hover {
        background-color: #e66c00 !important;
      }
      .status-line {
        font-size: 1em; /* Consistent font size */
        margin-top: 10px;
        display: flex;
        align-items: center;
      }
      #obsConnectionStatus,
      #vdoNinjaConnectionStatus {
        /* Status text styling */
        margin-left: 8px;
        color: #b0b0b0;
      }
      input[type="checkbox"] {
        accent-color: #007aff; /* Modern blue */
        margin-right: 8px; /* More space */
        width: 15px; /* Custom size */
        height: 15px;
        vertical-align: middle;
        flex-shrink: 0; /* Prevent shrinking in flex layouts */
      }
      .checkbox-label {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        color: #c0c0c0;
        font-size: 0.95em;
      }
      .checkbox-label input {
        /* Target checkbox within our label structure */
        margin-bottom: 0; /* Align with label text */
        margin-right: 8px;
      }
      /* Scrollbar styles - refine with new palette */
      ::-webkit-scrollbar {
        width: 10px; /* Slightly wider */
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: #202225; /* Dark track */
        border-radius: 5px;
      }
      ::-webkit-scrollbar-thumb {
        background: #4a4d54; /* Scrollbar thumb */
        border-radius: 5px;
        border: 2px solid #202225; /* Creates a "padding" effect */
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #007aff; /* Accent on hover */
      }
      * {
        /* Firefox scrollbar styling */
        scrollbar-width: auto; /* Or 'thin' if preferred */
        scrollbar-color: #4a4d54 #202225; /* thumb track */
      }
      .flex-row {
        display: flex;
        gap: 8px; /* Increased gap */
        flex-wrap: wrap;
        align-items: center; /* Default alignment for flex-rows */
      }
      #obsSceneNameInput {
        display: none !important;
      }
      #loadScenesBtn {
        margin-left: 5px;
        vertical-align: top; /* Align with select if they were side-by-side */
      }
      .container:nth-child(6) /* Container for Active Streams */
        .collapsible-content:not(.collapsed) {
        /* This rule might need adjustment if it was for allowing the stream list to expand fully.
           With 1000px max-height, it's usually enough. Consider removing if not strictly needed. */
      }
      .prefix-input-label {
        margin-bottom: 4px; /* Slightly more margin */
        display: block;
        font-size: 0.9em; /* Smaller for these sub-labels */
        color: #a0a0b0;
      }
      .prefix-group {
        margin-bottom: 10px; /* More space */
      }
      /* Help icon (?) for codec */
      a[href^="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"] {
        display: inline-flex; /* Use flex to center content */
        align-items: center;
        justify-content: center;
        text-decoration: none;
        color: #a0a0b0;
        font-size: 12px; /* Keep size */
        border: 1px solid #a0a0b0;
        border-radius: 50%;
        width: 18px; /* Slightly larger for easier click */
        height: 18px;
        font-weight: bold;
        vertical-align: middle;
        margin-left: 4px; /* More spacing */
        margin-bottom: 0; /* Align better with select */
        transition: background-color 0.2s ease, color 0.2s ease,
          border-color 0.2s ease;
      }
      a[href^="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"]:hover {
        background-color: #007aff;
        color: white;
        border-color: #007aff;
      }
      /* Stream Mapping UI adjustments */
      .stream-mapping {
        background-color: #25272c; /* Slightly different background */
        padding: 12px;
        border: 1px solid #383b40;
        border-radius: 6px;
        margin-bottom: 10px; /* Add margin-bottom for spacing between mapping rules */
      }
      .stream-mapping .flex-row {
        margin-bottom: 8px; /* Space between rows of controls in a single mapping */
      }
      .stream-mapping .flex-row:last-child {
        margin-bottom: 0;
      }
      .stream-mapping input[type="text"],
      .stream-mapping select {
        margin-bottom: 0; /* Remove bottom margin for inputs inside mapping, handled by flex gap/row margin */
        font-size: 0.9em; /* Slightly smaller for compact layout */
        padding: 8px;
      }
      .stream-mapping .remove-mapping-btn {
        padding: 6px 8px; /* Smaller padding for remove button */
        background-color: #c82333 !important; /* Danger red */
        font-size: 0.9em;
        margin-left: auto; /* Push to the right */
      }
      .stream-mapping .remove-mapping-btn:hover {
        background-color: #a01c28 !important;
      }
      .stream-mapping small {
        /* Adjust small text in mappings */
        font-size: 0.8em;
        margin-top: 5px;
      }
      .mapping-stream-id {
        flex-basis: 100px;
        flex-grow: 1;
        min-width: 80px;
      }
      .mapping-label {
        flex-basis: 140px;
        flex-grow: 2;
        min-width: 100px;
      }
      .mapping-match-type {
        flex-basis: 100px;
        flex-grow: 1;
        min-width: 90px;
      }
      .mapping-scene-name {
        flex-basis: 150px;
        flex-grow: 2;
        min-width: 120px;
      }
      .remove-mapping-btn {
        flex-shrink: 0;
      } /* Prevent remove button from shrinking */
      #addStreamMappingBtn {
        /* Make it stand out a bit */
        background-color: #0069d9; /* Bootstrap primary blue */
        border-color: #0062cc;
      }
      #addStreamMappingBtn:hover {
        background-color: #005cbf;
        border-color: #0056b3;
      }
      /* Ensure consistent spacing for checkbox labels within stream mappings */
      .stream-mapping .checkbox-label {
        font-size: 0.9em; /* Smaller to fit */
        margin-bottom: 0; /* Remove bottom margin as it's in a flex row */
      }
      /* Target OBS Target Settings dropdowns for specific width */
      #obsSceneSelect,
      #screenShareSceneSelect,
      #highlightSceneSelect {
        /* width handled by inline style, but can be adjusted if needed */
      }
      /* Make width of select and button in "Target Scene" line up nicely */
      #obsTargetSettingsFlexContainer > div:first-child {
        /* Assuming you wrap obsSceneSelect and loadScenesBtn in this */
        flex-grow: 1;
      }
      #obsTargetSettingsFlexContainer > button {
        flex-shrink: 0;
      }
      .settings-group {
        margin-top: 15px;
        border-top: 1px solid #3e4147;
        padding-top: 15px;
      }
      .settings-group:first-child {
        margin-top: 0;
        border-top: none;
        padding-top: 0;
      }
    </style>
  </head>
  <body>
    <h1 data-i18n="mainHeading">VDO.Ninja OBS Control</h1>

    <div class="container"> <div class="language-switcher">
            <label for="languageSelector" data-i18n="languageSwitcher.label">Language:</label>
            <select id="languageSelector">
                <option value="en">English</option>
                <option value="pt">Português</option>
            </select>
        </div>
    </div>

    <div class="container"> <h2 class="collapsible" data-state="expand" data-i18n="obsConnection.title">OBS WebSocket Connection</h2>
      <div class="collapsible-content">
        <label for="obsWsUrl" data-i18n="obsConnection.websocketUrlLabel">WebSocket URL:</label>
        <input type="text" id="obsWsUrl" value="ws://localhost:4455" />
        <label for="obsWsPassword" data-i18n="obsConnection.passwordLabel">Password:</label>
        <input type="password" id="obsWsPassword" value="" />
        <div class="prefix-group">
          <label
            for="cameraPrefix"
            id="cameraSubPrefixLabelText"
            class="prefix-input-label"
            data-i18n="obsConnection.cameraPrefixLabel"
            >General Camera prefix:</label
          >
          <input type="text" id="cameraPrefix" value="VDO" />
        </div>
        <div class="prefix-group">
          <label
            for="reactionSubPrefix"
            id="reactionSubPrefixLabelText"
            class="prefix-input-label"
            data-i18n="obsConnection.reactionPrefixLabel"
            >Reaction prefix: VDO.</label
          >
          <input type="text" id="reactionSubPrefix" value="Screen" />
        </div>
        <div class="prefix-group">
          <label
            for="highlightSubPrefix"
            id="highlightSubPrefixLabelText"
            class="prefix-input-label"
            data-i18n="obsConnection.highlightPrefixLabel"
            >Highlight prefix: VDO.</label
          >
          <input type="text" id="highlightSubPrefix" value="Highlight" />
        </div>
        <div class="status-line">
          <button id="obsConnectBtn" data-i18n="obsConnection.connectButton">Connect</button>
          <span id="obsConnectionStatus" data-i18n="obsConnection.statusDisconnected">Status: Disconnected</span>
          <span id="obsStatusIndicator" class="status-indicator"></span>
        </div>
      </div>
    </div>

    <div class="container"> <h2 class="collapsible" data-state="expand" data-i18n="vdoNinjaSettings.title">VDO.Ninja Settings</h2>
      <div class="collapsible-content">
        <label for="vdoNinjaBaseUrl" data-i18n="vdoNinjaSettings.baseUrlLabel">VDO.Ninja Base URL:</label>
        <input
          type="text"
          id="vdoNinjaBaseUrl"
          data-i18n="[placeholder]vdoNinjaSettings.baseUrlPlaceholder"
          placeholder="https://vdo.ninja"
          value="https://vdo.ninja"
        />
        <label for="vdoNinjaRoom" data-i18n="vdoNinjaSettings.roomNameLabel">Room Name:</label>
        <input
          type="text"
          id="vdoNinjaRoom"
          data-i18n="[placeholder]vdoNinjaSettings.roomNamePlaceholder"
          placeholder="e.g., MyNinjaRoom"
          class="blur-field"
        />
        <label for="vdoNinjaPassword" data-i18n="vdoNinjaSettings.passwordLabel">Password:</label>
        <input
          type="password"
          id="vdoNinjaPassword"
          data-i18n="[placeholder]vdoNinjaSettings.passwordPlaceholder"
          placeholder="Room or &password"
        />
        <label for="vdoNinjaStreamIds" data-i18n="vdoNinjaSettings.streamIdsLabel">Stream IDs:</label>
        <input
          type="text"
          id="vdoNinjaStreamIds"
          data-i18n="[placeholder]vdoNinjaSettings.streamIdsPlaceholder"
          placeholder="streamId1,streamId2"
          class="blur-field"
        />
        <small data-i18n="vdoNinjaSettings.roomOrStreamIdsNeeded">Room Name or Stream ID(s) needed</small>
        </div>
    </div>

    <div class="container"> <h2 class="collapsible" data-state="collapse" data-i18n="streamIdMappings.title">Stream ID Mappings</h2>
      <div class="collapsible-content collapsed">
        <div id="streamMappingContainer">
          <div id="streamMappings"></div>
          <button id="addStreamMappingBtn" style="margin-top: 10px" data-i18n="streamIdMappings.addNewMappingButton">
            Add New Mapping
          </button>
        </div>
      </div>
    </div>

    <div class="container"> <h2 class="collapsible" data-state="expand" data-i18n="obsTargetSettings.title">OBS Target Settings</h2>
      <div class="collapsible-content">
        <div class="settings-group">
          <label for="obsSceneSelect" data-i18n="obsTargetSettings.targetSceneLabel">Target Scene:</label>
          <div
            class="flex-row"
            style="gap: 10px"
            id="obsTargetSettingsFlexContainer"
          >
            <select id="obsSceneSelect" style="width: 300px; flex-grow: 1">
              <option value="" data-i18n="obsTargetSettings.selectSceneOption">Select a scene...</option>
            </select>
            <button id="loadScenesBtn" data-i18n="obsTargetSettings.refetchScenesButton">Re-Fetch Scenes</button>
          </div>
        </div>
        <div
          id="otherScenesContainer"
          class="settings-group"
          style="display: none"
        >
          <label data-i18n="obsTargetSettings.copySourcesLabel">Copy sources to other scenes (reference):</label>
          <div id="otherScenesList" style="margin-top: 5px"></div>
        </div>
        <input type="text" id="obsSceneNameInput" style="display: none" />
        <div class="settings-group">
          <label style="font-weight: 600; font-size: 1.05em" data-i18n="obsTargetSettings.screenShareSettings.title">Screen Sharing Settings:</label>
          <div
            class="flex-row"
            style="gap: 15px; align-items: flex-start"
          >
            <div>
              <label for="screenShareSceneSelect" style="font-size: 0.95em" data-i18n="obsTargetSettings.screenShareSettings.targetSceneLabel">Target Scene:</label>
              <select id="screenShareSceneSelect" style="width: 300px">
                <option value="" data-i18n="obsTargetSettings.screenShareSettings.sameAsMainOption">Same as main</option>
              </select>
            </div>
            <div class="flex-row" style="gap: 8px">
              <div>
                <label for="screenShareWidth" style="font-size: 0.95em" data-i18n="obsTargetSettings.screenShareSettings.widthLabel">Width:</label>
                <input
                  type="number"
                  id="screenShareWidth"
                  value="1920"
                  style="width: 100px"
                />
              </div>
              <div>
                <label for="screenShareHeight" style="font-size: 0.95em" data-i18n="obsTargetSettings.screenShareSettings.heightLabel">Height:</label>
                <input
                  type="number"
                  id="screenShareHeight"
                  value="1080"
                  style="width: 100px"
                />
              </div>
            </div>
          </div>
        </div>
        <div class="settings-group">
          <label for="highlightSceneSelect" style="font-weight: 600; font-size: 1.05em" data-i18n="obsTargetSettings.highlightScene.title">Highlight Scene:</label>
          <select id="highlightSceneSelect" style="width: 300px">
            <option value="" data-i18n="obsTargetSettings.highlightScene.selectSceneOption">Select a scene for highlights...</option>
          </select>
        </div>
        <div
          id="autoSourceOptions"
          class="settings-group flex-row"
          style="gap: 15px"
        >
          <label class="checkbox-label">
            <input type="checkbox" id="autoAddSources" checked />
            <span data-i18n="obsTargetSettings.autoAddSourcesLabel">Auto-add new streams as sources</span>
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="autoRemoveSources" checked />
            <span data-i18n="obsTargetSettings.autoRemoveSourcesLabel">Auto-remove sources on disconnect</span>
          </label>
        </div>
        <div class="settings-group">
          <div class="flex-row" style="align-items: flex-end; gap: 15px">
            <div>
              <label for="sourceSizing" data-i18n="obsTargetSettings.newSourceSizing.label">New Source Sizing:</label>
              <select id="sourceSizing" style="width: 250px">
                <option value="defaultSize" data-i18n="obsTargetSettings.newSourceSizing.defaultSizeOption">Default (1920x1080 at 0,0)</option>
                <option value="bestFit" data-i18n="obsTargetSettings.newSourceSizing.bestFitOption">Best Fit (Preserve Aspect)</option>
                <option value="stretchToFill" data-i18n="obsTargetSettings.newSourceSizing.stretchToFillOption">Stretch to Fill Screen</option>
                <option value="autoGrid" data-i18n="obsTargetSettings.newSourceSizing.autoGridOption">Auto Grid Layout</option>
              </select>
            </div>
            <div>
              <label for="sourceCodec" data-i18n="obsTargetSettings.codec.label">Codec:</label>
              <div class="flex-row" style="gap: 2px">
                <select id="sourceCodec" style="width: 150px">
                  <option value="" data-i18n="obsTargetSettings.codec.noneOption">none</option>
                  <option value="h264">h264</option>
                  <option value="vp8">vp8</option>
                  <option value="vp9">vp9</option>
                  <option value="av1">av1</option>
                  <option value="h265">h265</option>
                  <option value="webp">webp</option>
                  <option value="hardware">hardware</option>
                </select>
                <a
                  href="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"
                  target="_blank"
                  data-i18n="[title]obsTargetSettings.codec.learnMoreTitle"
                  title="Learn more about codec options"
                  >?</a
                >
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container"> <h2 class="collapsible" data-state="expand" data-i18n="activeStreams.title">Active Streams</h2>
      <div class="collapsible-content">
        <div id="streamList" class="stream-list">
          <div
            class="stream-item"
            style="
              text-align: center;
              background-color: transparent;
              border: none;
              color: #888;
            "
            data-i18n="activeStreams.noActiveStreams"
          >
            No active streams
          </div>
        </div>
      </div>
    </div>

    <iframe
      id="vdoNinjaIframe"
      allow="encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;midi *;geolocation;camera *;microphone *;fullscreen;picture-in-picture;display-capture;accelerometer;autoplay;gyroscope;screen-wake-lock;"
    ></iframe>

    <div class="container"> <h2 class="collapsible" data-state="expand" data-i18n="log.title">Log</h2>
      <div class="collapsible-content">
        <div id="logArea" class="log-area"></div>
      </div>
    </div>

    <script>
      // i18next initialization and language change logic
      const loadPath = 'https://raw.githubusercontent.com/MorseTheCode/OBS-Scripts/refs/heads/main/locales/{{lng}}.json';
      let logEntries = []; // Array to store log entry data
      const languageSelector = document.getElementById('languageSelector'); // Define globally

      function initializeApp() {
        let savedLanguage = localStorage.getItem('vdoNinjaObsControlLanguage') || 'en';
        languageSelector.value = savedLanguage; // Set dropdown to saved/default language

        i18next
          .use(i18nextHttpBackend)
          .init({
            lng: savedLanguage,
            fallbackLng: 'en',
            debug: true,
            backend: {
              loadPath: loadPath
            }
          }, function(err, t) {
            if (err) return console.error('Error initializing i18next:', err);
            loadSettings(); // Load other settings
            updateContent(); // Translate page
            logMessage("VDO.Ninja OBS Control Dock Initialized. Welcome!", "logMessages.appInitialized");
            updateVdoNinjaButtonState(false);
            toggleVdoNinjaInputs(false);
            setupSecureFieldsBlur();
            startVdoNinjaConnectionMonitor();
          });
      }


      function updateContent() {
        // Translate elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n');
          if (key.startsWith('[placeholder]')) {
            element.placeholder = i18next.t(key.substring('[placeholder]'.length));
          } else if (key.startsWith('[title]')) {
            element.title = i18next.t(key.substring('[title]'.length));
          }
           else {
            element.innerHTML = i18next.t(key);
          }
        });

        // Specifically re-translate placeholders and titles for dynamically added mapping inputs
        document.querySelectorAll('.stream-mapping .mapping-stream-id').forEach(input => {
            input.placeholder = i18next.t('streamIdMappings.streamIdPlaceholder');
            input.title = i18next.t('streamIdMappings.streamIdTooltip');
        });
        document.querySelectorAll('.stream-mapping .mapping-label').forEach(input => {
            input.placeholder = i18next.t('streamIdMappings.labelPlaceholder');
            input.title = i18next.t('streamIdMappings.labelTooltip');
        });

        // Call other update functions
        updateObsConnectButtonText();
        updateVdoNinjaButtonState(vdoNinjaConnected);
        updateStreamList();
        updatePrefixLabels();
        setupCollapsibleTooltips();
        updateSceneDropdowns();
        renderLog(); // Re-render the log with the new language
      }

      function setupCollapsibleTooltips() {
          document.querySelectorAll(".collapsible").forEach(header => {
              const isCollapsed = header.classList.contains("collapsed");
              const tooltipKey = isCollapsed ? "collapsible.clickToExpand" : "collapsible.clickToCollapse";
              header.style.setProperty('--before-text', `"${i18next.t(tooltipKey)}"`);
              header.setAttribute('aria-label', i18next.t(tooltipKey));
          });
      }

      languageSelector.addEventListener('change', (event) => {
        const newLang = event.target.value;
        i18next.changeLanguage(newLang, (err, t) => {
          if (err) return console.error('Error changing language:', err);
          localStorage.setItem('vdoNinjaObsControlLanguage', newLang); // Save new language
          updateContent();
          // No need to call saveSettings() here just for language,
          // as other settings are saved on their respective input changes.
        });
      });

      // --- Start of existing script ---
      // DOM elements
      const obsWsUrlInput = document.getElementById("obsWsUrl");
      const obsWsPasswordInput = document.getElementById("obsWsPassword");
      const obsConnectBtn = document.getElementById("obsConnectBtn");
      const obsConnectionStatus = document.getElementById("obsConnectionStatus");
      const obsStatusIndicator = document.getElementById("obsStatusIndicator");

      const cameraPrefixInput = document.getElementById("cameraPrefix");
      const reactionSubPrefixInput =document.getElementById("reactionSubPrefix");
      const highlightSubPrefixInput = document.getElementById("highlightSubPrefix");
      const cameraSubPrefixLabelText = document.getElementById("cameraSubPrefixLabelText");
      const reactionSubPrefixLabelText = document.getElementById("reactionSubPrefixLabelText");
      const highlightSubPrefixLabelText = document.getElementById("highlightSubPrefixLabelText");

      const vdoNinjaBaseUrlInput = document.getElementById("vdoNinjaBaseUrl");
      const vdoNinjaRoomInput = document.getElementById("vdoNinjaRoom");
      const vdoNinjaPasswordInput = document.getElementById("vdoNinjaPassword");
      const vdoNinjaStreamIdsInput = document.getElementById("vdoNinjaStreamIds");
      const vdoNinjaIframe = document.getElementById("vdoNinjaIframe");

      const obsSceneNameInput = document.getElementById("obsSceneNameInput");
      const obsSceneSelect = document.getElementById("obsSceneSelect");
      const sourceSizingSelect = document.getElementById("sourceSizing");
      const sourceCodecSelect = document.getElementById("sourceCodec");
      const autoAddSourcesCheckbox = document.getElementById("autoAddSources");
      const autoRemoveSourcesCheckbox = document.getElementById("autoRemoveSources");

      const streamListContainer = document.getElementById("streamList");

      const logArea = document.getElementById("logArea");
      const loadScenesBtn = document.getElementById("loadScenesBtn");
      const highlightSceneSelect = document.getElementById("highlightSceneSelect");

      // State variables
      let obs = null;
      let obsConnected = false;
      let vdoNinjaConnected = false;
      let activeStreams = {};
      let obsScenes = [];
      let requestCallbacks = {};
      let vdoNinjaLastActivityTime = 0;
      let vdoNinjaConnectionCheckTimer = null;
      let screenShareId = null;
      let highlightedStreamId = null;
      let loadedSelectedOtherScenes = [];

      document.querySelectorAll(".collapsible").forEach((header) => {
        const content = header.nextElementSibling;
        const startsExpanded = header.dataset.state === "expand";

        if (startsExpanded) {
          header.classList.remove("collapsed");
          content.classList.remove("collapsed");
          header.setAttribute("data-state", "collapse");
        } else {
          header.classList.add("collapsed");
          content.classList.add("collapsed");
          header.setAttribute("data-state", "expand");
        }

        header.addEventListener("click", function () {
          const isCollapsed = header.classList.toggle("collapsed");
          content.classList.toggle("collapsed");
          const newState = isCollapsed ? "expand" : "collapse";
          header.setAttribute("data-state", newState);
          setupCollapsibleTooltips();
        });
      });


      const vdoNinjaConnectBtn = document.createElement("button");
      vdoNinjaConnectBtn.id = "vdoNinjaConnectBtn";
      vdoNinjaConnectBtn.style.marginTop = "5px";

      const vdoNinjaStatusIndicator = document.createElement("span");
      vdoNinjaStatusIndicator.id = "vdoNinjaStatusIndicator";
      vdoNinjaStatusIndicator.className = "status-indicator";

      const vdoNinjaConnectionStatus = document.createElement("span");
      vdoNinjaConnectionStatus.id = "vdoNinjaConnectionStatus";
      vdoNinjaConnectionStatus.style.marginLeft = "5px";

      const vdoNinjaSettingsContainer = document.querySelector(
        "div.container:nth-child(4) .collapsible-content" // Adjusted to 3rd container
      );
      const buttonsDiv = document.createElement("div");
      buttonsDiv.style.marginTop = "10px";
      buttonsDiv.className = "status-line";
      buttonsDiv.appendChild(vdoNinjaConnectBtn);
      buttonsDiv.appendChild(vdoNinjaConnectionStatus);
      buttonsDiv.appendChild(vdoNinjaStatusIndicator);
      if (vdoNinjaSettingsContainer) {
        vdoNinjaSettingsContainer.appendChild(buttonsDiv);
      } else {
        console.error("VDO.Ninja settings container not found for injecting connect button.");
      }


      vdoNinjaConnectBtn.addEventListener("click", () => {
        if (vdoNinjaConnected) {
          disconnectFromVdoNinja();
        } else {
          connectToVdoNinja();
        }
      });
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function logMessage(fallbackMessage, i18nKey, i18nParams = {}) {
          const timestamp = new Date().toLocaleTimeString();
          logEntries.push({
              timestamp,
              i18nKey,
              i18nParams,
              fallbackMessage
          });
          renderLog();
      }

      function renderLog() {
          if (!logArea || (typeof i18next !== 'undefined' && !i18next.isInitialized)) {
             return;
          }
          let logContent = "";
          logEntries.forEach(entry => {
              let translatedMessage = entry.fallbackMessage;
              if (entry.i18nKey && i18next.exists(entry.i18nKey)) {
                  translatedMessage = i18next.t(entry.i18nKey, entry.i18nParams);
              } else if (entry.i18nKey) {
                //   console.warn(`i18next key not found for log: ${entry.i18nKey}. Falling back to: ${entry.fallbackMessage}`);
              }
              const safeTranslatedMessage = translatedMessage.replace(/</g, "&lt;").replace(/>/g, "&gt;");
              logContent += `[${entry.timestamp}] ${safeTranslatedMessage}\n`;
          });
          logArea.innerHTML = logContent;
          logArea.scrollTop = logArea.scrollHeight;
      }


      function generateRequestId(type) {
        return `${type}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      }

      function getVdoNinjaBaseUrl() {
        const customUrl = vdoNinjaBaseUrlInput.value.trim();
        return customUrl || "https://vdo.ninja";
      }

      function getFullCameraPrefix() {
        return cameraPrefixInput.value.trim();
      }
      function getFullReactionPrefix() {
        return `${cameraPrefixInput.value.trim()}.${reactionSubPrefixInput.value.trim()}`;
      }
      function getFullHighlightPrefix() {
        return `${cameraPrefixInput.value.trim()}.${highlightSubPrefixInput.value.trim()}`;
      }

      function updatePrefixLabels() {
        if (!i18next.isInitialized) return;
        const cameraPrefixVal = getFullCameraPrefix();
        const reactionSubPrefixVal = reactionSubPrefixInput.value.trim();
        const highlightSubPrefixVal = highlightSubPrefixInput.value.trim();

        cameraSubPrefixLabelText.textContent = i18next.t("obsConnection.cameraPrefixLabel");
        reactionSubPrefixLabelText.textContent = i18next.t("obsConnection.reactionPrefixDynamicLabel", {
            prefix: cameraPrefixVal || "",
            separator: (cameraPrefixVal && reactionSubPrefixVal) ? "." : "",
            subPrefix: reactionSubPrefixVal || ""
        });
        highlightSubPrefixLabelText.textContent = i18next.t("obsConnection.highlightPrefixDynamicLabel", {
            prefix: cameraPrefixVal || "VDO",
            separator: (cameraPrefixVal && highlightSubPrefixVal) ? "." : "",
            subPrefix: highlightSubPrefixVal || ""
        });
      }

      cameraPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });
      reactionSubPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });
      highlightSubPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });

      function toggleVdoNinjaInputs(disabled) {
        vdoNinjaBaseUrlInput.disabled = disabled;
        vdoNinjaRoomInput.disabled = disabled;
        vdoNinjaPasswordInput.disabled = disabled;
        vdoNinjaStreamIdsInput.disabled = disabled;
      }

      function updateObsConnectButtonText() {
        if (obsConnectBtn && i18next.isInitialized) {
            obsConnectBtn.textContent = obsConnected ? i18next.t("obsConnection.disconnectButton") : i18next.t("obsConnection.connectButton");
        }
      }


      function updateVdoNinjaButtonState(isVdoConnected) {
        vdoNinjaConnected = isVdoConnected;
        if (!i18next.isInitialized) return;

        if (vdoNinjaConnected) {
          vdoNinjaConnectBtn.textContent = i18next.t("vdoNinjaSettings.disconnectButton");
          vdoNinjaConnectBtn.classList.remove("disconnected");
          vdoNinjaConnectBtn.classList.add("connected");
          vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusConnected");
          vdoNinjaStatusIndicator.classList.add("connected");
          vdoNinjaStatusIndicator.classList.remove("error");
        } else {
          vdoNinjaConnectBtn.textContent = i18next.t("vdoNinjaSettings.connectButton");
          vdoNinjaConnectBtn.classList.remove("connected");
          vdoNinjaConnectBtn.classList.add("disconnected");
          vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusDisconnected");
          vdoNinjaStatusIndicator.classList.remove("connected", "error");
        }
        toggleVdoNinjaInputs(vdoNinjaConnected);
        // saveSettings(); // Save settings is called by individual input changes
      }

      function saveSettings() {
        const otherSceneCheckboxes = document.querySelectorAll(
          ".other-scene-checkbox:checked"
        );
        const selectedOtherScenes = Array.from(otherSceneCheckboxes).map(
          (cb) => cb.value
        );

        const settings = {
          obsWsUrl: obsWsUrlInput.value,
          obsWsPassword: obsWsPasswordInput.value,
          cameraPrefix: cameraPrefixInput.value,
          reactionSubPrefix: reactionSubPrefixInput.value,
          highlightSubPrefix: highlightSubPrefixInput.value,
          vdoNinjaBaseUrl: vdoNinjaBaseUrlInput.value,
          vdoNinjaRoom: vdoNinjaRoomInput.value,
          vdoNinjaPassword: vdoNinjaPasswordInput.value,
          vdoNinjaStreamIds: vdoNinjaStreamIdsInput.value,
          obsSceneName: obsSceneSelect.value,
          selectedOtherScenes: selectedOtherScenes,
          sourceSizing: sourceSizingSelect.value,
          sourceCodec: sourceCodecSelect.value,
          autoAddSources: autoAddSourcesCheckbox.checked,
          autoRemoveSources: autoRemoveSourcesCheckbox.checked,
          screenShareWidth: document.getElementById("screenShareWidth").value,
          screenShareHeight: document.getElementById("screenShareHeight").value,
          screenShareScene:
            document.getElementById("screenShareSceneSelect").value,
          highlightScene: highlightSceneSelect.value,
          language: i18next.language // Save current language
        };
        localStorage.setItem("obsNinjaSettings", JSON.stringify(settings));

        const mappings = getStreamMappings();
        localStorage.setItem("obsNinjaStreamMappings", JSON.stringify(mappings));
      }

      function calculateGridPositions(totalSources, canvasWidth, canvasHeight) {
        const positions = [];
        if (totalSources === 0) return positions;

        let cols = Math.ceil(Math.sqrt(totalSources));
        let rows = Math.ceil(totalSources / cols);

        if (totalSources === 3) {
          cols = 3;
          rows = 1;
        }

        const cellWidth = canvasWidth / cols;
        const cellHeight = canvasHeight / rows;

        const itemsInLastRow = totalSources - (rows - 1) * cols;
        let lastRowHorizontalOffset = 0;
        if (rows > 1 && itemsInLastRow > 0 && itemsInLastRow < cols) {
          lastRowHorizontalOffset = ((cols - itemsInLastRow) * cellWidth) / 2;
        }

        for (let i = 0; i < totalSources; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;

          let x = col * cellWidth;
          if (row === rows - 1) {
            x += lastRowHorizontalOffset;
          }
          const y = row * cellHeight;
          positions.push({ x, y, width: cellWidth, height: cellHeight });
        }
        return positions;
      }

      function disconnectFromVdoNinja() {
        vdoNinjaIframe.src = "about:blank";
        if (vdoNinjaConnectionCheckTimer) {
          clearTimeout(vdoNinjaConnectionCheckTimer);
          vdoNinjaConnectionCheckTimer = null;
        }
        activeStreams = {};
        updateStreamList();
        updateVdoNinjaButtonState(false);
        logMessage("Disconnected from VDO.Ninja.", "logMessages.vdoNinja.disconnected");
      }

      function connectToVdoNinja() {
        if (vdoNinjaConnected) {
          logMessage("Already connected to VDO.Ninja.", "logMessages.vdoNinja.alreadyConnected");
          return;
        }

        const room = vdoNinjaRoomInput.value.trim();
        const streamIds = vdoNinjaStreamIdsInput.value.trim();

        if (!room && !streamIds) {
          logMessage(
            "VDO.Ninja Error: Room Name or Stream ID(s) must be provided.",
            "logMessages.vdoNinja.errorRoomOrStreamIdNeeded"
          );
          return;
        }

        initializeVdoNinjaIframe();
        if (i18next.isInitialized) {
            vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusConnecting");
            vdoNinjaConnectBtn.textContent = i18next.t("vdoNinjaSettings.cancelButton");
        }


        if (vdoNinjaConnectionCheckTimer) {
          clearTimeout(vdoNinjaConnectionCheckTimer);
        }
        vdoNinjaConnectionCheckTimer = setTimeout(() => {
          if (
            !vdoNinjaConnected &&
            Date.now() - vdoNinjaLastActivityTime > 10000
          ) {
            logMessage(
              "VDO.Ninja connection timed out. No activity received from iframe.",
              "logMessages.vdoNinja.connectionTimeout"
            );
            if (i18next.isInitialized) {
                vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusConnectionFailed");
                vdoNinjaConnectBtn.textContent = i18next.t("vdoNinjaSettings.connectButton");
            }
            vdoNinjaStatusIndicator.classList.add("error");
            toggleVdoNinjaInputs(false);
          }
        }, 10000);

        toggleVdoNinjaInputs(true);
        saveSettings();
      }

      function addNewStreamMapping(
        streamId = "",
        label = "",
        sceneName = "",
        matchType = "streamId",
        shouldClone = true,
        shouldSwitch = false
      ) {
        const streamMappingsDiv = document.getElementById("streamMappings");
        const mappingDiv = document.createElement("div");
        mappingDiv.className = "stream-mapping";

        const initialStreamId =
          streamId instanceof PointerEvent ||
          (typeof streamId === "object" && streamId !== null && streamId.target)
            ? ""
            : streamId;

        mappingDiv.innerHTML = `
              <div style="margin-bottom: 5px;">
                  <label style="font-size: 1em; margin-bottom: 6px; display: block; font-weight:500;" data-i18n="streamIdMappings.ruleTitle">Stream Mapping Rule</label>
                  <div class="flex-row" style="align-items: center; margin-bottom: 6px;">
                      <input type="text" value="${initialStreamId}" class="mapping-stream-id">
                      <input type="text" value="${label}" class="mapping-label">
                      <select class="mapping-match-type" data-i18n="[title]streamIdMappings.matchTypeTooltip" title="How to match stream">
                          <option value="streamId" ${matchType === "streamId" ? "selected" : ""} data-i18n="streamIdMappings.matchType.idOnly">ID Only</option>
                          <option value="label" ${matchType === "label" ? "selected" : ""} data-i18n="streamIdMappings.matchType.labelOnly">Label Only</option>
                          <option value="both" ${matchType === "both" ? "selected" : ""} data-i18n="streamIdMappings.matchType.bothRequired">Both Required</option>
                          <option value="either" ${matchType === "either" ? "selected" : ""} data-i18n="streamIdMappings.matchType.eitherMatch">Either Match</option>
                      </select>
                      <select class="mapping-scene-name" data-i18n="[title]streamIdMappings.targetSceneTooltip" title="Target OBS Scene">
                          </select>
                      <button class="remove-mapping-btn" data-i18n="[title]streamIdMappings.removeRuleTooltip" title="Remove this mapping rule">×</button>
                  </div>
                  <div class="flex-row" style="gap: 15px;">
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-clone-to-main" ${shouldClone ? "checked" : ""}>
                          <span data-i18n="streamIdMappings.cloneToMainSceneLabel">Clone to main scene</span>
                      </label>
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-switch-to-scene" ${shouldSwitch ? "checked" : ""}>
                          <span data-i18n="streamIdMappings.switchToSceneOnAddLabel">Switch to scene on add</span>
                      </label>
                  </div>
                  <small style="color: #8a8a9a; font-size: 0.85em; display: block; margin-top: 4px;" data-i18n="streamIdMappings.ruleDescription">
                      Define how incoming streams are routed to OBS scenes.
                  </small>
              </div>
          `;
        if (i18next.isInitialized) {
            mappingDiv.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (key.startsWith('[placeholder]')) {
                    element.placeholder = i18next.t(key.substring('[placeholder]'.length));
                } else if (key.startsWith('[title]')) {
                    element.title = i18next.t(key.substring('[title]'.length));
                } else {
                    element.innerHTML = i18next.t(key);
                }
            });

            const streamIdInputElement = mappingDiv.querySelector('.mapping-stream-id');
            if (streamIdInputElement) {
                streamIdInputElement.placeholder = i18next.t('streamIdMappings.streamIdPlaceholder');
                streamIdInputElement.title = i18next.t('streamIdMappings.streamIdTooltip');
            }

            const labelInputElement = mappingDiv.querySelector('.mapping-label');
            if (labelInputElement) {
                labelInputElement.placeholder = i18next.t('streamIdMappings.labelPlaceholder');
                labelInputElement.title = i18next.t('streamIdMappings.labelTooltip');
            }
        }


        streamMappingsDiv.appendChild(mappingDiv);
        const sceneDropdown = mappingDiv.querySelector(".mapping-scene-name");

        populateSceneDropdown(obsScenes, sceneDropdown);
        if (
          sceneName &&
          obsScenes.some((scene) => scene.sceneName === sceneName)
        ) {
          sceneDropdown.value = sceneName;
        }

        const removeBtn = mappingDiv.querySelector(".remove-mapping-btn");
        removeBtn.addEventListener("click", () => {
          mappingDiv.remove();
          saveSettings();
        });

        const inputs = mappingDiv.querySelectorAll("input, select");
        inputs.forEach((input) => {
          input.addEventListener("change", saveSettings);
        });
      }

      function setupStreamMappingUI() {
        const addStreamMappingBtn = document.getElementById(
          "addStreamMappingBtn"
        );
        addStreamMappingBtn.addEventListener("click", () => {
          addNewStreamMapping();
        });
        loadStreamMappings();
      }

      function loadSettings() {
        const settingsJson = localStorage.getItem("obsNinjaSettings");
        let savedLanguage = 'en'; // Default language

        if (settingsJson) {
          try {
            const settings = JSON.parse(settingsJson);
            obsWsUrlInput.value = settings.obsWsUrl || "ws://localhost:4455";
            obsWsPasswordInput.value = settings.obsWsPassword || "";

            cameraPrefixInput.value = settings.cameraPrefix || "VDO";
            reactionSubPrefixInput.value = settings.reactionSubPrefix || "Screen";
            highlightSubPrefixInput.value =
              settings.highlightSubPrefix || "Highlight";

            vdoNinjaBaseUrlInput.value =
              settings.vdoNinjaBaseUrl || "https://vdo.ninja";
            vdoNinjaRoomInput.value = settings.vdoNinjaRoom || "";
            vdoNinjaPasswordInput.value = settings.vdoNinjaPassword || "";
            vdoNinjaStreamIdsInput.value = settings.vdoNinjaStreamIds || "";

            loadedSelectedOtherScenes = settings.selectedOtherScenes || [];

            sourceSizingSelect.value = settings.sourceSizing || "defaultSize";
            sourceCodecSelect.value = settings.sourceCodec || "";
            autoAddSourcesCheckbox.checked =
              settings.autoAddSources !== false;
            autoRemoveSourcesCheckbox.checked =
              settings.autoRemoveSources !== false;

            const screenShareWidthInput =
              document.getElementById("screenShareWidth");
            const screenShareHeightInput =
              document.getElementById("screenShareHeight");

            if (screenShareWidthInput)
              screenShareWidthInput.value = settings.screenShareWidth || "1920";
            if (screenShareHeightInput)
              screenShareHeightInput.value =
                settings.screenShareHeight || "1080";

            // Load saved language but don't apply it here yet.
            // i18next.init will handle the initial language.
            savedLanguage = settings.language || 'en';
            languageSelector.value = savedLanguage;


            // Log after i18next is initialized
            if (i18next.isInitialized) {
                logMessage("Settings loaded from localStorage.", "logMessages.settingsLoaded");
            } else {
                console.log("Settings loaded from localStorage (i18next not ready for log).");
            }

          } catch (e) {
            if (i18next.isInitialized) {
                logMessage(
                `Error loading settings from localStorage: ${e.message}. Using defaults.`,
                "logMessages.errorLoadingSettings", { message: e.message }
                );
            } else {
                console.error(`Error loading settings from localStorage: ${e.message}. Using defaults.`);
            }

            cameraPrefixInput.value = "VDO";
            reactionSubPrefixInput.value = "Screen";
            highlightSubPrefixInput.value = "Highlight";
            vdoNinjaBaseUrlInput.value = "https://vdo.ninja";
            sourceSizingSelect.value = "defaultSize";
            sourceCodecSelect.value = "";
          }
        } else {
           if (i18next.isInitialized) {
                logMessage("No saved settings found. Using default values.", "logMessages.noSavedSettings");
           } else {
                console.log("No saved settings found. Using default values.");
           }
          cameraPrefixInput.value = "VDO";
          reactionSubPrefixInput.value = "Screen";
          highlightSubPrefixInput.value = "Highlight";
          vdoNinjaBaseUrlInput.value = "https://vdo.ninja";
          sourceSizingSelect.value = "defaultSize";
          sourceCodecSelect.value = "";
        }

        setupStreamMappingUI(); // This also calls loadStreamMappings which might need i18next
        // updatePrefixLabels(); // Will be called by updateContent
        return savedLanguage; // Return for i18next init
      }

      function updateOtherScenesList() {
        const mainSceneName = obsSceneSelect.value;
        const otherScenesListDiv = document.getElementById("otherScenesList");
        const container = document.getElementById("otherScenesContainer");

        otherScenesListDiv.innerHTML = "";

        if (mainSceneName && obsScenes && obsScenes.length > 1) {
          container.style.display = "block";
          obsScenes.forEach((scene) => {
            if (scene.sceneName !== mainSceneName) {
              const checkboxId = `otherScene_${scene.sceneName.replace(
                /\s+/g,
                "_"
              )}`;
              const listItem = document.createElement("div");
              listItem.className = "checkbox-label";
              listItem.style.marginBottom = "8px";

              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.id = checkboxId;
              checkbox.value = scene.sceneName;
              checkbox.className = "other-scene-checkbox";

              if (loadedSelectedOtherScenes.includes(scene.sceneName)) {
                checkbox.checked = true;
              }
              checkbox.addEventListener("change", saveSettings);

              const label = document.createElement("label");
              label.htmlFor = checkboxId;
              label.textContent = scene.sceneName;
              label.style.marginLeft = "0";

              listItem.appendChild(checkbox);
              listItem.appendChild(label);
              otherScenesListDiv.appendChild(listItem);
            }
          });
          if (otherScenesListDiv.childElementCount === 0) {
            container.style.display = "none";
          }
        } else {
          container.style.display = "none";
        }
      }

      function updateStreamList() {
        if (!i18next.isInitialized) return;
        if (Object.keys(activeStreams).length === 0) {
          streamListContainer.innerHTML =
            `<div class="stream-item" style="text-align:center; background-color:transparent; border:none; color:#888;">${i18next.t("activeStreams.noActiveStreams")}</div>`;
          return;
        }
        streamListContainer.innerHTML = "";

        for (const streamId in activeStreams) {
          if (Object.hasOwnProperty.call(activeStreams, streamId)) {
            const stream = activeStreams[streamId];
            const streamDiv = document.createElement("div");
            streamDiv.className = "stream-item";

            const targetInfo = getTargetSceneForStream(streamId, stream.label);
            const targetSceneName = targetInfo.scene;
            const isDefaultScene = targetSceneName === getTargetScene();

            const isHighlighted = highlightedStreamId === streamId;
            const isCurrentlyScreenSharingThisStream = screenShareId === streamId;

            let streamItemHTML = `
                      <div style="font-weight: 600; font-size: 1.05em; color: #E0E0E0;">${
                        stream.label || streamId
                      }</div>
                      <small>${i18next.t("activeStreams.streamIdLabel", {id: streamId})}${
              stream.label ? ` | ${i18next.t("activeStreams.labelLabel", {label: stream.label})}` : ""
            }</small>
                      <small style="display: block; color: #A0A0B0;">
                          → ${i18next.t("activeStreams.targetSceneLabelText", {sceneName: targetSceneName || i18next.t("activeStreams.notSet")})}
                          ${
                            isDefaultScene && targetSceneName
                              ? `(${i18next.t("activeStreams.defaultSceneTag")})`
                              : targetSceneName
                              ? `(${i18next.t("activeStreams.mappedSceneTag")})`
                              : ""
                          }
                      </small>
                      <div style="margin-top: 2px; font-size: 0.9em;">
                        ${
                          stream.sourceCreated
                            ? `<span style="color:#28A745">${i18next.t("activeStreams.addedToObs")}</span>`
                            : `<span style="color:#FFC107">${i18next.t("activeStreams.notInObs")}</span>`
                        }
                      </div>
                      <div style="margin-top: 8px;" class="flex-row">`;

            streamItemHTML += `
                      <button class="add-stream-btn" data-stream-id="${streamId}"
                          style="background-color: ${
                            stream.sourceCreated ? "#F44336" : "#4C80AF"
                          };">
                              ${
                                stream.sourceCreated
                                  ? i18next.t("activeStreams.buttons.removeFromObs")
                                  : i18next.t("activeStreams.buttons.addToObs")
                              }
                      </button>`;

            if (stream.sourceCreated) {
              streamItemHTML += `
                          <button class="highlight-btn" data-stream-id="${streamId}"
                              style="background-color: ${
                                isHighlighted ? "#F44336" : "#4CAF50"
                              };">
                                  ${
                                    isHighlighted
                                      ? i18next.t("activeStreams.buttons.unhighlight")
                                      : i18next.t("activeStreams.buttons.highlight")
                                  }
                          </button>`;
            }

            if (stream.sourceCreated) {
              streamItemHTML += `
                          <button class="screen-share-btn" data-stream-id="${streamId}"
                                  style="background-color: ${
                                    isCurrentlyScreenSharingThisStream
                                      ? "#F44336"
                                      : "#9C27B0"
                                  };">
                              ${
                                isCurrentlyScreenSharingThisStream
                                  ? i18next.t("activeStreams.buttons.stopScreenShare")
                                  : i18next.t("activeStreams.buttons.screenShare")
                              }
                          </button>`;
            }
            streamItemHTML += `</div>`;
            streamDiv.innerHTML = streamItemHTML;
            streamListContainer.appendChild(streamDiv);

            const addRemoveBtn = streamDiv.querySelector(".add-stream-btn");
            if (addRemoveBtn) {
              addRemoveBtn.addEventListener("click", () => {
                if (stream.sourceCreated) {
                  removeStreamFromObs(streamId);
                } else {
                  addStreamToObs(streamId, stream.label, targetInfo);
                }
              });
            }
            const highlightBtn = streamDiv.querySelector(".highlight-btn");
            if (highlightBtn) {
              highlightBtn.addEventListener("click", async () => {
                await handleHighlightClick(streamId, stream.label, targetInfo);
              });
            }
            const screenShareBtn = streamDiv.querySelector(".screen-share-btn");
            if (screenShareBtn) {
              screenShareBtn.addEventListener("click", async () => {
                await handleScreenShareClick(streamId, stream.label);
              });
            }
          }
        }
      }

      async function handleHighlightClick(
        clickedStreamId,
        clickedStreamLabel,
        clickedTargetInfo
      ) {
        if (!obsConnected || !obs) {
          logMessage("Cannot highlight: Not connected to OBS.", "logMessages.obs.cannotHighlightNotConnected");
          return;
        }

        if (screenShareId) {
          logMessage(
            `A screen share is active (${screenShareId}). Stopping it before highlighting.`,
            "logMessages.obs.stoppingScreenShareForHighlight", { id: screenShareId }
          );
          await removeScreenShareFromObs(screenShareId);
        }

        const newHighlightScene = highlightSceneSelect.value;
        await toggleHighlight(
          clickedStreamId,
          clickedStreamLabel,
          clickedTargetInfo
        );

        if (highlightedStreamId && newHighlightScene) {
          try {
            const studio = await sendRequest("GetStudioModeEnabled");
            if (studio.studioModeEnabled) {
              logMessage(
                `Studio Mode Enabled - Triggering scene switch to Highlight Scene: '${newHighlightScene}'.`,
                "logMessages.obs.studioModeSwitchHighlight", { sceneName: newHighlightScene }
              );
              await sendRequest("SetCurrentPreviewScene", {
                sceneName: newHighlightScene,
              });
              await sleep(100);
              await sendRequest("TriggerStudioModeTransition");
            } else {
              logMessage(
                `Triggering scene switch to Highlight Scene: '${newHighlightScene}'.`,
                "logMessages.obs.switchingToHighlightScene", { sceneName: newHighlightScene }
              );
              await sendRequest("SetCurrentProgramScene", {
                sceneName: newHighlightScene,
              });
            }
          } catch (e) {
            logMessage(
              `Error switching to highlight scene '${newHighlightScene}': ${e.message}`,
              "logMessages.obs.errorSwitchingHighlightScene", { sceneName: newHighlightScene, message: e.message }
            );
          }
        }
      }

      async function handleScreenShareClick(streamId, streamLabel) {
        const clickedStreamIdForScreenShare = streamId;
        const currentActiveScreenShareGlobal = screenShareId;

        if (currentActiveScreenShareGlobal === clickedStreamIdForScreenShare) {
          await removeScreenShareFromObs(clickedStreamIdForScreenShare);
        } else {
          if (!obsConnected || !obs) {
            logMessage("Cannot start screen share: Not connected to OBS.", "logMessages.obs.cannotScreenShareNotConnected");
            return;
          }

          if (highlightedStreamId) {
            logMessage(
              `A camera is highlighted (${highlightedStreamId}). Unhighlighting it before starting screen share.`,
              "logMessages.obs.unhighlightingForScreenShare", { id: highlightedStreamId }
            );
            const oldHighlightDetails = activeStreams[highlightedStreamId];
            const oldHighlightLabel = oldHighlightDetails
              ? oldHighlightDetails.label
              : "";
            const oldHighlightTargetInfo = getTargetSceneForStream(
              highlightedStreamId,
              oldHighlightLabel
            );
            await toggleHighlight(
              highlightedStreamId,
              oldHighlightLabel,
              oldHighlightTargetInfo
            );
          }

          const screenShareScene =
            document.getElementById("screenShareSceneSelect").value ||
            getTargetScene();

          await addScreenShareToObs(clickedStreamIdForScreenShare, streamLabel);

          if (screenShareId && screenShareScene) {
            try {
              const studio = await sendRequest("GetStudioModeEnabled");
              if (studio.studioModeEnabled) {
                logMessage(
                  `Studio Mode Enabled - Triggering scene switch to Screen Share Scene: '${screenShareScene}'.`,
                  "logMessages.obs.studioModeSwitchScreenShare", { sceneName: screenShareScene }
                );
                await sendRequest("SetCurrentPreviewScene", {
                  sceneName: screenShareScene,
                });
                await sleep(100);
                await sendRequest("TriggerStudioModeTransition");
              } else {
                logMessage(
                  `Triggering scene switch to Screen Share Scene: '${screenShareScene}'.`,
                  "logMessages.obs.switchingToScreenShareScene", { sceneName: screenShareScene }
                );
                await sendRequest("SetCurrentProgramScene", {
                  sceneName: screenShareScene,
                });
              }
            } catch (e) {
              logMessage(
                `Error switching to screen share scene '${screenShareScene}': ${e.message}`,
                "logMessages.obs.errorSwitchingScreenShareScene", { sceneName: screenShareScene, message: e.message }
              );
            }
          }
        }
      }

      async function addScreenShareToObs(streamId, streamLabel) {
        const previousGlobalScreenShareId = screenShareId;

        if (!obsConnected || !obs) {
          logMessage("Cannot add screen share: Not connected to OBS.", "logMessages.obs.cannotAddScreenShareNotConnected");
          updateStreamList();
          return;
        }

        const room = vdoNinjaRoomInput.value.trim();
        if (!room) {
          logMessage(
            "Cannot add screen share: VDO.Ninja Room name is required for screen sharing URLs.",
            "logMessages.obs.cannotAddScreenShareNoRoom"
          );
          updateStreamList();
          return;
        }

        screenShareId = streamId;

        const width =
          parseInt(document.getElementById("screenShareWidth").value) || 1920;
        const height =
          parseInt(document.getElementById("screenShareHeight").value) || 1080;
        const screenShareSceneSelect = document.getElementById(
          "screenShareSceneSelect"
        );
        let targetSceneName =
          screenShareSceneSelect.value || getTargetScene();

        if (!targetSceneName) {
          logMessage(
            "Cannot add screen share: Target OBS scene is required.",
            "logMessages.obs.cannotAddScreenShareNoTargetScene"
          );
          screenShareId = previousGlobalScreenShareId;
          updateStreamList();
          return;
        }

        const sourceName = `${getFullReactionPrefix()}_${streamId}:s`;
        const baseUrl = getVdoNinjaBaseUrl();
        const selectedCodec = sourceCodecSelect.value;

        let screenShareUrl = `${baseUrl}/?view=${encodeURIComponent(
          streamId
        )}:s&solo&room=${encodeURIComponent(room)}`;
        if (selectedCodec && selectedCodec !== "") {
          screenShareUrl += `&codec=${encodeURIComponent(selectedCodec)}`;
        } else {
          screenShareUrl += `&codec=vp9`;
        }

        if (vdoNinjaPasswordInput.value) {
          screenShareUrl += `&password=${encodeURIComponent(
            vdoNinjaPasswordInput.value
          )}`;
        }
        screenShareUrl += "&cleanoutput&transparent&proaudio";

        const inputSettings = {
          url: screenShareUrl,
          width: width,
          height: height,
          fps: 30,
          reroute_audio: true,
          restart_when_active: false,
          shutdown: false,
        };

        logMessage(
          `Adding/Updating screen share source '${sourceName}' (URL: ${screenShareUrl}) to scene '${targetSceneName}'`,
          "logMessages.obs.addingUpdatingScreenShare", { sourceName, url: screenShareUrl, sceneName: targetSceneName }
        );

        try {
          const sourcesResponse = await sendRequest("GetInputList", {}, { suppressNotFound: true });
          const existingSourceWithSamePrefix = sourcesResponse.inputs.find(
            (input) =>
              input.inputName.startsWith(getFullReactionPrefix() + "_") &&
              input.inputName.endsWith(":s") &&
              input.inputName !== sourceName &&
              input.inputKind === "browser_source"
          );

          if (existingSourceWithSamePrefix) {
            logMessage(
              `Reconfiguring existing screen share source '${existingSourceWithSamePrefix.inputName}' to be '${sourceName}'.`,
              "logMessages.obs.reconfiguringExistingScreenShare", { oldName: existingSourceWithSamePrefix.inputName, newName: sourceName }
            );
            await sendRequest("SetInputSettings", {
              inputName: existingSourceWithSamePrefix.inputName,
              inputSettings: inputSettings,
            });
            if (existingSourceWithSamePrefix.inputName !== sourceName) {
              await sendRequest("SetInputName", {
                inputName: existingSourceWithSamePrefix.inputName,
                newInputName: sourceName,
              });
            }
            logMessage(
              `Reconfigured and renamed existing screen share source to '${sourceName}'.`,
              "logMessages.obs.reconfiguredRenamedScreenShare", { sourceName }
            );
          } else {
            const exactSourceExists = sourcesResponse.inputs.find(
              (input) =>
                input.inputName === sourceName &&
                input.inputKind === "browser_source"
            );
            if (exactSourceExists) {
              logMessage(
                `Screen share source '${sourceName}' already exists. Updating its settings.`,
                "logMessages.obs.screenShareExistsUpdating", { sourceName }
              );
              await sendRequest("SetInputSettings", {
                inputName: sourceName,
                inputSettings: inputSettings,
              });
            } else {
              logMessage(`Creating new screen share source '${sourceName}'.`, "logMessages.obs.creatingNewScreenShare", { sourceName });
              await sendRequest("CreateInput", {
                sceneName: targetSceneName,
                inputName: sourceName,
                inputKind: "browser_source",
                inputSettings,
                sceneItemEnabled: true,
              });
            }
          }

          let sceneItemId;
          try {
            const itemInfo = await sendRequest(
              "GetSceneItemId",
              { sceneName: targetSceneName, sourceName: sourceName },
              { suppressNotFound: true }
            );
            sceneItemId = itemInfo.sceneItemId;
            logMessage(
              `Source '${sourceName}' found in scene '${targetSceneName}', item ID: ${sceneItemId}. Ensuring it's enabled.`,
              "logMessages.obs.sourceFoundInSceneEnabled", { sourceName, sceneName: targetSceneName, itemId: sceneItemId }
            );
            await sendRequest("SetSceneItemEnabled", {
              sceneName: targetSceneName,
              sceneItemId: sceneItemId,
              sceneItemEnabled: true,
            });
          } catch (e) {
            if (
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("600")
            ) {
              logMessage(
                `Source '${sourceName}' not found as an item in scene '${targetSceneName}'. Creating scene item.`,
                "logMessages.obs.sourceNotFoundCreatingItem", { sourceName, sceneName: targetSceneName }
              );
              const createItemResponse = await sendRequest("CreateSceneItem", {
                sceneName: targetSceneName,
                sourceName: sourceName,
              });
              sceneItemId = createItemResponse.sceneItemId;
              logMessage(
                `Created scene item for '${sourceName}' in '${targetSceneName}', item ID: ${sceneItemId}.`,
                "logMessages.obs.createdSceneItem", { sourceName, sceneName: targetSceneName, itemId: sceneItemId }
              );
            } else {
              throw e;
            }
          }

          if (sceneItemId) {
            const transform = calculateTransform(
              "defaultSize",
              width,
              height,
              width,
              height
            );
            await sendRequest("SetSceneItemTransform", {
              sceneName: targetSceneName,
              sceneItemId: sceneItemId,
              sceneItemTransform: transform,
            });
            logMessage(
              `Applied transform to screen share source '${sourceName}' in '${targetSceneName}'.`,
              "logMessages.obs.appliedTransformScreenShare", { sourceName, sceneName: targetSceneName }
            );
          }
          logMessage(
            `Successfully configured screen share for stream ${streamId} (${streamLabel}).`,
            "logMessages.obs.successConfigScreenShare", { streamId, label: streamLabel }
          );
        } catch (error) {
          logMessage(
            `Error adding/updating screen share source '${sourceName}': ${error.message}.`,
            "logMessages.obs.errorAddingUpdatingScreenShare", { sourceName, message: error.message }
          );
          screenShareId = previousGlobalScreenShareId;
        } finally {
          updateStreamList();
        }
      }

      async function toggleHighlight(
        clickedStreamId,
        clickedStreamLabel,
        clickedTargetInfo
      ) {
        if (!obsConnected || !obs) {
          logMessage("Cannot toggle highlight: Not connected to OBS.", "logMessages.obs.cannotToggleHighlightNotConnected");
          return;
        }

        const previouslyGlobalHighlightedStreamId = highlightedStreamId;
        const camPrefix = getFullCameraPrefix();
        const hlPrefix = getFullHighlightPrefix();

        if (
          previouslyGlobalHighlightedStreamId &&
          previouslyGlobalHighlightedStreamId !== clickedStreamId
        ) {
          logMessage(
            `Switching highlight: Unhighlighting previous stream ${previouslyGlobalHighlightedStreamId}.`,
            "logMessages.obs.switchingHighlightUnhighlightPrevious", { id: previouslyGlobalHighlightedStreamId }
          );
          const oldStreamDetails =
            activeStreams[previouslyGlobalHighlightedStreamId];
          const oldStreamLabel = oldStreamDetails ? oldStreamDetails.label : "";
          const oldTargetInfo = getTargetSceneForStream(
            previouslyGlobalHighlightedStreamId,
            oldStreamLabel
          );

          const oldHighlightedSourceName = `${hlPrefix}_${previouslyGlobalHighlightedStreamId}`;
          const oldOriginalSourceName = `${camPrefix}_${previouslyGlobalHighlightedStreamId}`;

          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: oldHighlightedSourceName },
              { suppressNotFound: true }
            );
            await sendRequest("SetInputName", {
              inputName: oldHighlightedSourceName,
              newInputName: oldOriginalSourceName,
            });
            logMessage(
              `Stream ${previouslyGlobalHighlightedStreamId} unhighlighted (renamed from ${oldHighlightedSourceName} to ${oldOriginalSourceName}).`,
              "logMessages.obs.streamUnhighlighted", { id: previouslyGlobalHighlightedStreamId, oldName: oldHighlightedSourceName, newName: oldOriginalSourceName }
            );

            if (sourceSizingSelect.value === "autoGrid") {
              if (oldTargetInfo.scene)
                await rearrangeAllStreamsInScene(oldTargetInfo.scene);
              if (
                oldTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== oldTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error unhighlighting previous stream ${previouslyGlobalHighlightedStreamId} (from ${oldHighlightedSourceName}): ${e.message}`,
                "logMessages.obs.errorUnhighlightingPrevious", { id: previouslyGlobalHighlightedStreamId, sourceName: oldHighlightedSourceName, message: e.message }
              );
            }
          }
        }

        const clickedOriginalSourceName = `${camPrefix}_${clickedStreamId}`;
        const clickedNewHighlightedSourceName = `${hlPrefix}_${clickedStreamId}`;

        if (previouslyGlobalHighlightedStreamId === clickedStreamId) {
          logMessage(`Unhighlighting clicked stream ${clickedStreamId}.`, "logMessages.obs.unhighlightingClicked", { id: clickedStreamId });
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: clickedNewHighlightedSourceName },
              { suppressNotFound: true }
            );
            await sendRequest("SetInputName", {
              inputName: clickedNewHighlightedSourceName,
              newInputName: clickedOriginalSourceName,
            });
            highlightedStreamId = null;
            logMessage(
              `Stream ${clickedStreamId} successfully unhighlighted (renamed to ${clickedOriginalSourceName}).`,
              "logMessages.obs.streamSuccessfullyUnhighlighted", { id: clickedStreamId, newName: clickedOriginalSourceName }
            );

            if (sourceSizingSelect.value === "autoGrid") {
              if (clickedTargetInfo.scene)
                await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
              if (
                clickedTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== clickedTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error unhighlighting ${clickedStreamId} (from ${clickedNewHighlightedSourceName}): ${e.message}`,
                "logMessages.obs.errorUnhighlightingClicked", { id: clickedStreamId, sourceName: clickedNewHighlightedSourceName, message: e.message }
              );
            }
            highlightedStreamId = null;
          }
        } else {
          logMessage(`Highlighting clicked stream ${clickedStreamId}.`, "logMessages.obs.highlightingClicked", { id: clickedStreamId });
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: clickedOriginalSourceName },
              { suppressNotFound: true }
            );
            await sendRequest("SetInputName", {
              inputName: clickedOriginalSourceName,
              newInputName: clickedNewHighlightedSourceName,
            });
            highlightedStreamId = clickedStreamId;
            logMessage(
              `Stream ${clickedStreamId} successfully highlighted (renamed to ${clickedNewHighlightedSourceName}).`,
              "logMessages.obs.streamSuccessfullyHighlighted", { id: clickedStreamId, newName: clickedNewHighlightedSourceName }
            );

            if (sourceSizingSelect.value === "autoGrid") {
              if (clickedTargetInfo.scene)
                await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
              if (
                clickedTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== clickedTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error highlighting ${clickedStreamId} (from ${clickedOriginalSourceName}): ${e.message}`,
                "logMessages.obs.errorHighlightingClicked", { id: clickedStreamId, sourceName: clickedOriginalSourceName, message: e.message }
              );
            } else {
              try {
                await sendRequest(
                  "GetInputSettings",
                  { inputName: clickedNewHighlightedSourceName },
                  { suppressNotFound: true }
                );
                highlightedStreamId = clickedStreamId;
              } catch (e2) {
                if (highlightedStreamId === clickedStreamId)
                  highlightedStreamId = null;
              }
            }
            if (
              highlightedStreamId === clickedStreamId &&
              isNotFoundOrDoesNotExist
            ) {
            } else if (highlightedStreamId === clickedStreamId) {
              highlightedStreamId = null;
            }
          }
        }
        updateStreamList();
        saveSettings();
      }

      obsConnectBtn.addEventListener("click", () => {
        if (obsConnected && obs) {
          logMessage("Disconnecting from OBS WebSocket...", "logMessages.obs.disconnecting");
          if (obs) {
            obs.onclose = null;
            obs.close();
            obs = null;
          }
          onObsDisconnected();
        } else {
          connectToOBS();
        }
      });

      function getTargetSceneForStream(streamId, streamLabel = "") {
        const mappings = getStreamMappings();
        const defaultTargetScene = getTargetScene();

        for (const mapping of mappings) {
          let isMatch = false;
          switch (mapping.matchType) {
            case "streamId":
              isMatch = mapping.streamId && streamId === mapping.streamId;
              break;
            case "label":
              isMatch =
                mapping.label && streamLabel && streamLabel === mapping.label;
              break;
            case "both":
              isMatch =
                mapping.streamId &&
                mapping.label &&
                streamId === mapping.streamId &&
                streamLabel === mapping.label;
              break;
            case "either":
              isMatch =
                (mapping.streamId && streamId === mapping.streamId) ||
                (mapping.label &&
                  streamLabel &&
                  streamLabel === mapping.label);
              break;
          }
          if (isMatch && mapping.sceneName) {
            return { scene: mapping.sceneName, mapping: mapping };
          }
        }
        return { scene: defaultTargetScene, mapping: null };
      }

      function updateSceneDropdowns() {
        if (!i18next.isInitialized) return; // Ensure i18next is ready

        const currentMainSceneValue = obsSceneSelect.value;
        const currentScreenShareSceneValue = document.getElementById(
          "screenShareSceneSelect"
        ).value;
        const currentHighlightSceneValue = highlightSceneSelect.value;
        const mappingSceneSelects =
          document.querySelectorAll(".mapping-scene-name");
        const currentMappingSceneValues = Array.from(mappingSceneSelects).map(
          (select) => select.value
        );

        populateSceneDropdown(obsScenes, obsSceneSelect);
        populateSceneDropdown(obsScenes, document.getElementById("screenShareSceneSelect"));
        populateSceneDropdown(obsScenes, highlightSceneSelect);

        if (
          currentMainSceneValue &&
          obsScenes.some((scene) => scene.sceneName === currentMainSceneValue)
        ) {
          obsSceneSelect.value = currentMainSceneValue;
        }
        if (
          currentScreenShareSceneValue === "" ||
          (currentScreenShareSceneValue &&
            obsScenes.some(
              (scene) => scene.sceneName === currentScreenShareSceneValue
            ))
        ) {
          document.getElementById("screenShareSceneSelect").value =
            currentScreenShareSceneValue;
        }
        if (
          currentHighlightSceneValue &&
          obsScenes.some(
            (scene) => scene.sceneName === currentHighlightSceneValue
          )
        ) {
          highlightSceneSelect.value = currentHighlightSceneValue;
        }

        mappingSceneSelects.forEach((select, index) => {
          populateSceneDropdown(obsScenes, select);
          if (
            currentMappingSceneValues[index] &&
            obsScenes.some(
              (scene) => scene.sceneName === currentMappingSceneValues[index]
            )
          ) {
            select.value = currentMappingSceneValues[index];
          }
        });
        updateOtherScenesList();
      }

      function loadStreamMappings() {
        const mappingsJson = localStorage.getItem("obsNinjaStreamMappings");
        if (mappingsJson) {
          try {
            const mappings = JSON.parse(mappingsJson);
            mappings.forEach((mapping) => {
              addNewStreamMapping(
                mapping.streamId,
                mapping.label,
                mapping.sceneName,
                mapping.matchType,
                mapping.cloneToMain !== undefined ? mapping.cloneToMain : true,
                mapping.switchToScene !== undefined
                  ? mapping.switchToScene
                  : false
              );
            });
            if (obsScenes && obsScenes.length > 0) {
              updateSceneDropdowns();
            }
            if (i18next.isInitialized) {
                logMessage(`Loaded ${mappings.length} stream mappings.`, "logMessages.loadedStreamMappings", { count: mappings.length });
            } else {
                console.log(`Loaded ${mappings.length} stream mappings (i18next not ready for log).`);
            }
          } catch (e) {
             if (i18next.isInitialized) {
                logMessage(
                `Error loading stream mappings from localStorage: ${e.message}`,
                "logMessages.errorLoadingStreamMappings", { message: e.message }
                );
            } else {
                console.error(`Error loading stream mappings from localStorage: ${e.message}`);
            }
          }
        }
      }
      function getStreamMappings() {
        const mappings = [];
        document.querySelectorAll(".stream-mapping").forEach((div) => {
          const streamIdInput = div.querySelector(".mapping-stream-id");
          const labelInput = div.querySelector(".mapping-label");
          const matchTypeSelect = div.querySelector(".mapping-match-type");
          const sceneNameSelect = div.querySelector(".mapping-scene-name");
          const cloneToMainCheckbox = div.querySelector(
            ".mapping-clone-to-main"
          );
          const switchToSceneCheckbox = div.querySelector(
            ".mapping-switch-to-scene"
          );

          if (
            streamIdInput &&
            labelInput &&
            matchTypeSelect &&
            sceneNameSelect &&
            cloneToMainCheckbox &&
            switchToSceneCheckbox
          ) {
            const streamId = streamIdInput.value.trim();
            const label = labelInput.value.trim();
            const matchType = matchTypeSelect.value;
            const sceneName = sceneNameSelect.value.trim();
            const cloneToMain = cloneToMainCheckbox.checked;
            const switchToScene = switchToSceneCheckbox.checked;

            if (sceneName && (streamId || label)) {
              mappings.push({
                streamId,
                label,
                matchType,
                sceneName,
                cloneToMain,
                switchToScene,
              });
            }
          } else {
            logMessage(
              "Warning: Could not find all expected elements in a stream mapping UI div.",
              "logMessages.warningStreamMappingElementsNotFound"
            );
          }
        });
        return mappings;
      }

      async function connectToOBS() {
        if (
          cameraPrefixInput.value.trim() === "" ||
          reactionSubPrefixInput.value.trim() === "" ||
          highlightSubPrefixInput.value.trim() === ""
        ) {
          logMessage(
            "Error: Camera, Reaction, and Highlight prefixes are required for OBS connection.",
            "logMessages.obs.errorPrefixesRequired"
          );
          obsStatusIndicator.classList.add("error");
          if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusErrorPrefixesMissing");
          return;
        }

        let url = obsWsUrlInput.value.trim();
        const password = obsWsPasswordInput.value;

        if (!url) {
          logMessage("Error: OBS WebSocket URL is required.", "logMessages.obs.errorUrlRequired");
          obsStatusIndicator.classList.add("error");
          if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusErrorUrlMissing");
          return;
        }
        if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
          url = "ws://" + url;
          obsWsUrlInput.value = url;
        }
        if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusConnecting");
        obsStatusIndicator.classList.remove("connected", "error");
        logMessage(`Attempting to connect to OBS WebSocket at ${url}...`, "logMessages.obs.attemptingConnection", { url });

        const connectionTimeoutId = setTimeout(() => {
          if (
            obs &&
            obs.readyState !== WebSocket.OPEN &&
            obs.readyState !== WebSocket.CONNECTING
          ) {
            logMessage("OBS WebSocket connection attempt timed out.", "logMessages.obs.connectionTimeout");
            if (obs) {
              try {
                obs.close();
              } catch (e) {}
              obs = null;
            }
            if (i18next.isInitialized) {
                obsConnectionStatus.textContent = i18next.t("obsConnection.statusErrorTimeout");
                obsConnectBtn.textContent = i18next.t("obsConnection.connectButton");
            }
            obsStatusIndicator.classList.add("error");
            obsConnectBtn.classList.remove("connected");
            obsConnectBtn.classList.add("disconnected");
          }
        }, 10000);

        try {
          obs = new WebSocket(url);

          obs.onopen = () => {
            logMessage(
              "OBS WebSocket connection opened. Waiting for Server Hello...",
              "logMessages.obs.connectionOpenedWaitingHello"
            );
          };

          obs.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);

              if (message.op === 0) {
                logMessage("Received Hello from OBS. Sending Identify...", "logMessages.obs.receivedHelloSendingIdentify");
                const identifyPayload = {
                  op: 1,
                  d: {
                    rpcVersion: 1,
                    eventSubscriptions:
                      (1 << 0) |
                      (1 << 1) |
                      (1 << 2) |
                      (1 << 3) |
                      (1 << 6) |
                      (1 << 7) |
                      (1 << 8) |
                      (1 << 9),
                  },
                };
                if (message.d && message.d.authentication) {
                  const { challenge, salt } = message.d.authentication;
                  if (password) {
                    identifyPayload.d.authentication =
                      await generateAuthResponse(password, salt, challenge);
                    logMessage(
                      "Authentication data prepared for Identify message.",
                      "logMessages.obs.authDataPrepared"
                    );
                  } else {
                    logMessage(
                      "Warning: OBS server requires authentication, but no password provided.",
                      "logMessages.obs.warningAuthRequiredNoPassword"
                    );
                  }
                }
                obs.send(JSON.stringify(identifyPayload));
              } else if (message.op === 2) {
                clearTimeout(connectionTimeoutId);
                logMessage(
                  "OBS WebSocket Authentication successful! Connection established.",
                  "logMessages.obs.authSuccessConnected"
                );
                obsConnected = true;
                updateObsConnectButtonText();
                obsConnectBtn.classList.add("connected");
                obsConnectBtn.classList.remove("disconnected");
                if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusConnected");
                obsStatusIndicator.classList.add("connected");
                obsStatusIndicator.classList.remove("error");
                onObsConnected();
              } else if (message.op === 7) {
                const entry =
                  message.d && message.d.requestId
                    ? requestCallbacks[message.d.requestId]
                    : null;

                if (entry) {
                  const responseData = message.d;
                  const requestStatus = responseData.requestStatus;
                  const requestType =
                    responseData.requestType || entry.requestType;

                  if (requestStatus && requestStatus.code === 100) {
                    entry.resolve(responseData.responseData || {});
                  } else {
                    const errorMessage = requestStatus
                      ? requestStatus.comment
                      : "Unknown error";
                    const errorCode = requestStatus ? requestStatus.code : "N/A";

                    const suppressLog =
                      entry.suppressNotFound && errorCode === 600;

                    if (!suppressLog) {
                      logMessage(
                        `OBS Request Error (Type: ${requestType}, ID: ${responseData.requestId}): ${errorMessage} (Code: ${errorCode})`,
                        "logMessages.obs.requestError", { type: requestType, id: responseData.requestId, error: errorMessage, code: errorCode }
                      );
                    }
                    entry.reject(
                      new Error(
                        `Request ${requestType} failed: ${errorMessage} (Code: ${errorCode})`
                      )
                    );
                  }
                  delete requestCallbacks[responseData.requestId];
                }
              } else if (message.op === 5) {
                if (message.d && message.d.eventType === "SceneListChanged") {
                  logMessage(
                    "OBS Event: Scene list changed. Re-fetching scenes.",
                    "logMessages.obs.eventSceneListChanged"
                  );
                  fetchObsScenes();
                }
              }
            } catch (error) {
              logMessage(
                `Error processing OBS WebSocket message: ${error.message}. Data: ${event.data}`,
                "logMessages.obs.errorProcessingMessage", { message: error.message, data: event.data }
              );
            }
          };

          obs.onerror = (errorEvent) => {
            clearTimeout(connectionTimeoutId);
            let errorMsg = "Unknown WebSocket error";
            if (errorEvent && errorEvent.message) {
              errorMsg = errorEvent.message;
            } else if (typeof errorEvent === "string") {
              errorMsg = errorEvent;
            }
            logMessage(`OBS WebSocket Error: ${errorMsg}`, "logMessages.obs.webSocketError", { error: errorMsg });
            obsStatusIndicator.classList.add("error");
            if (i18next.isInitialized) {
                obsConnectionStatus.textContent = i18next.t("obsConnection.statusError");
                obsConnectBtn.textContent = i18next.t("obsConnection.connectButton");
            }
            obsConnectBtn.classList.remove("connected");
            obsConnectBtn.classList.add("disconnected");
            obsConnected = false;
          };

          obs.onclose = (event) => {
            clearTimeout(connectionTimeoutId);
            let reason = "";
            if (i18next.isInitialized) {
                if (event.code === 4009) {
                reason =
                    i18next.t("logMessages.obs.authFailedReason");
                } else if (event.reason) {
                reason = event.reason;
                } else {
                reason = i18next.t("logMessages.obs.connectionClosedReasonCode", {code: event.code || "Unknown", wasClean: event.wasClean ? "" : i18next.t("logMessages.obs.uncleanDisconnection") });
                }
            } else { // Fallback if i18next not ready
                reason = `Code ${event.code}`;
            }
            logMessage(`OBS WebSocket Connection Closed. Reason: ${reason}`, "logMessages.obs.connectionClosed", { reason });
            onObsDisconnected();
          };
        } catch (error) {
          clearTimeout(connectionTimeoutId);
          logMessage(
            `Error creating OBS WebSocket connection: ${error.message}`,
            "logMessages.obs.errorCreatingConnection", { message: error.message }
          );
          if (i18next.isInitialized) {
            obsConnectionStatus.textContent = i18next.t("obsConnection.statusError");
            obsConnectBtn.textContent = i18next.t("obsConnection.connectButton");
          }
          obsStatusIndicator.classList.add("error");
          obsConnectBtn.classList.remove("connected");
          obsConnectBtn.classList.add("disconnected");
          obsConnected = false;
        }
      }

      async function generateAuthResponse(password, salt, challenge) {
        const encoder = new TextEncoder();
        try {
          const secretString = password + salt;
          const secretData = encoder.encode(secretString);
          let secretHash;

          if (window.crypto && window.crypto.subtle) {
            const hashBuffer = await window.crypto.subtle.digest(
              "SHA-256",
              secretData
            );
            secretHash = new Uint8Array(hashBuffer);
          } else {
            await loadJsShaLibrary();
            const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
            shaObj.update(secretString);
            const hashHex = shaObj.getHash("HEX");
            secretHash = new Uint8Array(
              hashHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
            );
          }

          const secretBase64 = btoa(String.fromCharCode.apply(null, secretHash));
          const authString = secretBase64 + challenge;
          const authData = encoder.encode(authString);
          let authHash;

          if (window.crypto && window.crypto.subtle) {
            const hashBuffer = await window.crypto.subtle.digest(
              "SHA-256",
              authData
            );
            authHash = new Uint8Array(hashBuffer);
          } else {
            const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
            shaObj.update(authString);
            const hashHex = shaObj.getHash("HEX");
            authHash = new Uint8Array(
              hashHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
            );
          }
          return btoa(String.fromCharCode.apply(null, authHash));
        } catch (error) {
          logMessage(`OBS Authentication generation error: ${error.message}`, "logMessages.obs.authGenerationError", { message: error.message });
          throw error;
        }
      }

      function sendRequest(requestType, requestData = {}, options = {}) {
        return new Promise((resolve, reject) => {
          if (!obsConnected || !obs) {
            logMessage(
              `Cannot send request '${requestType}': Not connected to OBS.`,
              "logMessages.obs.cannotSendRequestNotConnected", { requestType }
            );
            reject(new Error("Not connected to OBS"));
            return;
          }
          const requestId = generateRequestId(requestType);

          requestCallbacks[requestId] = {
            resolve,
            reject,
            requestType,
            suppressNotFound: !!options.suppressNotFound,
          };

          const requestPayload = {
            op: 6,
            d: {
              requestType,
              requestId,
              requestData,
            },
          };

          try {
            obs.send(JSON.stringify(requestPayload));
          } catch (error) {
            logMessage(
              `Error sending OBS request '${requestType}': ${error.message}`,
              "logMessages.obs.errorSendingRequest", { requestType, message: error.message }
            );
            if (requestCallbacks[requestId]) {
              const failedEntry = requestCallbacks[requestId];
              delete requestCallbacks[requestId];
              failedEntry.reject(error);
            } else {
              reject(error);
            }
          }

          setTimeout(() => {
            if (requestCallbacks[requestId]) {
              const entry = requestCallbacks[requestId];
              delete requestCallbacks[requestId];
              logMessage(
                `OBS Request '${entry.requestType}' (ID: ${requestId}) timed out.`,
                "logMessages.obs.requestTimeout", { requestType: entry.requestType, id: requestId }
              );
              entry.reject(new Error(`Request timeout for ${entry.requestType}`));
            }
          }, 5000);
        });
      }

      function onObsConnected() {
        logMessage(
          "OBS Connection fully established. Fetching initial data...",
          "logMessages.obs.connectionEstablishedFetchingData"
        );
        fetchObsScenes()
          .then(() => {
            if (sourceSizingSelect.value === "autoGrid" && getTargetScene()) {
              logMessage(
                "Initial rearrange for auto-grid on main target scene after OBS connection.",
                "logMessages.obs.initialRearrangeAutoGrid"
              );
              setTimeout(
                () => rearrangeAllStreamsInScene(getTargetScene()),
                1000
              );
            }
          })
          .catch((error) => {
            logMessage(
              `Error during post-OBS connection setup (fetching scenes): ${error.message}`,
              "logMessages.obs.errorPostConnectionSetup", { message: error.message }
            );
          });
      }

      function onObsDisconnected() {
        logMessage("OBS Connection has been closed or lost.", "logMessages.obs.connectionClosedOrLost");
        obsConnected = false;
        updateObsConnectButtonText();
        obsConnectBtn.classList.remove("connected");
        obsConnectBtn.classList.add("disconnected");
        if (i18next.isInitialized) obsConnectionStatus.textContent = i18next.t("obsConnection.statusDisconnected");
        obsStatusIndicator.classList.remove("connected", "error");

        Object.values(activeStreams).forEach(
          (stream) => (stream.sourceCreated = false)
        );
        updateStreamList();

        obsScenes = [];
        updateSceneDropdowns();
        updateOtherScenesList();
      }

      async function fetchObsScenes() {
        if (!obsConnected || !obs) {
          logMessage("Cannot fetch OBS scenes: Not connected to OBS.", "logMessages.obs.cannotFetchScenesNotConnected");
          return;
        }
        logMessage("Fetching OBS scenes...", "logMessages.obs.fetchingScenes");
        try {
          const response = await sendRequest("GetSceneList");
          const settingsJson = localStorage.getItem("obsNinjaSettings");
          const settings = settingsJson ? JSON.parse(settingsJson) : {};

          if (response && response.scenes) {
            obsScenes = response.scenes;
            logMessage(`Fetched ${obsScenes.length} scenes from OBS.`, "logMessages.obs.fetchedScenesCount", { count: obsScenes.length });

            updateSceneDropdowns();

            if (
              settings.obsSceneName &&
              obsScenes.some((s) => s.sceneName === settings.obsSceneName)
            ) {
              obsSceneSelect.value = settings.obsSceneName;
            } else if (settings.obsSceneName) {
              logMessage(
                `Previously selected main scene "${settings.obsSceneName}" no longer found. Please reselect.`,
                "logMessages.obs.mainSceneNotFound", { sceneName: settings.obsSceneName }
              );
            }

            if (
              settings.screenShareScene === "" ||
              (settings.screenShareScene &&
                obsScenes.some((s) => s.sceneName === settings.screenShareScene))
            ) {
              document.getElementById("screenShareSceneSelect").value =
                settings.screenShareScene;
            } else if (settings.screenShareScene) {
              logMessage(
                `Previously selected screen share scene "${settings.screenShareScene}" no longer found. Defaulting to "Same as main".`,
                "logMessages.obs.screenShareSceneNotFound", { sceneName: settings.screenShareScene }
              );
               document.getElementById("screenShareSceneSelect").value = "";
            }


            if (
              settings.highlightScene &&
              obsScenes.some((s) => s.sceneName === settings.highlightScene)
            ) {
              highlightSceneSelect.value = settings.highlightScene;
            } else if (settings.highlightScene) {
              logMessage(
                `Previously selected highlight scene "${settings.highlightScene}" no longer found. Please reselect.`,
                "logMessages.obs.highlightSceneNotFound", { sceneName: settings.highlightScene }
              );
            }

            updateOtherScenesList();

            const savedMappingsJson =
              localStorage.getItem("obsNinjaStreamMappings");
            if (savedMappingsJson) {
              try {
                const mappings = JSON.parse(savedMappingsJson);
                document
                  .querySelectorAll(".mapping-scene-name")
                  .forEach((select, index) => {
                    if (mappings[index] && mappings[index].sceneName) {
                      if (
                        obsScenes.some(
                          (scene) =>
                            scene.sceneName === mappings[index].sceneName
                        )
                      ) {
                        select.value = mappings[index].sceneName;
                      }
                    }
                  });
              } catch (e) {
                logMessage(
                  `Error applying saved scene selections to stream mappings: ${e.message}`,
                  "logMessages.obs.errorApplyingSavedMappings", { message: e.message }
                );
              }
            }
            obsSceneNameInput.value = obsSceneSelect.value;
          } else {
            logMessage("Failed to fetch OBS scenes or no scenes returned.", "logMessages.obs.failedToFetchScenes");
            obsScenes = [];
            updateSceneDropdowns();
            updateOtherScenesList();
          }
        } catch (error) {
          logMessage(`Error fetching OBS scenes: ${error.message}`, "logMessages.obs.errorFetchingScenes", { message: error.message });
          obsScenes = [];
          updateSceneDropdowns();
          updateOtherScenesList();
        }
      }

      function populateSceneDropdown(
        scenesData,
        selectElement
      ) {
        if (!i18next.isInitialized) return;
        const currentValue = selectElement.value;
        selectElement.innerHTML = '';

        let placeholderKeyToUse;

        if (selectElement.id === "obsSceneSelect") {
          placeholderKeyToUse = "obsTargetSettings.selectSceneOption";
        } else if (selectElement.id === "screenShareSceneSelect") {
          placeholderKeyToUse = "obsTargetSettings.screenShareSettings.sameAsMainOption";
        } else if (selectElement.id === "highlightSceneSelect") {
          placeholderKeyToUse = "obsTargetSettings.highlightScene.selectSceneOption";
        } else if (selectElement.classList.contains("mapping-scene-name")) {
          placeholderKeyToUse = "streamIdMappings.selectSceneOption";
        } else {
          placeholderKeyToUse = "obsTargetSettings.selectSceneOption";
          console.warn("populateSceneDropdown called with an unhandled select element:", selectElement.id || selectElement.className);
        }

        const placeholderOption = document.createElement('option');
        placeholderOption.value = "";
        placeholderOption.textContent = i18next.t(placeholderKeyToUse);
        selectElement.appendChild(placeholderOption);

        if (scenesData && scenesData.length > 0) {
          scenesData.forEach((scene) => {
            const option = document.createElement("option");
            option.value = scene.sceneName;
            option.textContent = scene.sceneName;
            selectElement.appendChild(option);
          });
        }

        if (currentValue && Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
          selectElement.value = currentValue;
        } else {
           selectElement.value = "";
        }
      }


      function getTargetScene() {
        return obsSceneSelect.value || "";
      }

      function getVdoNinjaViewUrl(streamId, includeCommonParams = true) {
        const room = vdoNinjaRoomInput.value.trim();
        const ninjaPassword = vdoNinjaPasswordInput.value;
        const baseUrl = getVdoNinjaBaseUrl();
        const selectedCodec = sourceCodecSelect.value;

        let url = `${baseUrl}/?`;

        if (room) {
          url += `view=${encodeURIComponent(
            streamId
          )}&solo&room=${encodeURIComponent(room)}`;
        } else {
          url += `view=${encodeURIComponent(streamId)}`;
        }

        if (ninjaPassword) {
          url += `&password=${encodeURIComponent(ninjaPassword)}`;
        }
        if (selectedCodec && selectedCodec !== "") {
          url += `&codec=${encodeURIComponent(selectedCodec)}`;
        }
        if (includeCommonParams) {
          url +=
            "&cleanoutput&proaudio&ab=160&transparent&autoplay&noheader&webcursor";
        }
        return url;
      }

      function initializeVdoNinjaIframe() {
        const room = vdoNinjaRoomInput.value.trim();
        const streamIdsInput = vdoNinjaStreamIdsInput.value.trim();

        if (!room && !streamIdsInput) {
          logMessage(
            "VDO.Ninja: Room Name or specific Stream ID(s) must be provided to connect.",
            "logMessages.vdoNinja.roomOrStreamIdNeededForConnect"
          );
          updateVdoNinjaButtonState(false);
          return;
        }

        const baseUrl = getVdoNinjaBaseUrl();
        let vdoNinjaUrl = `${baseUrl}/?`;

        if (room) {
          vdoNinjaUrl += `room=${encodeURIComponent(room)}`;
          if (streamIdsInput) {
            const viewStreamIds = streamIdsInput
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s)
              .join(",");
            if (viewStreamIds)
              vdoNinjaUrl += `&view=${encodeURIComponent(viewStreamIds)}&solo`;
          }
        } else if (streamIdsInput) {
          const viewStreamIds = streamIdsInput
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s)
            .join(",");
          if (viewStreamIds) {
            vdoNinjaUrl += `view=${encodeURIComponent(viewStreamIds)}`;
          } else {
            logMessage(
              "VDO.Ninja: Stream IDs provided but were empty after trimming.",
              "logMessages.vdoNinja.streamIdsEmptyAfterTrim"
            );
            updateVdoNinjaButtonState(false);
            return;
          }
        }

        if (vdoNinjaPasswordInput.value) {
          vdoNinjaUrl += `&password=${encodeURIComponent(
            vdoNinjaPasswordInput.value
          )}`;
        }

        vdoNinjaUrl +=
          "&cleanoutput&dataonly&nocursor&nopush&debug&noaudio&novideo&cors=" +
          encodeURIComponent(window.location.origin);

        logMessage(`Initializing VDO.Ninja iframe with URL: ${vdoNinjaUrl}`, "logMessages.vdoNinja.initializingIframe", { url: vdoNinjaUrl });
        vdoNinjaIframe.src = "about:blank";
        vdoNinjaIframe.setAttribute("crossorigin", "anonymous");

        setTimeout(() => {
          vdoNinjaIframe.src = vdoNinjaUrl;
          vdoNinjaLastActivityTime = Date.now();
        }, 100);
      }

      window.addEventListener(
        "message",
        (event) => {
          const expectedOriginBase = getVdoNinjaBaseUrl();
          let parsedExpectedOrigin;
          try {
            parsedExpectedOrigin = new URL(expectedOriginBase);
          } catch (e) {
            logMessage(
              `Invalid VDO.Ninja base URL in settings: ${expectedOriginBase}`,
              "logMessages.vdoNinja.invalidBaseUrl", { url: expectedOriginBase }
            );
            return;
          }

          if (
            event.origin !== parsedExpectedOrigin.origin ||
            event.source !== vdoNinjaIframe.contentWindow
          ) {
            return;
          }

          const data = event.data;
          vdoNinjaLastActivityTime = Date.now();

          if (!vdoNinjaConnected) {
            vdoNinjaConnected = true;
            updateVdoNinjaButtonState(true);
            if (vdoNinjaConnectionCheckTimer) {
              clearTimeout(vdoNinjaConnectionCheckTimer);
              vdoNinjaConnectionCheckTimer = null;
            }
            logMessage("VDO.Ninja iframe connection established and active.", "logMessages.vdoNinja.iframeConnectedActive");
          }

          if (data && data.streamID) {
            const streamId = data.streamID;
            const label = data.label || i18next.t("vdoNinja.defaultStreamLabel", {id: streamId});


            if (
              (data.action === "view-connection" && data.value === true) ||
              data.action === "guest-connected" ||
              (data.action === "push-connection" && data.value === true)
            ) {
              logMessage(
                `VDO.Ninja stream connected/active: "${label}" (ID: ${streamId})`,
                "logMessages.vdoNinja.streamConnectedActive", { label, id: streamId }
              );
              activeStreams[streamId] = {
                label,
                sourceCreated: false,
                streamId,
                uuid: data.UUID || null,
                connected: true,
              };
              updateStreamList();

              if (autoAddSourcesCheckbox.checked) {
                logMessage(`Auto-adding stream ${streamId} to OBS.`, "logMessages.vdoNinja.autoAddingStream", { id: streamId });
                const targetInfo = getTargetSceneForStream(streamId, label);
                addStreamToObs(streamId, label, targetInfo);
              }
            } else if (
              (data.action === "view-connection" && data.value === false) ||
              (data.action === "push-connection" && data.value === false)
            ) {
              if (activeStreams[streamId]) {
                logMessage(
                  `VDO.Ninja stream disconnected/inactive: "${label}" (ID: ${streamId})`,
                  "logMessages.vdoNinja.streamDisconnectedInactive", { label, id: streamId }
                );
                if (
                  autoRemoveSourcesCheckbox &&
                  autoRemoveSourcesCheckbox.checked
                ) {
                  logMessage(`Auto-removing stream ${streamId} from OBS.`, "logMessages.vdoNinja.autoRemovingStream", { id: streamId });
                  removeStreamFromObs(streamId);
                }
                delete activeStreams[streamId];
                updateStreamList();
              }
            } else if (
              data.action === "view-connection-info" &&
              data.value &&
              data.value.label
            ) {
              if (activeStreams[streamId]) {
                if (activeStreams[streamId].label !== data.value.label) {
                  logMessage(
                    `VDO.Ninja stream label updated for ID ${streamId}: "${data.value.label}" (was "${activeStreams[streamId].label}")`,
                    "logMessages.vdoNinja.streamLabelUpdated", { id: streamId, newLabel: data.value.label, oldLabel: activeStreams[streamId].label }
                  );
                  activeStreams[streamId].label = data.value.label;
                  updateStreamList();
                }
              }
            }
          }
        },
        false
      );

      function startVdoNinjaConnectionMonitor() {
        setInterval(() => {
          if (
            vdoNinjaConnected &&
            Date.now() - vdoNinjaLastActivityTime > 45000
          ) {
            logMessage(
              "VDO.Ninja connection lost (no activity from iframe). Attempting to reset.",
              "logMessages.vdoNinja.connectionLostResetting"
            );
            if (i18next.isInitialized) vdoNinjaConnectionStatus.textContent = i18next.t("vdoNinjaSettings.statusConnectionLost");
            vdoNinjaStatusIndicator.classList.add("error");
            vdoNinjaStatusIndicator.classList.remove("connected");
            disconnectFromVdoNinja();
          }
        }, 30000);
      }

      async function addStreamToObs(
        streamId,
        streamLabel,
        targetInfo = null
      ) {
        if (!obsConnected || !obs) {
          logMessage(
            `Cannot add stream "${streamLabel}" (${streamId}) to OBS: Not connected to OBS.`,
            "logMessages.obs.cannotAddStreamNotConnected", { label: streamLabel, id: streamId }
          );
          return;
        }

        const resolvedTargetInfo =
          targetInfo || getTargetSceneForStream(streamId, streamLabel);
        const targetSceneName = resolvedTargetInfo.scene;
        const mappingRule = resolvedTargetInfo.mapping;

        if (!targetSceneName) {
          logMessage(
            `Cannot add stream "${streamLabel}" (${streamId}): Target OBS scene name is required but not set (no default and no mapping).`,
            "logMessages.obs.cannotAddStreamNoTargetSceneName", { label: streamLabel, id: streamId }
          );
          return;
        }

        const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
        const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
        let effectiveSourceName = baseSourceName;
        let sourceReallyExistsGlobally = false;

        try {
          await sendRequest(
            "GetInputSettings",
            { inputName: highlightedSourceName },
            { suppressNotFound: true }
          );
          logMessage(
            `Highlighted version '${highlightedSourceName}' found for stream ${streamId}. This will be managed.`,
            "logMessages.obs.highlightedVersionFound", { sourceName: highlightedSourceName, id: streamId }
          );
          effectiveSourceName = highlightedSourceName;
          sourceReallyExistsGlobally = true;
          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = true;
          highlightedStreamId = streamId;
        } catch (e) {
          if (
            !(
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"))
            )
          ) {
            logMessage(
              `Error checking for highlighted source '${highlightedSourceName}': ${e.message}. Will check for base source.`,
              "logMessages.obs.errorCheckingHighlightedSource", { sourceName: highlightedSourceName, message: e.message }
            );
          }
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: baseSourceName },
              { suppressNotFound: true }
            );
            logMessage(
              `Base version '${baseSourceName}' found for stream ${streamId}. This will be managed.`,
              "logMessages.obs.baseVersionFound", { sourceName: baseSourceName, id: streamId }
            );
            effectiveSourceName = baseSourceName;
            sourceReallyExistsGlobally = true;
            if (activeStreams[streamId])
              activeStreams[streamId].sourceCreated = true;
          } catch (e2) {
            const isNotFoundE2 =
              e2.message.toLowerCase().includes("not found") ||
              e2.message.toLowerCase().includes("does not exist") ||
              e2.message.toLowerCase().includes("no source") ||
              (e2.message.toLowerCase().includes("code") &&
                e2.message.toLowerCase().includes("600"));
            if (!isNotFoundE2) {
              logMessage(
                `Error checking for base source '${baseSourceName}': ${e2.message}. Will attempt to create.`,
                "logMessages.obs.errorCheckingBaseSource", { sourceName: baseSourceName, message: e2.message }
              );
            }
            effectiveSourceName = baseSourceName;
            sourceReallyExistsGlobally = false;
          }
        }

        const mainDefaultScene = getTargetScene();
        let shouldCloneThisStreamToMain = false;
        if (
          mappingRule &&
          mappingRule.sceneName !== mainDefaultScene &&
          mappingRule.cloneToMain
        ) {
          shouldCloneThisStreamToMain = true;
        }
        let shouldSwitchToThisScene = false;
        if (mappingRule && mappingRule.switchToScene) {
          shouldSwitchToThisScene = true;
        }

        const vdoNinjaStreamUrl = getVdoNinjaViewUrl(streamId);
        let canvasWidth = 1920,
          canvasHeight = 1080;
        try {
          const videoSettings = await sendRequest("GetVideoSettings");
          if (
            videoSettings &&
            videoSettings.baseWidth &&
            videoSettings.baseHeight
          ) {
            canvasWidth = videoSettings.baseWidth;
            canvasHeight = videoSettings.baseHeight;
          }
        } catch (error) {
          logMessage(
            `Error getting OBS canvas size: ${error.message}. Using default ${canvasWidth}x${canvasHeight}.`,
            "logMessages.obs.errorGettingCanvasSize", { message: error.message, width: canvasWidth, height: canvasHeight }
          );
        }

        const inputSettings = {
          url: vdoNinjaStreamUrl,
          width: canvasWidth,
          height: canvasHeight,
          fps: 30,
          reroute_audio: true,
          restart_when_active: false,
          shutdown: false,
        };

        logMessage(
          `Managing source '${effectiveSourceName}' (exists: ${sourceReallyExistsGlobally}) for stream "${streamLabel}" in OBS scene '${targetSceneName}'. URL: ${vdoNinjaStreamUrl}`,
          "logMessages.obs.managingSource", { sourceName: effectiveSourceName, exists: sourceReallyExistsGlobally, label: streamLabel, sceneName: targetSceneName, url: vdoNinjaStreamUrl }
        );
        if (shouldCloneThisStreamToMain)
          logMessage(
            ` - Will also clone to main scene '${mainDefaultScene}'.`,
            "logMessages.obs.willCloneToMainScene", { sceneName: mainDefaultScene }
          );
        if (shouldSwitchToThisScene)
          logMessage(
            ` - Will also switch OBS to scene '${targetSceneName}'.`,
            "logMessages.obs.willSwitchToScene", { sceneName: targetSceneName }
          );

        try {
          let initialSceneItemId = null;
          let clonedSceneItemId = null;

          if (!sourceReallyExistsGlobally) {
            logMessage(
              `Source '${baseSourceName}' does not exist globally. Creating it in scene '${targetSceneName}'.`,
              "logMessages.obs.sourceNotGlobalCreating", { sourceName: baseSourceName, sceneName: targetSceneName }
            );
            await sendRequest("CreateInput", {
              sceneName: targetSceneName,
              inputName: baseSourceName,
              inputKind: "browser_source",
              inputSettings,
              sceneItemEnabled: true,
            });
            effectiveSourceName = baseSourceName;
            logMessage(
              `Source '${effectiveSourceName}' created and added to scene '${targetSceneName}'.`,
              "logMessages.obs.sourceCreatedAddedToScene", { sourceName: effectiveSourceName, sceneName: targetSceneName }
            );
            try {
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: targetSceneName,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              initialSceneItemId = itemInfo.sceneItemId;
            } catch (e) {
            }
          } else {
            logMessage(
              `Source '${effectiveSourceName}' already exists globally. Updating its settings.`,
              "logMessages.obs.sourceGlobalUpdating", { sourceName: effectiveSourceName }
            );
            await sendRequest("SetInputSettings", {
              inputName: effectiveSourceName,
              inputSettings,
            });
            try {
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: targetSceneName,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              initialSceneItemId = itemInfo.sceneItemId;
              logMessage(
                `Source '${effectiveSourceName}' found as item in scene '${targetSceneName}'.`,
                "logMessages.obs.sourceFoundAsItemInScene", { sourceName: effectiveSourceName, sceneName: targetSceneName }
              );
            } catch (e) {
              if (
                e.message.toLowerCase().includes("not found") ||
                (e.message.toLowerCase().includes("code") &&
                  e.message.toLowerCase().includes("600"))
              ) {
                logMessage(
                  `Source '${effectiveSourceName}' exists globally but not in scene '${targetSceneName}'. Adding it.`,
                  "logMessages.obs.sourceGlobalNotInSceneAdding", { sourceName: effectiveSourceName, sceneName: targetSceneName }
                );
                const createItemResponse = await sendRequest(
                  "CreateSceneItem",
                  {
                    sceneName: targetSceneName,
                    sourceName: effectiveSourceName,
                  }
                );
                initialSceneItemId = createItemResponse.sceneItemId;
              } else {
                throw e;
              }
            }
          }

          if (
            shouldCloneThisStreamToMain &&
            mainDefaultScene &&
            mainDefaultScene !== targetSceneName
          ) {
            logMessage(
              `Attempting to clone source '${effectiveSourceName}' to main scene '${mainDefaultScene}'.`,
              "logMessages.obs.attemptingCloneToMain", { sourceName: effectiveSourceName, sceneName: mainDefaultScene }
            );
            try {
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: mainDefaultScene,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              clonedSceneItemId = itemInfo.sceneItemId;
              logMessage(
                `Source '${effectiveSourceName}' already exists as an item in main scene '${mainDefaultScene}'.`,
                "logMessages.obs.sourceExistsInMainScene", { sourceName: effectiveSourceName, sceneName: mainDefaultScene }
              );
            } catch (e) {
              if (
                e.message.toLowerCase().includes("not found") ||
                (e.message.toLowerCase().includes("code") &&
                  e.message.toLowerCase().includes("600"))
              ) {
                logMessage(
                  `Cloning source '${effectiveSourceName}' to main scene '${mainDefaultScene}'.`,
                  "logMessages.obs.cloningToMainScene", { sourceName: effectiveSourceName, sceneName: mainDefaultScene }
                );
                const createCloneResponse = await sendRequest(
                  "CreateSceneItem",
                  {
                    sceneName: mainDefaultScene,
                    sourceName: effectiveSourceName,
                  }
                );
                clonedSceneItemId = createCloneResponse.sceneItemId;
              } else {
                logMessage(
                  `Error checking for '${effectiveSourceName}' in main scene '${mainDefaultScene}' before cloning: ${e.message}`,
                  "logMessages.obs.errorCheckingMainSceneBeforeClone", { sourceName: effectiveSourceName, sceneName: mainDefaultScene, message: e.message }
                );
              }
            }
          }

          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = true;

          if (initialSceneItemId) {
            await applyTransformAndGrid(
              targetSceneName,
              effectiveSourceName,
              canvasWidth,
              canvasHeight,
              initialSceneItemId
            );
          }
          if (clonedSceneItemId) {
            await applyTransformAndGrid(
              mainDefaultScene,
              effectiveSourceName,
              canvasWidth,
              canvasHeight,
              clonedSceneItemId
            );
          }

          const otherSceneCheckboxes = document.querySelectorAll(
            ".other-scene-checkbox:checked"
          );
          for (const checkbox of otherSceneCheckboxes) {
            const otherSceneName = checkbox.value;
            if (
              otherSceneName &&
              otherSceneName !== targetSceneName &&
              (!shouldCloneThisStreamToMain ||
                otherSceneName !== mainDefaultScene)
            ) {
              try {
                let otherSceneItemId = null;
                try {
                  const itemInfo = await sendRequest(
                    "GetSceneItemId",
                    {
                      sceneName: otherSceneName,
                      sourceName: effectiveSourceName,
                    },
                    { suppressNotFound: true }
                  );
                  otherSceneItemId = itemInfo.sceneItemId;
                } catch (e) {
                }

                if (!otherSceneItemId) {
                  logMessage(
                    `Adding source '${effectiveSourceName}' as item to other scene '${otherSceneName}'.`,
                    "logMessages.obs.addingSourceToOtherScene", { sourceName: effectiveSourceName, sceneName: otherSceneName }
                  );
                  const createItemResponse = await sendRequest(
                    "CreateSceneItem",
                    {
                      sceneName: otherSceneName,
                      sourceName: effectiveSourceName,
                    }
                  );
                  otherSceneItemId = createItemResponse.sceneItemId;
                  if (otherSceneItemId) {
                    await applyTransformAndGrid(
                      otherSceneName,
                      effectiveSourceName,
                      canvasWidth,
                      canvasHeight,
                      otherSceneItemId
                    );
                  }
                }
              } catch (e) {
                logMessage(
                  `Error adding/cloning source '${effectiveSourceName}' to other scene '${otherSceneName}': ${e.message}`,
                  "logMessages.obs.errorAddingCloningToOtherScene", { sourceName: effectiveSourceName, sceneName: otherSceneName, message: e.message }
                );
              }
            }
          }

          if (shouldSwitchToThisScene) {
            logMessage(
              `Switching OBS current program scene to '${targetSceneName}'.`,
              "logMessages.obs.switchingProgramScene", { sceneName: targetSceneName }
            );
            const studio = await sendRequest("GetStudioModeEnabled");
            if (studio.studioModeEnabled) {
              await sendRequest("SetCurrentPreviewScene", {
                sceneName: targetSceneName,
              });
              await sleep(100);
              await sendRequest("TriggerStudioModeTransition");
            } else {
              await sendRequest("SetCurrentProgramScene", {
                sceneName: targetSceneName,
              });
            }
          }
          logMessage(
            `Successfully processed stream "${streamLabel}" (${streamId}), effective OBS source: '${effectiveSourceName}'.`,
            "logMessages.obs.successfullyProcessedStream", { label: streamLabel, id: streamId, sourceName: effectiveSourceName }
          );

          const screenShareSourceNameToCheck = `${getFullReactionPrefix()}_${streamId}:s`;
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: screenShareSourceNameToCheck },
              { suppressNotFound: true }
            );
            logMessage(
              `Existing screen share source '${screenShareSourceNameToCheck}' found for stream ${streamId}. Associating it.`,
              "logMessages.obs.existingScreenShareFound", { sourceName: screenShareSourceNameToCheck, id: streamId }
            );
            screenShareId = streamId;
          } catch (e) {
            const isNotFound =
              e.message.toLowerCase().includes("not found") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error checking for existing screen share source '${screenShareSourceNameToCheck}': ${e.message}`,
                "logMessages.obs.errorCheckingExistingScreenShare", { sourceName: screenShareSourceNameToCheck, message: e.message }
              );
            }
          }
        } catch (error) {
          logMessage(
            `Error managing stream '${effectiveSourceName}' ("${streamLabel}") in OBS: ${error.message}`,
            "logMessages.obs.errorManagingStream", { sourceName: effectiveSourceName, label: streamLabel, message: error.message }
          );
          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = false;
        } finally {
          updateStreamList();
        }
      }

      async function applyTransformAndGrid(
        sceneName,
        sourceName,
        canvasWidth,
        canvasHeight,
        sceneItemId = null
      ) {
        if (!sceneName) {
          logMessage(
            `Cannot apply transform for source '${sourceName}': Scene name not provided.`,
            "logMessages.obs.cannotApplyTransformNoScene", { sourceName }
          );
          return;
        }
        let itemIdToTransform = sceneItemId;

        if (!itemIdToTransform) {
          try {
            const itemInfo = await sendRequest(
              "GetSceneItemId",
              { sceneName, sourceName },
              { suppressNotFound: true }
            );
            if (itemInfo && itemInfo.sceneItemId) {
              itemIdToTransform = itemInfo.sceneItemId;
            } else {
              return;
            }
          } catch (error) {
            const isNotFound =
              error.message.toLowerCase().includes("not found") ||
              (error.message.toLowerCase().includes("code") &&
                error.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error fetching scene item ID for transform of '${sourceName}' in '${sceneName}': ${error.message}. Cannot apply transform.`,
                "logMessages.obs.errorFetchingItemIdForTransform", { sourceName, sceneName, message: error.message }
              );
            }
            return;
          }
        }

        if (!itemIdToTransform) {
          return;
        }

        if (sourceSizingSelect.value === "autoGrid") {
          logMessage(
            `Auto-grid enabled for scene '${sceneName}'. Triggering rearrange.`,
            "logMessages.obs.autoGridEnabledRearranging", { sceneName }
          );
          await rearrangeAllStreamsInScene(sceneName);
        } else {
          try {
            const transform = calculateTransform(
              sourceSizingSelect.value,
              canvasWidth,
              canvasHeight,
              canvasWidth,
              canvasHeight
            );
            await sendRequest("SetSceneItemTransform", {
              sceneName,
              sceneItemId: itemIdToTransform,
              sceneItemTransform: transform,
            });
          } catch (error) {
            logMessage(
              `Error applying non-grid transform to '${sourceName}' (Item ID: ${itemIdToTransform}) in '${sceneName}': ${error.message}`,
              "logMessages.obs.errorApplyingNonGridTransform", { sourceName, itemId: itemIdToTransform, sceneName, message: error.message }
            );
          }
        }
      }

      async function rearrangeAllStreamsInScene(sceneName) {
        if (
          !obsConnected ||
          !obs ||
          !sceneName ||
          sourceSizingSelect.value !== "autoGrid"
        ) {
          if (sourceSizingSelect.value !== "autoGrid") return;
          logMessage(
            `Cannot rearrange streams in scene '${sceneName}': OBS not connected, scene name missing, or auto-grid not selected.`,
            "logMessages.obs.cannotRearrangeStreams", { sceneName }
          );
          return;
        }
        logMessage(
          `Rearranging VDO.Ninja streams in scene '${sceneName}' using autoGrid layout.`,
          "logMessages.obs.rearrangingStreamsAutoGrid", { sceneName }
        );

        try {
          let canvasWidth = 1920,
            canvasHeight = 1080;
          try {
            const videoSettings = await sendRequest("GetVideoSettings");
            if (
              videoSettings &&
              videoSettings.baseWidth &&
              videoSettings.baseHeight
            ) {
              canvasWidth = videoSettings.baseWidth;
              canvasHeight = videoSettings.baseHeight;
            }
          } catch (error) {
            logMessage(
              `Canvas size error during rearrange for scene '${sceneName}': ${error.message}. Using default ${canvasWidth}x${canvasHeight}.`,
              "logMessages.obs.canvasSizeErrorRearrange", { sceneName, message: error.message, width: canvasWidth, height: canvasHeight }
            );
          }

          const sceneItemsResponse = await sendRequest("GetSceneItemList", {
            sceneName,
          });
          const camPrefixWithUnderscore = getFullCameraPrefix() + "_";
          const hlPrefixWithUnderscore = getFullHighlightPrefix() + "_";

          const vdoNinjaSourcesInScene = sceneItemsResponse.sceneItems.filter(
            (item) => {
              const isRegularCameraSource = item.sourceName.startsWith(
                camPrefixWithUnderscore
              );
              const isHighlightedCameraSource = item.sourceName.startsWith(
                hlPrefixWithUnderscore
              );

              let streamIdFromSourceName = null;
              if (isRegularCameraSource) {
                streamIdFromSourceName = item.sourceName.substring(
                  camPrefixWithUnderscore.length
                );
              } else if (isHighlightedCameraSource) {
                streamIdFromSourceName = item.sourceName.substring(
                  hlPrefixWithUnderscore.length
                );
              }

              return (
                (isRegularCameraSource || isHighlightedCameraSource) &&
                streamIdFromSourceName &&
                activeStreams[streamIdFromSourceName] &&
                activeStreams[streamIdFromSourceName].connected &&
                activeStreams[streamIdFromSourceName].sourceCreated
              );
            }
          );

          if (vdoNinjaSourcesInScene.length === 0) {
            return;
          }

          const positions = calculateGridPositions(
            vdoNinjaSourcesInScene.length,
            canvasWidth,
            canvasHeight
          );

          for (let i = 0; i < vdoNinjaSourcesInScene.length; i++) {
            const item = vdoNinjaSourcesInScene[i];
            const transform = calculateTransform(
              "autoGrid",
              canvasWidth,
              canvasHeight,
              canvasWidth,
              canvasHeight,
              positions[i]
            );
            await sendRequest("SetSceneItemTransform", {
              sceneName,
              sceneItemId: item.sceneItemId,
              sceneItemTransform: transform,
            });
          }
          logMessage(
            `Successfully rearranged ${vdoNinjaSourcesInScene.length} VDO.Ninja sources in scene '${sceneName}'.`,
            "logMessages.obs.successfullyRearrangedSources", { count: vdoNinjaSourcesInScene.length, sceneName }
          );
        } catch (error) {
          logMessage(
            `Error rearranging streams in scene '${sceneName}': ${error.message}`,
            "logMessages.obs.errorRearrangingStreams", { sceneName, message: error.message }
          );
        }
      }

      function calculateTransform(
        sizingMode,
        sourceWidth,
        sourceHeight,
        canvasWidth,
        canvasHeight,
        gridPosition = null
      ) {
        let transform = {
          alignment: 5,
          boundsType: "OBS_BOUNDS_NONE",
          boundsAlignment: 0,
          boundsWidth: sourceWidth,
          boundsHeight: sourceHeight,
          positionX: (canvasWidth - sourceWidth) / 2,
          positionY: (canvasHeight - sourceHeight) / 2,
          scaleX: 1.0,
          scaleY: 1.0,
          rotation: 0.0,
          cropTop: 0,
          cropBottom: 0,
          cropLeft: 0,
          cropRight: 0,
          sourceWidth: sourceWidth,
          sourceHeight: sourceHeight,
          width: sourceWidth,
          height: sourceHeight,
        };

        switch (sizingMode) {
          case "stretchToFill":
            transform.boundsType = "OBS_BOUNDS_STRETCH";
            transform.boundsWidth = canvasWidth;
            transform.boundsHeight = canvasHeight;
            transform.width = canvasWidth;
            transform.height = canvasHeight;
            transform.positionX = 0;
            transform.positionY = 0;
            break;
          case "bestFit":
            transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
            transform.boundsWidth = canvasWidth;
            transform.boundsHeight = canvasHeight;
            transform.width = canvasWidth;
            transform.height = canvasHeight;
            transform.positionX = 0;
            transform.positionY = 0;
            break;
          case "autoGrid":
            if (gridPosition) {
              transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
              transform.positionX = gridPosition.x;
              transform.positionY = gridPosition.y;
              transform.boundsWidth = gridPosition.width;
              transform.boundsHeight = gridPosition.height;
              transform.width = gridPosition.width;
              transform.height = gridPosition.height;
            } else {
              logMessage(
                "Warning: autoGrid sizing mode called without gridPosition. Falling back to 'bestFit'.",
                "logMessages.obs.warningAutoGridNoPosition"
              );
              transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
              transform.boundsWidth = canvasWidth;
              transform.boundsHeight = canvasHeight;
              transform.width = canvasWidth;
              transform.height = canvasHeight;
              transform.positionX = 0;
              transform.positionY = 0;
            }
            break;
          case "defaultSize":
          default:
            transform.positionX = (canvasWidth - sourceWidth) / 2;
            transform.positionY = (canvasHeight - sourceHeight) / 2;
            if (sourceWidth > canvasWidth) {
              transform.width = canvasWidth;
              transform.positionX = 0;
              transform.boundsType = "OBS_BOUNDS_SCALE_TO_WIDTH";
              transform.boundsWidth = canvasWidth;
            }
            if (sourceHeight > canvasHeight) {
              transform.height = canvasHeight;
              transform.positionY = 0;
              transform.boundsType = "OBS_BOUNDS_SCALE_TO_HEIGHT";
              transform.boundsHeight = canvasHeight;
            }
            if (sourceWidth > canvasWidth && sourceHeight > canvasHeight) {
              transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
              transform.boundsWidth = canvasWidth;
              transform.boundsHeight = canvasHeight;
              transform.width = canvasWidth;
              transform.height = canvasHeight;
              transform.positionX = 0;
              transform.positionY = 0;
            }
            break;
        }
        return transform;
      }

      async function removeStreamFromObs(streamId) {
        if (!obsConnected || !obs) {
          logMessage(
            `Cannot remove stream ${streamId} from OBS: Not connected to OBS.`,
            "logMessages.obs.cannotRemoveStreamNotConnected", { id: streamId }
          );
          return;
        }
        if (
          !activeStreams[streamId] &&
          streamId !== screenShareId &&
          streamId !== highlightedStreamId
        ) {
        }

        const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
        const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
        logMessage(
          `User or auto-triggered removal of stream '${streamId}' from OBS. Base source: '${baseSourceName}', Highlighted: '${highlightedSourceName}'.`,
          "logMessages.obs.triggeredRemoval", { id: streamId, baseName: baseSourceName, highlightName: highlightedSourceName }
        );

        const streamInfo = activeStreams[streamId];
        const currentLabel = streamInfo
          ? streamInfo.label
          : i18next.t("vdoNinja.defaultStreamLabel", {id: streamId});
        const targetInfo = getTargetSceneForStream(streamId, currentLabel);

        if (highlightedStreamId === streamId) {
          logMessage(
            `Stream ${streamId} is currently highlighted. Unhighlighting before removal.`,
            "logMessages.obs.streamHighlightedUnhighlightingBeforeRemove", { id: streamId }
          );
          await toggleHighlight(streamId, currentLabel, targetInfo);
        }

        const scenesToClean = new Set();
        if (targetInfo && targetInfo.scene) {
          scenesToClean.add(targetInfo.scene);
        }
        const globalMainScene = getTargetScene();
        if (globalMainScene) {
          scenesToClean.add(globalMainScene);
        }
        document
          .querySelectorAll(".other-scene-checkbox:checked")
          .forEach((checkbox) => {
            if (checkbox.value) scenesToClean.add(checkbox.value);
          });

        let itemRemovedThisRun = false;

        for (const sceneName of scenesToClean) {
          if (!sceneName) continue;

          if (await tryRemoveFromScene(baseSourceName, sceneName)) {
            itemRemovedThisRun = true;
          }
        }

        if (screenShareId === streamId) {
          logMessage(
            `Stream ${streamId} was actively screen sharing. Initiating screen share removal.`,
            "logMessages.obs.streamScreenSharingRemoving", { id: streamId }
          );
          await removeScreenShareFromObs(streamId);
        }

        if (activeStreams[streamId]) {
          activeStreams[streamId].sourceCreated = false;
        }

        if (itemRemovedThisRun) {
          logMessage(
            `Finished removing source items for stream ${streamId} from specified OBS scenes.`,
            "logMessages.obs.finishedRemovingSourceItems", { id: streamId }
          );
        }

        if (sourceSizingSelect.value === "autoGrid") {
          const uniqueScenesProcessed = new Set(
            Array.from(scenesToClean).filter((s) => s)
          );
          for (const sceneName of uniqueScenesProcessed) {
            logMessage(
              `Auto-grid: Triggering rearrange for scene '${sceneName}' after stream removal.`,
              "logMessages.obs.autoGridRearrangeAfterRemove", { sceneName }
            );
            setTimeout(() => rearrangeAllStreamsInScene(sceneName), 250);
          }
        }

        if (screenShareId !== streamId) {
          updateStreamList();
        }
        saveSettings();
      }

      async function removeScreenShareFromObs(streamIdToRemove) {
        if (!obsConnected || !obs) {
          logMessage("Cannot remove screen share: Not connected to OBS.", "logMessages.obs.cannotRemoveScreenShareNotConnected");
          return;
        }
        if (!streamIdToRemove) {
          if (screenShareId === streamIdToRemove) {
            screenShareId = null;
            updateStreamList();
          }
          return;
        }

        const sourceName = `${getFullReactionPrefix()}_${streamIdToRemove}:s`;
        logMessage(
          `Attempting to fully remove screen share source '${sourceName}' from OBS (all scenes and input).`,
          "logMessages.obs.attemptingRemoveScreenShareSource", { sourceName }
        );

        let itemRemovedFromAnyScene = false;
        try {
          const scenesResponse = await sendRequest("GetSceneList");
          if (scenesResponse && scenesResponse.scenes) {
            for (const scene of scenesResponse.scenes) {
              if (await tryRemoveFromScene(sourceName, scene.sceneName)) {
                itemRemovedFromAnyScene = true;
              }
            }
          }

          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: sourceName },
              { suppressNotFound: true }
            );
            logMessage(`Removing global input '${sourceName}' from OBS.`, "logMessages.obs.removingGlobalInput", { sourceName });
            await sendRequest("RemoveInput", { inputName: sourceName });
            logMessage(`Successfully removed input '${sourceName}'.`, "logMessages.obs.successfullyRemovedInput", { sourceName });
          } catch (e) {
            const isNotFound =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));

            if (!isNotFound) {
              logMessage(
                `Global input removal for '${sourceName}' failed (may be in use or other error): ${e.message}`,
                "logMessages.obs.globalInputRemovalFailed", { sourceName, message: e.message }
              );
            }
          }
        } catch (error) {
          logMessage(
            `Error during screen share removal process for '${sourceName}': ${error.message}`,
            "logMessages.obs.errorScreenShareRemovalProcess", { sourceName, message: error.message }
          );
        } finally {
          if (screenShareId === streamIdToRemove) {
            screenShareId = null;
          }
          updateStreamList();
        }
      }

      async function tryRemoveFromScene(sourceName, sceneName) {
        if (!sceneName) {
          return false;
        }
        try {
          const itemInfo = await sendRequest(
            "GetSceneItemId",
            { sceneName, sourceName },
            { suppressNotFound: true }
          );
          if (itemInfo && itemInfo.sceneItemId) {
            logMessage(
              `Removing source item '${sourceName}' (ID: ${itemInfo.sceneItemId}) from scene '${sceneName}'.`,
              "logMessages.obs.removingSourceItemFromScene", { sourceName, itemId: itemInfo.sceneItemId, sceneName }
            );
            await sendRequest("RemoveSceneItem", {
              sceneName,
              sceneItemId: itemInfo.sceneItemId,
            });
            return true;
          }
          return false;
        } catch (error) {
          const isNotFound =
            error.message.toLowerCase().includes("not found") ||
            error.message.toLowerCase().includes("no scene items were found") ||
            error.message.toLowerCase().includes("could not find") ||
            (error.message.toLowerCase().includes("code") &&
              error.message.toLowerCase().includes("600"));
          if (!isNotFound) {
            logMessage(
              `Error trying to remove source item '${sourceName}' from scene '${sceneName}': ${error.message}`,
              "logMessages.obs.errorTryingRemoveSourceItem", { sourceName, sceneName, message: error.message }
            );
          }
          return false;
        }
      }

      function loadJsShaLibrary() {
        return new Promise((resolve, reject) => {
          if (typeof jsSHA !== "undefined") {
            resolve();
            return;
          }
          const script = document.createElement("script");
          script.src =
            "https://cdnjs.cloudflare.com/ajax/libs/jsSHA/3.3.0/sha256.js";
          script.onload = () => {
            logMessage(
              "jsSHA library loaded successfully (fallback for Web Crypto).",
              "logMessages.jsShaLoaded"
            );
            resolve();
          };
          script.onerror = () => {
            logMessage(
              "Error: Failed to load jsSHA library. OBS authentication might fail if Web Crypto is also unavailable.",
              "logMessages.errorLoadingJsSha"
            );
            reject(new Error("Failed to load jsSHA library"));
          };
          document.head.appendChild(script);
        });
      }

      function setupSecureFieldsBlur() {
        const secureFields = document.querySelectorAll(
          "#vdoNinjaRoom, #vdoNinjaStreamIds"
        );
        secureFields.forEach((field) => {
          field.classList.add("blur-field");
          field.addEventListener("focus", () =>
            field.classList.remove("blur-field")
          );
          field.addEventListener("blur", () => {
            if (field.value === "") field.classList.add("blur-field");
          });
          // Apply blur if field is initially empty
          if (field.value === "") {
            field.classList.add("blur-field");
          }
        });
      }


      const otherScenesContainer = document.getElementById(
        "otherScenesContainer"
      );
      const otherScenesListDiv = document.getElementById("otherScenesList");
      const screenShareSceneSelect = document.getElementById(
        "screenShareSceneSelect"
      );

      obsSceneSelect.addEventListener("change", () => {
        obsSceneNameInput.value = obsSceneSelect.value;
        saveSettings();
        updateOtherScenesList();
        updateStreamList();
        if (sourceSizingSelect.value === "autoGrid" && getTargetScene()) {
          rearrangeAllStreamsInScene(getTargetScene());
        }
      });

      [
        obsWsUrlInput,
        obsWsPasswordInput,
        vdoNinjaBaseUrlInput,
        vdoNinjaRoomInput,
        vdoNinjaPasswordInput,
        vdoNinjaStreamIdsInput,
        autoAddSourcesCheckbox,
        autoRemoveSourcesCheckbox,
        highlightSceneSelect,
        screenShareSceneSelect,
      ].forEach((el) => {
        if (el) el.addEventListener("change", saveSettings);
      });

      sourceSizingSelect.addEventListener("change", () => {
        saveSettings();
        if (sourceSizingSelect.value === "autoGrid") {
          const mainTargetScene = getTargetScene();
          if (mainTargetScene) {
            rearrangeAllStreamsInScene(mainTargetScene);
          }
          document
            .querySelectorAll(".other-scene-checkbox:checked")
            .forEach((checkbox) => {
              if (checkbox.value) rearrangeAllStreamsInScene(checkbox.value);
            });
        } else {
          const scenesToUpdate = new Set();
          if (getTargetScene()) scenesToUpdate.add(getTargetScene());
          document
            .querySelectorAll(".other-scene-checkbox:checked")
            .forEach((cb) => scenesToUpdate.add(cb.value));
          getStreamMappings().forEach((m) => scenesToUpdate.add(m.sceneName));

          scenesToUpdate.forEach((sceneName) => {
            if (sceneName)
              applyStandardTransformToAllManagedStreamsInScene(sceneName);
          });
        }
      });

      async function applyStandardTransformToAllManagedStreamsInScene(
        sceneName
      ) {
        if (!obsConnected || !sceneName || sourceSizingSelect.value === "autoGrid")
          return;
        logMessage(
          `Applying standard transform ('${sourceSizingSelect.value}') to VDO.Ninja sources in scene '${sceneName}'.`,
          "logMessages.obs.applyingStandardTransform", { sizing: sourceSizingSelect.value, sceneName }
        );

        try {
          let canvasWidth = 1920,
            canvasHeight = 1080;
          const videoSettings = await sendRequest("GetVideoSettings");
          if (
            videoSettings &&
            videoSettings.baseWidth &&
            videoSettings.baseHeight
          ) {
            canvasWidth = videoSettings.baseWidth;
            canvasHeight = videoSettings.baseHeight;
          }

          const sceneItemsResponse = await sendRequest("GetSceneItemList", {
            sceneName,
          });
          const camPrefixWithUnderscore = getFullCameraPrefix() + "_";
          const hlPrefixWithUnderscore = getFullHighlightPrefix() + "_";

          for (const item of sceneItemsResponse.sceneItems) {
            const isManagedSource =
              (item.sourceName.startsWith(camPrefixWithUnderscore) ||
                item.sourceName.startsWith(hlPrefixWithUnderscore)) &&
              item.inputKind === "browser_source";

            if (isManagedSource) {
              const streamIdGuess = item.sourceName
                .replace(camPrefixWithUnderscore, "")
                .replace(hlPrefixWithUnderscore, "");
              if (
                activeStreams[streamIdGuess] &&
                activeStreams[streamIdGuess].sourceCreated
              ) {
                const transform = calculateTransform(
                  sourceSizingSelect.value,
                  canvasWidth,
                  canvasHeight,
                  canvasWidth,
                  canvasHeight
                );
                await sendRequest("SetSceneItemTransform", {
                  sceneName,
                  sceneItemId: item.sceneItemId,
                  sceneItemTransform: transform,
                });
              }
            }
          }
        } catch (error) {
          logMessage(
            `Error applying standard transform in scene '${sceneName}': ${error.message}`,
            "logMessages.obs.errorApplyingStandardTransform", { sceneName, message: error.message }
          );
        }
      }

      sourceCodecSelect.addEventListener("change", async () => {
        saveSettings();
        const newCodec = sourceCodecSelect.value;
        logMessage(
          `Codec changed to: ${newCodec || "none"}. Updating OBS sources...`,
          "logMessages.obs.codecChangedUpdatingSources", { codec: newCodec || "none" }
        );

        if (!obsConnected) {
          logMessage(
            "OBS is not connected. Sources will not be updated with the new codec until reconnection and a new action.",
            "logMessages.obs.codecChangedNotConnected"
          );
          return;
        }

        for (const streamId in activeStreams) {
          if (
            Object.hasOwnProperty.call(activeStreams, streamId) &&
            activeStreams[streamId].sourceCreated
          ) {
            let effectiveSourceName = `${getFullCameraPrefix()}_${streamId}`;
            if (highlightedStreamId === streamId) {
              effectiveSourceName = `${getFullHighlightPrefix()}_${streamId}`;
            }

            try {
              const currentSettingsResponse = await sendRequest(
                "GetInputSettings",
                { inputName: effectiveSourceName },
                { suppressNotFound: true }
              );
              if (
                currentSettingsResponse &&
                currentSettingsResponse.inputSettings
              ) {
                const newViewUrl = getVdoNinjaViewUrl(streamId);
                const updatedSettings = {
                  ...currentSettingsResponse.inputSettings,
                  url: newViewUrl,
                };

                await sendRequest("SetInputSettings", {
                  inputName: effectiveSourceName,
                  inputSettings: updatedSettings,
                });
                logMessage(
                  `Source '${effectiveSourceName}' updated with URL: ${newViewUrl}`,
                  "logMessages.obs.sourceUpdatedWithUrl", { sourceName: effectiveSourceName, url: newViewUrl }
                );
              }
            } catch (error) {
              const isNotFound =
                error.message.toLowerCase().includes("not found") ||
                (error.message.toLowerCase().includes("code") &&
                  error.message.toLowerCase().includes("600"));
              if (!isNotFound) {
                logMessage(
                  `Error updating codec for source '${effectiveSourceName}': ${error.message}`,
                  "logMessages.obs.errorUpdatingCodecForSource", { sourceName: effectiveSourceName, message: error.message }
                );
              }
            }
          }
        }

        if (screenShareId) {
          const screenShareSourceName = `${getFullReactionPrefix()}_${screenShareId}:s`;
          try {
            const currentScreenShareSettingsResponse = await sendRequest(
              "GetInputSettings",
              { inputName: screenShareSourceName },
              { suppressNotFound: true }
            );
            if (
              currentScreenShareSettingsResponse &&
              currentScreenShareSettingsResponse.inputSettings
            ) {
              const room = vdoNinjaRoomInput.value.trim();
              const baseUrl = getVdoNinjaBaseUrl();
              let newScreenShareUrl = `${baseUrl}/?view=${encodeURIComponent(
                screenShareId
              )}:s&solo&room=${encodeURIComponent(room)}`;

              if (newCodec && newCodec !== "") {
                newScreenShareUrl += `&codec=${encodeURIComponent(newCodec)}`;
              } else {
                newScreenShareUrl += `&codec=vp9`;
              }
              if (vdoNinjaPasswordInput.value) {
                newScreenShareUrl += `&password=${encodeURIComponent(
                  vdoNinjaPasswordInput.value
                )}`;
              }
              newScreenShareUrl += "&cleanoutput&transparent&proaudio";

              const updatedScreenShareSettings = {
                ...currentScreenShareSettingsResponse.inputSettings,
                url: newScreenShareUrl,
              };

              await sendRequest("SetInputSettings", {
                inputName: screenShareSourceName,
                inputSettings: updatedScreenShareSettings,
              });
              logMessage(
                `Screen share source '${screenShareSourceName}' updated with URL: ${newScreenShareUrl}`,
                "logMessages.obs.screenShareSourceUpdatedWithUrl", { sourceName: screenShareSourceName, url: newScreenShareUrl }
              );
            }
          } catch (error) {
            const isNotFound =
              error.message.toLowerCase().includes("not found") ||
              (error.message.toLowerCase().includes("code") &&
                error.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error updating codec for screen share source '${screenShareSourceName}': ${error.message}`,
                "logMessages.obs.errorUpdatingCodecForScreenShare", { sourceName: screenShareSourceName, message: error.message }
              );
            }
          }
        }
        logMessage("Codec update for OBS sources complete.", "logMessages.obs.codecUpdateComplete");
      });

      loadScenesBtn.addEventListener("click", fetchObsScenes);

      if (screenShareSceneSelect) {
        screenShareSceneSelect.addEventListener("change", saveSettings);
      }
      const screenShareWidthInput =
        document.getElementById("screenShareWidth");
      const screenShareHeightInput =
        document.getElementById("screenShareHeight");
      if (screenShareWidthInput)
        screenShareWidthInput.addEventListener("change", saveSettings);
      if (screenShareHeightInput)
        screenShareHeightInput.addEventListener("change", saveSettings);

      document.addEventListener("DOMContentLoaded", () => {
        initializeApp(); // Call the new initialization function
      });

      function setupSecureFieldsBlur() {
        const secureFields = document.querySelectorAll(
          "#vdoNinjaRoom, #vdoNinjaStreamIds"
        );
        secureFields.forEach((field) => {
          field.classList.add("blur-field");
          field.addEventListener("focus", () =>
            field.classList.remove("blur-field")
          );
          field.addEventListener("blur", () => {
            if (field.value === "") field.classList.add("blur-field");
          });
          if (field.value === "") { // Apply blur if initially empty
            field.classList.add("blur-field");
          }
        });
      }
    </script>
  </body>
</html>
