<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VDO.Ninja OBS Control Dock - Enhanced v4.2</title>
    <style>
      body {
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        background-color: #181a1b;
        color: #e0e0e0;
        font-size: 14px;
        line-height: 1.6;
        display: flex; /* Arrange sidebar and main content horizontally */
        overflow-x: hidden; /* Prevent horizontal scrollbar */
        height: 100vh; /* Ensure body takes full viewport height */
      }

      #toggleSidebarBtn {
        position: fixed;
        left: 10px;
        top: 10px;
        z-index: 1002; /* Higher z-index */
        background-color: #4a5060;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1.2em;
        transition: left 0.3s ease-in-out;
      }
      #toggleSidebarBtn:hover {
        background-color: #5a6070;
      }

      #sidebar {
        width: 460px;
        min-width: 380px;
        height: 100vh;
        background-color: #1c1e22;
        overflow-y: auto;
        padding: 0px;
        padding-top: 60px; /* Make space for the fixed toggle button */
        transition: transform 0.3s ease-in-out, min-width 0.3s ease-in-out, width 0.3s ease-in-out, padding 0.3s ease-in-out;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        position: relative; /* For positioning context if needed */
      }

      #sidebar.collapsed {
        transform: translateX(-100%);
        min-width: 0;
        width: 0;
        padding-left: 0;
        padding-right: 0;
        overflow: hidden;
      }
      
      #sidebar h1 {
        color: #d0d0d0;
        margin: 0 0 20px 0;
        padding-bottom: 15px;
        font-size: 1.6em;
        font-weight: 600;
        border-bottom: 1px solid #3e4147;
      }

      #mainSceneAreaContainer {
        flex-grow: 1;
        height: 90vh;
        max-width: 152vh;
        display: flex;
        flex-direction: column;
        background-color: #101213;
        transition: padding-left 0.3s ease-in-out; /* For smooth transition of padding */
        padding-left: 0px; /* Default padding when sidebar is open */
      }

      body.sidebar-collapsed #mainSceneAreaContainer {
        /* Styling for when sidebar is collapsed */
      }
      
      body.sidebar-collapsed #toggleSidebarBtn {
        /* Styling for toggle button when sidebar is collapsed */
      }


      #obsCanvasInfo {
        padding: 10px 10px;
        background: #22252a;
        font-size: 0.9em;
        color: #ccc;
        border-bottom: 1px solid #3e4147;
        display: flex;
        justify-content: space-between;
        align-items: center;
        min-height: 10px;
        transition: padding-left 0.3s ease-in-out; /* Smooth transition for padding */
      }
      
      body.sidebar-collapsed #obsCanvasInfo {
          padding-left: 50px; /* Add padding to avoid fixed button when sidebar is closed */
      }


      #obsCanvasInfo span {
        font-weight: 500;
        color: #e0e0e0;
      }


      #mainSceneArea {
        flex-grow: 1;
        height: 90vh;
        position: relative;
        overflow: hidden;
        background-color: #202326;
        margin: 10px;
        border-radius: 4px;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
      }

      .scene-item-visual {
        position: absolute;
        border: 1px solid #555;
        box-sizing: border-box;
        background-color: rgba(100, 100, 150, 0.6);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 10px;
        overflow: hidden;
        white-space: normal;
        text-align: center;
        word-break: break-word;
        padding: 3px;
        border-radius: 3px;
        transition: background-color 0.2s, border-color 0.2s, opacity 0.2s, transform 0.1s ease-out; 
        cursor: default; 
      }
      .scene-item-visual .item-name {
          font-weight: bold;
          font-size: 1.1em;
          margin-bottom: 2px;
          width: 100%;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
      }
      .scene-item-visual .item-kind {
          font-size: 0.85em;
          color: #bbb;
          width: 100%;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
      }


      .scene-item-visual.vdo-camera {
        background-color: rgba(76, 175, 80, 0.7); 
        border-color: #4CAF50;
        cursor: context-menu; 
      }
      .scene-item-visual.vdo-camera:hover {
          background-color: rgba(76, 175, 80, 0.9);
          border-color: #66bb6a;
          transform: scale(1.02); 
      }

      .scene-item-visual.vdo-camera.highlighted {
        background-color: rgba(255, 193, 7, 0.8); 
        border: 2px solid #ffc107;
        box-shadow: 0 0 10px rgba(255, 193, 7, 0.7); 
      }
      .scene-item-visual.vdo-camera.highlighted:hover {
         background-color: rgba(255, 193, 7, 1);
         border-color: #ffca28;
      }

      .scene-item-visual.vdo-screenshare { /* Style for screen share sources in visualization */
        background-color: rgba(33, 150, 243, 0.7);
        border: 2px solid #2196F3; /* More prominent border */
        box-shadow: 0 0 8px rgba(33, 150, 243, 0.6);
      }
      .scene-item-visual.not-visible {
        opacity: 0.5;
        border-style: dashed;
      }


      #sceneItemContextMenu {
        position: absolute;
        background-color: #2c2e33;
        border: 1px solid #3e4147;
        border-radius: 4px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 5px 0;
        z-index: 2000; 
        display: none; 
        min-width: 220px; 
      }

      #sceneItemContextMenu ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      #sceneItemContextMenu ul li {
        padding: 10px 18px;
        cursor: pointer;
        color: #e0e0e0;
        font-size: 0.95em;
      }

      #sceneItemContextMenu ul li:hover {
        background-color: #007aff;
        color: white;
      }
       #sceneItemContextMenu ul hr {
          border: none;
          border-top: 1px solid #4a4d54;
          margin: 5px 0;
      }

      /* Styles from obs2.html, adapted for sidebar context */
      .container {
        margin-bottom: 15px;
        padding: 15px;
        background-color: #2c2e33;
        border-radius: 8px;
        border: 1px solid #3e4147;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .collapsible {
        cursor: pointer;
        user-select: none;
        padding: 12px 15px;
        position: relative;
        font-weight: 600;
        font-size: 1.1em;
        background: #35383d;
        margin: -15px -15px 10px -15px; 
        padding-left: 15px;
        border-bottom: 1px solid #3e4147;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        transition: background-color 0.2s ease;
      }
      
      #sidebar .container .collapsible:first-child {
        /* Styling for first collapsible in container */
      }


      .collapsible.collapsed {
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        margin-bottom: 0; 
        border-bottom: none; 
      }
      .container .collapsible:last-child.collapsed { 
        margin-bottom: -15px;
      }


      .collapsible[data-state="expand"]::after { content: "▼"; }
      .collapsible[data-state="collapse"]::after { content: "▲"; }
      .collapsible::after {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 14px;
        color: #a0a0b0;
        transition: transform 0.2s ease;
      }
      


      .collapsible:hover {
        background: #404348;
      }

      .collapsible-content {
        max-height: 1000px; 
        overflow: hidden;
        transition: max-height 0.3s ease-in-out, padding-top 0.3s ease-in-out,
          opacity 0.3s ease-in-out;
        padding-top: 10px; 
        opacity: 1;
      }

      .collapsible-content.collapsed {
        max-height: 0;
        padding-top: 0;
        opacity: 0;
        overflow: hidden;
      }

      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500;
        color: #c0c0c0;
      }

      input[type="text"],
      input[type="password"],
      input[type="number"],
      select {
        width: calc(100% - 22px); 
        padding: 10px;
        margin-bottom: 12px;
        border: 1px solid #4a4d54;
        border-radius: 6px;
        background-color: #25272c;
        color: #e0e0e0;
        font-size: 1em;
        box-sizing: border-box;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      input[type="text"]:focus,
      input[type="password"]:focus,
      input[type="number"]:focus,
      select:focus {
        border-color: #007aff;
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25);
        outline: none;
      }

      select {
        padding-right: 30px;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23A0A0B0'%3E%3Cpath d='M8 11L3 6h10L8 11z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 12px;
      }

      button {
        padding: 10px 15px;
        background-color: #4a5060;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        margin-right: 5px;
        margin-bottom: 5px;
        font-size: 0.95em;
        font-weight: 500;
        transition: background-color 0.2s ease, transform 0.1s ease;
      }

      button:hover { background-color: #5a6070; }
      button:active { transform: translateY(1px); }

      button.connected { background-color: #007aff; }
      button.connected:hover { background-color: #0056b3; }
      button.disconnected { background-color: #6c757d; }
      button.disconnected:hover { background-color: #5a6268; }

      .blur-field { filter: blur(5px); transition: filter 0.2s ease; }
      .blur-field:focus { filter: blur(0); }

      #vdoNinjaIframe {
        width: 1px; height: 1px; position: absolute;
        left: -1000px; top: -1000px; border: 0;
      }

      .log-area {
        height: 120px; background-color: #202225; color: #b0b0b0;
        border: 1px solid #4a4d54; border-radius: 6px; overflow-y: scroll;
        padding: 10px; font-family: "Consolas", "Monaco", "Lucida Console", monospace;
        font-size: 0.9em; margin-top: 10px; white-space: pre-wrap;
      }

      .status-indicator {
        display: inline-block; width: 10px; height: 10px;
        border-radius: 50%; margin-left: 8px; background-color: #555;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }
      .status-indicator.connected { background-color: #007aff; box-shadow: 0 0 8px rgba(0, 122, 255, 0.7); }
      .status-indicator.error { background-color: #dc3545; box-shadow: 0 0 8px rgba(220, 53, 69, 0.7); }

      .stream-list {
        background-color: #202225; border: 1px solid #4a4d54;
        border-radius: 6px; padding: 5px; margin-top: 5px;
        transition: max-height 0.3s ease;
      }
      .stream-list:empty { 
        min-height: 40px; display: flex; align-items: center;
        justify-content: center; color: #888; padding: 10px;
      }


      .stream-item {
        padding: 10px 12px; border-bottom: 1px solid #383b40;
        font-size: 1em; word-break: break-word; background-color: #2c2e33;
        margin: 0 0 8px 0; border-radius: 4px;
      }
      .stream-item:last-child { border-bottom: none; margin-bottom: 0; }

      h2 { 
        color: #c8c8c8;
        margin: 5px 0;
        font-size: 1.1em;
      }

      small {
        color: #9090a0; font-size: 0.88em; display: block;
        margin-top: 3px; line-height: 1.4;
      }

      /* Specific button colors from obs2 */
      .add-stream-btn { background-color: #28a745 !important; }
      .add-stream-btn:hover { background-color: #218838 !important; }
      button.add-stream-btn[style*="rgb(244, 67, 54)"],
      button.add-stream-btn[style*="#F44336"] { background-color: #dc3545 !important; }
      button.add-stream-btn[style*="rgb(244, 67, 54)"]:hover,
      button.add-stream-btn[style*="#F44336"]:hover { background-color: #c82333 !important; }

      .highlight-btn { background-color: #17a2b8 !important; } 
      .highlight-btn:hover { background-color: #138496 !important; }
      
      button.highlight-btn[style*="rgb(244, 67, 54)"], 
      button.highlight-btn[style*="#F44336"] { background-color: #ffc107 !important; color: #212529 !important; } 
      button.highlight-btn[style*="rgb(244, 67, 54)"]:hover,
      button.highlight-btn[style*="#F44336"]:hover { background-color: #e0a800 !important; }


      .screen-share-btn { background-color: #6f42c1 !important; }
      .screen-share-btn:hover { background-color: #5a2aa8 !important; }
      button.screen-share-btn[style*="rgb(244, 67, 54)"],
      button.screen-share-btn[style*="#F44336"] { background-color: #fd7e14 !important; }
      button.screen-share-btn[style*="rgb(244, 67, 54)"]:hover,
      button.screen-share-btn[style*="#F44336"]:hover { background-color: #e66c00 !important; }


      .status-line { font-size: 1em; margin-top: 10px; display: flex; align-items: center; }
      #obsConnectionStatus, #vdoNinjaConnectionStatus { margin-left: 8px; color: #b0b0b0; }

      input[type="checkbox"] {
        accent-color: #007aff; margin-right: 8px; width: 15px;
        height: 15px; vertical-align: middle; flex-shrink: 0;
      }
      .checkbox-label {
        display: flex; align-items: center; margin-bottom: 5px;
        color: #c0c0c0; font-size: 0.95em;
      }
      .checkbox-label input { margin-bottom: 0; margin-right: 8px; }

      /* Scrollbar styles from obs2 */
      ::-webkit-scrollbar { width: 10px; height: 10px; }
      ::-webkit-scrollbar-track { background: #202225; border-radius: 5px; }
      ::-webkit-scrollbar-thumb { background: #4a4d54; border-radius: 5px; border: 2px solid #202225; }
      ::-webkit-scrollbar-thumb:hover { background: #007aff; }
      * { scrollbar-width: auto; scrollbar-color: #4a4d54 #202225; }


      .flex-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      #obsSceneNameInput { display: none !important; }
      #loadScenesBtn { margin-left: 5px; vertical-align: top; }

      .prefix-input-label { margin-bottom: 4px; display: block; font-size: 0.9em; color: #a0a0b0; }
      .prefix-group { margin-bottom: 10px; }

      a[href^="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"] {
        display: inline-flex; align-items: center; justify-content: center;
        text-decoration: none; color: #a0a0b0; font-size: 12px;
        border: 1px solid #a0a0b0; border-radius: 50%; width: 18px; height: 18px;
        font-weight: bold; vertical-align: middle; margin-left: 4px; margin-bottom: 0;
        transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      }
      a[href^="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"]:hover {
        background-color: #007aff; color: white; border-color: #007aff;
      }

      .stream-mapping {
        background-color: #25272c; padding: 12px; border: 1px solid #383b40;
        border-radius: 6px; margin-bottom: 10px;
      }
      .stream-mapping .flex-row { margin-bottom: 8px; }
      .stream-mapping .flex-row:last-child { margin-bottom: 0; }
      .stream-mapping input[type="text"], .stream-mapping select {
        margin-bottom: 0; font-size: 0.9em; padding: 8px;
      }
      .stream-mapping .remove-mapping-btn {
        padding: 6px 8px; background-color: #c82333 !important;
        font-size: 0.9em; margin-left: auto;
      }
      .stream-mapping .remove-mapping-btn:hover { background-color: #a01c28 !important; }
      .stream-mapping small { font-size: 0.8em; margin-top: 5px; }
      .mapping-stream-id { flex-basis: 100px; flex-grow: 1; min-width: 80px; }
      .mapping-label { flex-basis: 140px; flex-grow: 2; min-width: 100px; }
      .mapping-match-type { flex-basis: 100px; flex-grow: 1; min-width: 90px; }
      .mapping-scene-name { flex-basis: 150px; flex-grow: 2; min-width: 120px;}
      .remove-mapping-btn { flex-shrink: 0; }

      #addStreamMappingBtn { background-color: #0069d9; border-color: #0062cc; }
      #addStreamMappingBtn:hover { background-color: #005cbf; border-color: #0056b3; }
      .stream-mapping .checkbox-label { font-size: 0.9em; margin-bottom: 0; }
      #obsTargetSettingsFlexContainer > div:first-child { flex-grow: 1; }
      #obsTargetSettingsFlexContainer > button { flex-shrink: 0; }
      .crop-overlay {position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-style: dashed; border-width: 1px; border-color: rgba(255, 255, 255, 0.5); pointer-events: none;}
    </style>
  </head>
  <body class="sidebar-collapsed"> <button id="toggleSidebarBtn">☰</button>
    <div id="sidebar"> <h1>VDO.Ninja OBS Control</h1>

        <div class="container">
            <h2 class="collapsible" data-state="expand">OBS WebSocket Connection</h2>
            <div class="collapsible-content">
            <label for="obsWsUrl">WebSocket URL:</label>
            <input type="text" id="obsWsUrl" value="ws://localhost:4455" />

            <label for="obsWsPassword">Password:</label>
            <input type="password" id="obsWsPassword" value="" />

            <div class="prefix-group">
                <label for="cameraPrefix" id="cameraPrefixLabelText" class="prefix-input-label">Camera prefix:</label>
                <input type="text" id="cameraPrefix" value="VDO" />
            </div>
            <div class="prefix-group">
                <label for="reactionSubPrefix" id="reactionSubPrefixLabelText" class="prefix-input-label">Reaction prefix: VDO.</label>
                <input type="text" id="reactionSubPrefix" value="Screen" />
            </div>
            <div class="prefix-group">
                <label for="highlightSubPrefix" id="highlightSubPrefixLabelText" class="prefix-input-label">Highlight prefix: VDO.</label>
                <input type="text" id="highlightSubPrefix" value="Highlight" />
            </div>
            <div class="status-line">
                <button id="obsConnectBtn">Connect</button>
                <span id="obsConnectionStatus">Status: Disconnected</span>
                <span id="obsStatusIndicator" class="status-indicator"></span>
            </div>
            </div>
        </div>

        <div class="container">
            <h2 class="collapsible" data-state="expand">VDO.Ninja Settings</h2>
            <div class="collapsible-content">
            <label for="vdoNinjaBaseUrl">VDO.Ninja Base URL:</label>
            <input type="text" id="vdoNinjaBaseUrl" placeholder="https://vdo.ninja" value="https://vdo.ninja"/>

            <label for="vdoNinjaRoom">Room Name:</label>
            <input type="text" id="vdoNinjaRoom" placeholder="e.g., MyNinjaRoom" class="blur-field"/>

            <label for="vdoNinjaPassword">Password:</label>
            <input type="password" id="vdoNinjaPassword" placeholder="Room or &password" class="blur-field"/>

            <label for="vdoNinjaStreamIds">Stream IDs:</label>
            <input type="text" id="vdoNinjaStreamIds" placeholder="streamId1,streamId2" class="blur-field"/>
            <small>Room Name or Stream ID(s) needed</small>
            </div>
        </div>

        <div class="container">
            <h2 class="collapsible" data-state="collapse">Stream ID Mappings</h2> <div class="collapsible-content collapsed">
            <div id="streamMappingContainer">
                <div id="streamMappings">
                </div>
                <button id="addStreamMappingBtn" style="margin-top: 10px">
                Add New Mapping
                </button>
            </div>
            </div>
        </div>

        <div class="container">
            <h2 class="collapsible" data-state="expand">OBS Target Settings</h2>
            <div class="collapsible-content">
            <label for="obsSceneSelect">Default Target Scene:</label>
            <div class="flex-row" style="gap: 10px" id="obsTargetSettingsFlexContainer">
                <select id="obsSceneSelect" style="width: 300px; flex-grow: 1">
                <option value="">Select a scene...</option>
                </select>
                <button id="loadScenesBtn">Re-Fetch Scenes</button>
            </div>

            <div style="margin-top: 15px;">
                <label for="highlightSceneSelect">Highlight Scene:</label>
                <select id="highlightSceneSelect" style="width: 100%;">
                    <option value="">Do not switch scene</option>
                </select>
                <small>Scene to switch to when a camera is Highlighted via context menu.</small>
            </div>
            <div class="flex-row" style="align-items: flex-end; margin-top: 12px; gap: 15px">
                <div>
                <label for="sourceSizing">New Source Sizing:</label>
                <select id="sourceSizing" style="width: 250px">
                    <option value="defaultSize">Default (1920x1080 at 0,0)</option>
                    <option value="bestFit">Best Fit (Preserve Aspect)</option>
                    <option value="stretchToFill">Stretch to Fill Screen</option>
                    <option value="autoGrid">Auto Grid Layout</option>
                </select>
                </div>
                <div>
                <label for="sourceCodec">Codec:</label>
                <div class="flex-row" style="gap: 2px">
                    <select id="sourceCodec" style="width: 150px">
                    <option value="">none</option>
                    <option value="h264">h264</option>
                    <option value="vp8">vp8</option>
                    <option value="vp9">vp9</option>
                    <option value="av1">av1</option>
                    <option value="h265">h265</option>
                    <option value="webp">webp</option>
                    <option value="hardware">hardware</option>
                    </select>
                    <a href="https://docs.vdo.ninja/advanced-settings/video-parameters/codec" target="_blank" title="Learn more about codec options">?</a>
                </div>
                </div>
            </div>

            <div id="autoSourceOptions" class="flex-row" style="gap: 15px; margin-bottom: 8px; margin-top: 15px">
                <label class="checkbox-label">
                <input type="checkbox" id="autoAddSources" checked />
                Auto-add new streams as sources
                </label>
                <label class="checkbox-label">
                <input type="checkbox" id="autoRemoveSources" checked />
                Auto-remove sources on disconnect
                </label>
            </div>

            <div id="otherScenesContainer" style="margin-top: 15px; border-top: 1px solid #3e4147; padding-top: 15px; display: none">
                <label>Copy sources to other scenes (reference):</label>
                <div id="otherScenesList" style="margin-top: 5px"></div>
            </div>
            <input type="text" id="obsSceneNameInput" style="display: none"/> 
            
            <div style="margin-top: 15px; border-top: 1px solid #3e4147; padding-top: 15px">
                <label style="font-weight: 600; font-size: 1.05em">Screen Sharing Settings:</label>
                <div class="flex-row" style="gap: 15px; align-items: flex-start">
                <div>
                    <label for="screenShareSceneSelect" style="font-size: 0.95em">Target Scene (for Screen Share / Stream action):</label>
                    <select id="screenShareSceneSelect" style="width: 300px">
                    <option value="">Same as main (default)</option>
                    </select>
                </div>
                <div class="flex-row" style="gap: 8px">
                    <div>
                    <label for="screenShareWidth" style="font-size: 0.95em">Width:</label>
                    <input type="number" id="screenShareWidth" value="1920" style="width: 100px"/>
                    </div>
                    <div>
                    <label for="screenShareHeight" style="font-size: 0.95em">Height:</label>
                    <input type="number" id="screenShareHeight" value="1080" style="width: 100px"/>
                    </div>
                </div>
                </div>
            </div>
            </div>
        </div>

        <div class="container">
            <h2 class="collapsible" data-state="expand">Active Streams</h2>
            <div class="collapsible-content">
            <div id="streamList" class="stream-list">
                <div class="stream-item" style="text-align: center; background-color: transparent; border: none; color: #888">
                No active streams
                </div>
            </div>
            </div>
        </div>

        <div class="container">
            <h2 class="collapsible" data-state="expand">Log</h2>
            <div class="collapsible-content">
            <div id="logArea" class="log-area"></div>
            </div>
        </div>
    </div> <div id="mainSceneAreaContainer">
      <div id="obsCanvasInfo">
         <div>OBS Canvas: <span id="canvasDimensionsText">-</span></div>
         <div>Current Scene: <span id="currentSceneNameText">-</span></div>
      </div>
      <div id="mainSceneArea">
        </div>
    </div>

    <iframe id="vdoNinjaIframe" allow="encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;midi *;geolocation;camera *;microphone *;fullscreen;picture-in-picture;display-capture;accelerometer;autoplay;gyroscope;screen-wake-lock;"></iframe>

    <div id="sceneItemContextMenu">
        <ul>
            </ul>
    </div>

    <script>
      // --- DOM Element References ---
      // OBS Connection
      const obsWsUrlInput = document.getElementById('obsWsUrl');
      const obsWsPasswordInput = document.getElementById('obsWsPassword');
      const obsConnectBtn = document.getElementById('obsConnectBtn');
      const obsConnectionStatus = document.getElementById('obsConnectionStatus');
      const obsStatusIndicator = document.getElementById('obsStatusIndicator');

      // Prefixes
      const cameraPrefixInput = document.getElementById('cameraPrefix');
      const reactionSubPrefixInput = document.getElementById('reactionSubPrefix');
      const highlightSubPrefixInput = document.getElementById('highlightSubPrefix');
      const cameraPrefixLabelText = document.getElementById('cameraPrefixLabelText'); 
      const reactionSubPrefixLabelText = document.getElementById('reactionSubPrefixLabelText');
      const highlightSubPrefixLabelText = document.getElementById('highlightSubPrefixLabelText');

      // VDO.Ninja Settings
      const vdoNinjaBaseUrlInput = document.getElementById('vdoNinjaBaseUrl');
      const vdoNinjaRoomInput = document.getElementById('vdoNinjaRoom');
      const vdoNinjaPasswordInput = document.getElementById('vdoNinjaPassword');
      const vdoNinjaStreamIdsInput = document.getElementById('vdoNinjaStreamIds');
      const vdoNinjaIframe = document.getElementById('vdoNinjaIframe');
      // VDO.Ninja connect button and status elements are created dynamically later

      // OBS Target Settings
      const obsSceneNameInput = document.getElementById('obsSceneNameInput'); // Hidden input
      const obsSceneSelect = document.getElementById('obsSceneSelect'); // Default target scene
      const highlightSceneSelect = document.getElementById('highlightSceneSelect'); 
      // const streamSceneSelect = document.getElementById('streamSceneSelect'); // Removed
      const sourceSizingSelect = document.getElementById('sourceSizing');
      const sourceCodecSelect = document.getElementById('sourceCodec');
      const autoAddSourcesCheckbox = document.getElementById('autoAddSources');
      const autoRemoveSourcesCheckbox = document.getElementById('autoRemoveSources');
      const loadScenesBtn = document.getElementById('loadScenesBtn');
      const otherScenesContainer = document.getElementById('otherScenesContainer');
      const otherScenesList = document.getElementById('otherScenesList');
      
      // Screen Sharing Settings
      const screenShareSceneSelect = document.getElementById('screenShareSceneSelect');
      const screenShareWidthInput = document.getElementById('screenShareWidth');
      const screenShareHeightInput = document.getElementById('screenShareHeight');

      // Active Streams & Log
      const streamListContainer = document.getElementById('streamList');
      const logArea = document.getElementById('logArea');

      // Enhanced UI Elements (Sidebar, Visualization, Context Menu)
      const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
      const sidebar = document.getElementById('sidebar');
      const mainSceneAreaContainer = document.getElementById('mainSceneAreaContainer');
      const mainSceneArea = document.getElementById('mainSceneArea');
      const canvasDimensionsText = document.getElementById('canvasDimensionsText');
      const currentSceneNameText = document.getElementById('currentSceneNameText');
      const sceneItemContextMenu = document.getElementById('sceneItemContextMenu');


      // --- State Variables ---
      let obs = null; 
      let obsConnected = false; 
      let vdoNinjaConnected = false; 
      let activeStreams = {}; 
      let obsScenes = []; 
      let requestCallbacks = {}; 
      let vdoNinjaLastActivityTime = 0; 
      let vdoNinjaConnectionCheckTimer = null; 

      // Feature-specific states
      let screenShareId = null; // Stream ID currently being screen shared (via sidebar OR context menu "Stream" action)
      let highlightedStreamId = null; 
      // let mainStreamId = null; // Removed
      
      let loadedSelectedOtherScenes = []; 

      // Visualization state
      let currentProgramSceneName = null; 
      let currentSceneItemsData = {}; 
      let obsCanvasDimensions = { baseWidth: 1920, baseHeight: 1080 }; 
      let activeContextMenuTarget = null; 

      // --- Sidebar Toggle Functionality ---
      if (toggleSidebarBtn && sidebar && document.body) {
        toggleSidebarBtn.addEventListener('click', () => {
          sidebar.classList.toggle('collapsed');
          document.body.classList.toggle('sidebar-collapsed', sidebar.classList.contains('collapsed'));
          localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('collapsed'));
          setTimeout(renderSceneVisualization, 310); 
        });
      }

      // --- Collapsible Sections ---
      document.querySelectorAll('.collapsible').forEach(header => {
        const content = header.nextElementSibling;
        if (!content) {
            console.warn("Collapsible header found without a next sibling content element:", header);
            return;
        }
        const startsExpanded = header.dataset.state === "expand";

        if (startsExpanded) {
          header.classList.remove('collapsed'); 
          content.classList.remove('collapsed');
          header.setAttribute('data-state', 'collapse'); 
        } else { 
          header.classList.add('collapsed');
          content.classList.add('collapsed');
          header.setAttribute('data-state', 'expand'); 
        }

        header.addEventListener('click', function () {
          this.classList.toggle('collapsed'); 
          content.classList.toggle('collapsed');
          const newState = content.classList.contains('collapsed') ? 'expand' : 'collapse';
          this.setAttribute('data-state', newState);
        });
      });

      // --- VDO.Ninja Connection Controls Injection ---
      const vdoNinjaConnectBtn = document.createElement('button');
      vdoNinjaConnectBtn.id = 'vdoNinjaConnectBtn';
      vdoNinjaConnectBtn.textContent = 'Connect';
      vdoNinjaConnectBtn.style.marginTop = '5px';

      const vdoNinjaStatusIndicator = document.createElement('span');
      vdoNinjaStatusIndicator.id = 'vdoNinjaStatusIndicator';
      vdoNinjaStatusIndicator.className = 'status-indicator';

      const vdoNinjaConnectionStatusSpan = document.createElement('span'); 
      vdoNinjaConnectionStatusSpan.id = 'vdoNinjaConnectionStatus';
      vdoNinjaConnectionStatusSpan.textContent = 'Status: Disconnected';
      vdoNinjaConnectionStatusSpan.style.marginLeft = '5px';

      const vdoNinjaSettingsCollapsibleContent = document.querySelector('#sidebar .container:nth-child(3) .collapsible-content');
      if (vdoNinjaSettingsCollapsibleContent) {
        const buttonsDiv = document.createElement('div');
        buttonsDiv.style.marginTop = '10px';
        buttonsDiv.className = 'status-line';
        buttonsDiv.appendChild(vdoNinjaConnectBtn);
        buttonsDiv.appendChild(vdoNinjaConnectionStatusSpan);
        buttonsDiv.appendChild(vdoNinjaStatusIndicator);
        vdoNinjaSettingsCollapsibleContent.appendChild(buttonsDiv);

        vdoNinjaConnectBtn.addEventListener('click', () => {
          if (vdoNinjaConnected) {
            disconnectFromVdoNinja();
          } else {
            connectToVdoNinja();
          }
        });
      } else {
        console.error("Could not find VDO.Ninja settings container to inject connect button.");
      }

      // --- Utility Functions ---
      function logMessage(message) {
        console.log(message); 
        const timestamp = new Date().toLocaleTimeString();
        if (logArea) { 
            logArea.innerHTML += `[${timestamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight; 
        }
      }

      function generateRequestId(type) {
        return `${type}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      }

      function getVdoNinjaBaseUrl() {
        const customUrl = vdoNinjaBaseUrlInput.value.trim();
        return customUrl || "https://vdo.ninja"; 
      }

      function getFullCameraPrefix() { return cameraPrefixInput.value.trim(); }
      function getFullReactionPrefix() { return `${cameraPrefixInput.value.trim()}.${reactionSubPrefixInput.value.trim()}`; }
      function getFullHighlightPrefix() { return `${cameraPrefixInput.value.trim()}.${highlightSubPrefixInput.value.trim()}`; }

      function updatePrefixLabels() {
        const cameraPrefixVal = getFullCameraPrefix();
        const reactionSubVal = reactionSubPrefixInput.value.trim();
        const highlightSubVal = highlightSubPrefixInput.value.trim();
        
        if (reactionSubPrefixLabelText) reactionSubPrefixLabelText.textContent = `Reaction prefix: ${cameraPrefixVal || '(VDO)'}${cameraPrefixVal && reactionSubVal ? '.' : ''}${reactionSubVal || '(Screen)'}`;
        if (highlightSubPrefixLabelText) highlightSubPrefixLabelText.textContent = `Highlight prefix: ${cameraPrefixVal || '(VDO)'}${cameraPrefixVal && highlightSubVal ? '.' : ''}${highlightSubVal || '(Highlight)'}`;
      }
      cameraPrefixInput.addEventListener('input', () => { updatePrefixLabels(); saveSettings(); });
      reactionSubPrefixInput.addEventListener('input', () => { updatePrefixLabels(); saveSettings(); });
      highlightSubPrefixInput.addEventListener('input', () => { updatePrefixLabels(); saveSettings(); });

      function toggleVdoNinjaInputs(disabled) {
        vdoNinjaBaseUrlInput.disabled = disabled;
        vdoNinjaRoomInput.disabled = disabled;
        vdoNinjaPasswordInput.disabled = disabled;
        vdoNinjaStreamIdsInput.disabled = disabled;
      }

      function updateVdoNinjaButtonState(isVdoConnected) {
        vdoNinjaConnected = isVdoConnected; 
        if (vdoNinjaConnectBtn) { 
            if (vdoNinjaConnected) {
              vdoNinjaConnectBtn.textContent = 'Disconnect';
              vdoNinjaConnectBtn.classList.remove('disconnected');
              vdoNinjaConnectBtn.classList.add('connected');
              if(vdoNinjaConnectionStatusSpan) vdoNinjaConnectionStatusSpan.textContent = 'Status: Connected';
              if(vdoNinjaStatusIndicator) { vdoNinjaStatusIndicator.classList.add('connected'); vdoNinjaStatusIndicator.classList.remove('error');}
            } else {
              vdoNinjaConnectBtn.textContent = 'Connect';
              vdoNinjaConnectBtn.classList.remove('connected');
              vdoNinjaConnectBtn.classList.add('disconnected');
              if(vdoNinjaConnectionStatusSpan) vdoNinjaConnectionStatusSpan.textContent = 'Status: Disconnected';
              if(vdoNinjaStatusIndicator) vdoNinjaStatusIndicator.classList.remove('connected', 'error');
            }
        }
        toggleVdoNinjaInputs(vdoNinjaConnected);
      }

      // --- Settings Load/Save ---
      function saveSettings() {
        const otherSceneCheckboxes = document.querySelectorAll('#otherScenesList .other-scene-checkbox:checked');
        const selectedOtherScenes = Array.from(otherSceneCheckboxes).map(cb => cb.value);

        const settings = {
          obsWsUrl: obsWsUrlInput.value,
          obsWsPassword: obsWsPasswordInput.value,
          cameraPrefix: cameraPrefixInput.value,
          reactionSubPrefix: reactionSubPrefixInput.value,
          highlightSubPrefix: highlightSubPrefixInput.value,
          vdoNinjaBaseUrl: vdoNinjaBaseUrlInput.value,
          vdoNinjaRoom: vdoNinjaRoomInput.value,
          vdoNinjaPassword: vdoNinjaPasswordInput.value,
          vdoNinjaStreamIds: vdoNinjaStreamIdsInput.value,
          obsSceneName: obsSceneSelect.value, 
          highlightScene: highlightSceneSelect.value, 
          // streamScene: streamSceneSelect.value, // Removed
          selectedOtherScenes: selectedOtherScenes,
          sourceSizing: sourceSizingSelect.value,
          sourceCodec: sourceCodecSelect.value,
          autoAddSources: autoAddSourcesCheckbox.checked,
          autoRemoveSources: autoRemoveSourcesCheckbox.checked,
          screenShareWidth: screenShareWidthInput.value,
          screenShareHeight: screenShareHeightInput.value,
          screenShareScene: screenShareSceneSelect.value,
        };
        localStorage.setItem('obsNinjaSettings', JSON.stringify(settings));

        const mappings = getStreamMappings();
        localStorage.setItem('obsNinjaStreamMappings', JSON.stringify(mappings));
      }

      function loadSettings() {
        const settingsJson = localStorage.getItem('obsNinjaSettings');
        if (settingsJson) {
          try {
            const settings = JSON.parse(settingsJson);
            obsWsUrlInput.value = settings.obsWsUrl || 'ws://localhost:4455';
            obsWsPasswordInput.value = settings.obsWsPassword || '';
            cameraPrefixInput.value = settings.cameraPrefix || 'VDO';
            reactionSubPrefixInput.value = settings.reactionSubPrefix || 'Screen';
            highlightSubPrefixInput.value = settings.highlightSubPrefix || 'Highlight';
            vdoNinjaBaseUrlInput.value = settings.vdoNinjaBaseUrl || 'https://vdo.ninja';
            vdoNinjaRoomInput.value = settings.vdoNinjaRoom || '';
            vdoNinjaPasswordInput.value = settings.vdoNinjaPassword || '';
            vdoNinjaStreamIdsInput.value = settings.vdoNinjaStreamIds || '';
            
            localStorage.setItem('preferredMainScene', settings.obsSceneName || "");
            localStorage.setItem('preferredHighlightScene', settings.highlightScene || "");
            // localStorage.setItem('preferredStreamScene', settings.streamScene || ""); // Removed
            localStorage.setItem('preferredScreenShareScene', settings.screenShareScene || "");

            loadedSelectedOtherScenes = settings.selectedOtherScenes || [];
            sourceSizingSelect.value = settings.sourceSizing || 'defaultSize';
            sourceCodecSelect.value = settings.sourceCodec || '';
            autoAddSourcesCheckbox.checked = settings.autoAddSources !== undefined ? settings.autoAddSources : true;
            autoRemoveSourcesCheckbox.checked = settings.autoRemoveSources !== undefined ? settings.autoRemoveSources : true;
            
            if (screenShareWidthInput) screenShareWidthInput.value = settings.screenShareWidth || '1920';
            if (screenShareHeightInput) screenShareHeightInput.value = settings.screenShareHeight || '1080';
            
            updatePrefixLabels();
            logMessage("Settings loaded from localStorage.");
          } catch (e) {
            logMessage(`Error loading settings from localStorage: ${e.message}. Using defaults.`);
            applyDefaultSettings(); 
          }
        } else {
          logMessage("No saved settings found. Using default values.");
          applyDefaultSettings(); 
        }
        setupStreamMappingUI(); 
      }
      
      function applyDefaultSettings() { 
          cameraPrefixInput.value = 'VDO';
          reactionSubPrefixInput.value = 'Screen';
          highlightSubPrefixInput.value = 'Highlight';
          updatePrefixLabels();
          vdoNinjaBaseUrlInput.value = 'https://vdo.ninja';
          sourceSizingSelect.value = 'defaultSize';
          sourceCodecSelect.value = ''; 
          autoAddSourcesCheckbox.checked = true;
          autoRemoveSourcesCheckbox.checked = true;
          if (screenShareWidthInput) screenShareWidthInput.value = '1920';
          if (screenShareHeightInput) screenShareHeightInput.value = '1080';
          localStorage.removeItem('preferredMainScene');
          localStorage.removeItem('preferredHighlightScene');
          // localStorage.removeItem('preferredStreamScene'); // Removed
          localStorage.removeItem('preferredScreenShareScene');
          if(obsSceneSelect) obsSceneSelect.value = "";
          if(highlightSceneSelect) highlightSceneSelect.value = "";
          // if(streamSceneSelect) streamSceneSelect.value = ""; // Removed
          if(screenShareSceneSelect) screenShareSceneSelect.value = "";
      }

      // --- VDO.Ninja Connection and Iframe Logic ---
      function connectToVdoNinja() {
        if (vdoNinjaConnected) { logMessage("Already connected to VDO.Ninja."); return; }
        const room = vdoNinjaRoomInput.value.trim();
        const streamIds = vdoNinjaStreamIdsInput.value.trim();
        if (!room && !streamIds) { logMessage("VDO.Ninja Error: Room Name or Stream ID(s) must be provided."); return; }

        initializeVdoNinjaIframe(); 
        if (vdoNinjaConnectionStatusSpan) vdoNinjaConnectionStatusSpan.textContent = 'Status: Connecting...';
        if (vdoNinjaConnectBtn) vdoNinjaConnectBtn.textContent = 'Cancel'; 

        if (vdoNinjaConnectionCheckTimer) clearTimeout(vdoNinjaConnectionCheckTimer);
        vdoNinjaConnectionCheckTimer = setTimeout(() => {
          if (!vdoNinjaConnected && (Date.now() - vdoNinjaLastActivityTime > 15000)) { 
            logMessage("VDO.Ninja connection timed out. No activity received.");
            if(vdoNinjaConnectionStatusSpan) vdoNinjaConnectionStatusSpan.textContent = 'Status: Connection Failed';
            if(vdoNinjaStatusIndicator) vdoNinjaStatusIndicator.classList.add('error');
            if(vdoNinjaConnectBtn) vdoNinjaConnectBtn.textContent = 'Connect';
            toggleVdoNinjaInputs(false); 
          }
        }, 15000); 
        toggleVdoNinjaInputs(true); 
        saveSettings(); 
      }

      function disconnectFromVdoNinja() {
        vdoNinjaIframe.src = 'about:blank'; 
        if (vdoNinjaConnectionCheckTimer) {
          clearTimeout(vdoNinjaConnectionCheckTimer);
          vdoNinjaConnectionCheckTimer = null;
        }
        activeStreams = {}; 
        updateStreamList(); 
        updateVdoNinjaButtonState(false); 
        logMessage("Disconnected from VDO.Ninja.");
      }
      
      function getVdoNinjaViewUrl(streamId, isScreenShare = false) {
        const room = vdoNinjaRoomInput.value.trim();
        const ninjaPassword = vdoNinjaPasswordInput.value;
        const baseUrl = getVdoNinjaBaseUrl();
        let selectedCodec = sourceCodecSelect.value;

        let effectiveStreamId = streamId;
        if (isScreenShare) {
            effectiveStreamId += ":s"; 
            if (!selectedCodec) selectedCodec = 'vp9'; 
        }
        
        let url = `${baseUrl}/?`;
        if (room) {
          url += `view=${encodeURIComponent(effectiveStreamId)}&solo&room=${encodeURIComponent(room)}`;
        } else {
          url += `view=${encodeURIComponent(effectiveStreamId)}`; 
        }

        if (ninjaPassword) url += `&password=${encodeURIComponent(ninjaPassword)}`;
        if (selectedCodec) url += `&codec=${encodeURIComponent(selectedCodec)}`;
        
        url += "&cleanoutput&proaudio&ab=160&transparent&autoplay&noheader&webcursor";
        return url;
      }

      function initializeVdoNinjaIframe() {
        const room = vdoNinjaRoomInput.value.trim();
        const streamIdsInput = vdoNinjaStreamIdsInput.value.trim();

        if (!room && !streamIdsInput) {
          logMessage("VDO.Ninja: Room or Stream ID(s) must be provided to initialize listener.");
          updateVdoNinjaButtonState(false); 
          return;
        }

        const baseUrl = getVdoNinjaBaseUrl();
        let vdoNinjaUrl = `${baseUrl}/?`;

        if (room) {
          vdoNinjaUrl += `room=${encodeURIComponent(room)}`;
          if (streamIdsInput) { 
            const vsids = streamIdsInput.split(',').map(s => s.trim()).filter(s => s).join(',');
            if (vsids) vdoNinjaUrl += `&view=${encodeURIComponent(vsids)}&solo`;
          }
        } else if (streamIdsInput) { 
          const vsids = streamIdsInput.split(',').map(s => s.trim()).filter(s => s).join(',');
          if (vsids) vdoNinjaUrl += `view=${encodeURIComponent(vsids)}`;
          else { logMessage("VDO.Ninja: Stream IDs provided but empty after trimming."); updateVdoNinjaButtonState(false); return; }
        }

        if (vdoNinjaPasswordInput.value) vdoNinjaUrl += `&password=${encodeURIComponent(vdoNinjaPasswordInput.value)}`;
        
        vdoNinjaUrl += "&cleanoutput&dataonly&nocursor&nopush&debug&noaudio&novideo&cors="+encodeURIComponent(window.location.origin);
        
        logMessage(`Initializing VDO.Ninja listener iframe with URL: ${vdoNinjaUrl}`);
        vdoNinjaIframe.src = 'about:blank'; 
        vdoNinjaIframe.setAttribute('crossorigin', 'anonymous'); 
        
        setTimeout(() => {
          vdoNinjaIframe.src = vdoNinjaUrl;
          vdoNinjaLastActivityTime = Date.now(); 
        }, 100);
      }
      
      window.addEventListener("message", async (event) => { 
        const expectedOriginBase = getVdoNinjaBaseUrl();
        let parsedExpectedOrigin;
        try { parsedExpectedOrigin = new URL(expectedOriginBase); }
        catch (e) { logMessage(`Invalid VDO.Ninja base URL in settings: ${expectedOriginBase}`); return; }

        if (event.origin !== parsedExpectedOrigin.origin || event.source !== vdoNinjaIframe.contentWindow) {
          return; 
        }

        const data = event.data;
        vdoNinjaLastActivityTime = Date.now(); 

        if (!vdoNinjaConnected) { 
          vdoNinjaConnected = true;
          updateVdoNinjaButtonState(true);
          if (vdoNinjaConnectionCheckTimer) clearTimeout(vdoNinjaConnectionCheckTimer);
          logMessage("VDO.Ninja iframe connection established and active.");
        }

        if (data && data.streamID) {
          const streamId = data.streamID;
          const label = data.label || `Stream ${streamId}`; 

          if ((data.action === "view-connection" && data.value === true) || 
              (data.action === "guest-connected") || 
              (data.action === "push-connection" && data.value === true)) {
            logMessage(`VDO.Ninja stream connected/active: "${label}" (ID: ${streamId})`);
            activeStreams[streamId] = { label, sourceCreated: false, streamId, uuid: data.UUID || null, connected: true };
            updateStreamList(); 

            if (autoAddSourcesCheckbox.checked && obsConnected) {
              logMessage(`Auto-adding stream ${streamId} ("${label}") to OBS.`);
              const targetInfo = getTargetSceneForStream(streamId, label);
              await addStreamToObs(streamId, label, targetInfo); 
            }
          } else if ((data.action === "view-connection" && data.value === false) || 
                     (data.action === "push-connection" && data.value === false)) {
            if (activeStreams[streamId]) {
              logMessage(`VDO.Ninja stream disconnected/inactive: "${label}" (ID: ${streamId})`);
              if (autoRemoveSourcesCheckbox.checked && obsConnected) {
                logMessage(`Auto-removing stream ${streamId} ("${label}") from OBS.`);
                await removeStreamFromObs(streamId); 
              }
              delete activeStreams[streamId]; 
              updateStreamList(); 
              if (!autoRemoveSourcesCheckbox.checked && obsConnected && currentProgramSceneName) {
                  await fetchAndRenderCurrentProgramScene();
              }
            }
          } else if (data.action === "view-connection-info" && data.value && data.value.label) {
            if (activeStreams[streamId] && activeStreams[streamId].label !== data.value.label) {
              logMessage(`VDO.Ninja stream label updated for ID ${streamId}: "${data.value.label}" (was "${activeStreams[streamId].label}")`);
              activeStreams[streamId].label = data.value.label;
              updateStreamList();
              if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene();
            }
          }
        }
      }, false);

      function startVdoNinjaConnectionMonitor() {
        setInterval(() => {
          if (vdoNinjaConnected && (Date.now() - vdoNinjaLastActivityTime > 45000)) { 
            logMessage("VDO.Ninja connection lost (no activity from iframe). Attempting to reset listener.");
            if(vdoNinjaConnectionStatusSpan) vdoNinjaConnectionStatusSpan.textContent = 'Status: Connection Lost';
            if(vdoNinjaStatusIndicator) {vdoNinjaStatusIndicator.classList.add('error'); vdoNinjaStatusIndicator.classList.remove('connected');}
            
            vdoNinjaConnected = false; 
            updateVdoNinjaButtonState(false); 
            
            setTimeout(() => {
                if (!vdoNinjaConnected) { 
                    logMessage("Re-initializing VDO.Ninja listener iframe due to inactivity.");
                    initializeVdoNinjaIframe();
                }
            }, 5000); 
          }
        }, 30000); 
      }

      // --- OBS WebSocket Core ---
      obsConnectBtn.addEventListener('click', () => {
        if (obsConnected && obs) {
          logMessage("Disconnecting from OBS WebSocket...");
          if (obs) { obs.onclose = null; obs.close(); obs = null; } 
          onObsDisconnected(); 
        } else {
          connectToOBS();
        }
      });

      async function connectToOBS() {
        if (cameraPrefixInput.value.trim() === '' || reactionSubPrefixInput.value.trim() === '' || highlightSubPrefixInput.value.trim() === '') {
            logMessage("Error: Camera, Reaction, and Highlight prefixes are required for OBS connection.");
            if(obsStatusIndicator) obsStatusIndicator.classList.add('error');
            if(obsConnectionStatus) obsConnectionStatus.textContent = 'Status: Error - Prefixes missing';
            return;
        }

        let url = obsWsUrlInput.value.trim();
        const password = obsWsPasswordInput.value; 
        if (!url) { logMessage("Error: OBS WebSocket URL is required."); if(obsStatusIndicator) obsStatusIndicator.classList.add('error'); if(obsConnectionStatus) obsConnectionStatus.textContent = 'Status: Error - URL missing'; return;}
        if (!url.startsWith('ws://') && !url.startsWith('wss://')) { url = 'ws://' + url; obsWsUrlInput.value = url; }

        if(obsConnectionStatus) obsConnectionStatus.textContent = 'Status: Connecting...';
        if(obsStatusIndicator) obsStatusIndicator.classList.remove('connected', 'error');
        logMessage(`Attempting to connect to OBS WebSocket at ${url}...`);
        
        const connectionTimeoutDuration = 10000; 
        const connectionTimeoutId = setTimeout(() => {
            if (!obsConnected && obs && obs.readyState !== WebSocket.OPEN && obs.readyState !== WebSocket.CONNECTING) { 
                logMessage("OBS WebSocket connection attempt timed out.");
                if (obs) { try { obs.close(); } catch (e) {} obs = null; } 
                if(obsConnectionStatus) obsConnectionStatus.textContent = 'Status: Error - Connection timed out';
                if(obsStatusIndicator) obsStatusIndicator.classList.add('error');
                if(obsConnectBtn) { obsConnectBtn.textContent = 'Connect'; obsConnectBtn.classList.remove('connected'); obsConnectBtn.classList.add('disconnected'); }
            }
        }, connectionTimeoutDuration);

        try {
            obs = new WebSocket(url); 

            obs.onopen = () => {
                logMessage("OBS WebSocket connection opened. Waiting for Server Hello...");
            };

            obs.onmessage = async (event) => {
                try {
                    const message = JSON.parse(event.data);

                    if (message.op === 0) { 
                        logMessage("Received Hello from OBS. Sending Identify...");
                        const identifyPayload = {
                            op: 1, 
                            d: {
                                rpcVersion: 1,
                                eventSubscriptions: (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9) | (1 << 10) 
                            }
                        };
                        if (message.d && message.d.authentication) {
                            const { challenge, salt } = message.d.authentication;
                            if (password) {
                                identifyPayload.d.authentication = await generateAuthResponse(password, salt, challenge);
                                logMessage("Authentication data prepared for Identify message.");
                            } else {
                                logMessage("Warning: OBS server requires authentication, but no password provided. Connection will likely fail.");
                            }
                        }
                        obs.send(JSON.stringify(identifyPayload));
                    } else if (message.op === 2) { 
                        clearTimeout(connectionTimeoutId); 
                        logMessage("OBS WebSocket Authentication successful! Connection established.");
                        obsConnected = true;
                        if(obsConnectBtn) { obsConnectBtn.textContent = 'Disconnect'; obsConnectBtn.classList.add('connected'); obsConnectBtn.classList.remove('disconnected'); }
                        if(obsConnectionStatus) obsConnectionStatus.textContent = 'Status: Connected';
                        if(obsStatusIndicator) { obsStatusIndicator.classList.add('connected'); obsStatusIndicator.classList.remove('error'); }
                        saveSettings(); 
                        onObsConnected(); 
                    } else if (message.op === 7) { 
                        const entry = message.d && message.d.requestId ? requestCallbacks[message.d.requestId] : null;
                        if (entry) {
                            const responseDataWrapper = message.d; 
                            const requestStatus = responseDataWrapper.requestStatus;
                            const responseData = responseDataWrapper.responseData || {}; 
                            const requestType = responseDataWrapper.requestType || entry.requestType; 
                            
                            if (requestStatus && (requestStatus.result === true || requestStatus.code === 100)) { 
                                entry.resolve(responseData); 
                            } else { 
                                const errorMessage = requestStatus ? requestStatus.comment : "Unknown error";
                                const errorCode = requestStatus ? requestStatus.code : 'N/A';
                                const suppressLog = entry.suppressNotFound && (errorCode === 600 || errorCode === 601 || String(errorCode).startsWith('RESOURCE_')); 
                                if (!suppressLog) {
                                    logMessage(`OBS Request Error (Type: ${requestType}, ID: ${responseDataWrapper.requestId}): ${errorMessage} (Code: ${errorCode})`);
                                }
                                entry.reject(new Error(`Request ${requestType} failed: ${errorMessage} (Code: ${errorCode})`));
                            }
                            delete requestCallbacks[responseDataWrapper.requestId];
                        } else if (message.d && message.d.requestId) {
                            // logMessage(`Received response for unknown or timed-out request ID: ${message.d.requestId}`);
                        }
                    } else if (message.op === 5) { 
                        await handleObsEvent(message.d); 
                    }
                } catch (error) {
                    logMessage(`Error processing OBS WebSocket message: ${error.message}. Data: ${event.data}`);
                }
            };

            obs.onerror = (errorEvent) => {
                clearTimeout(connectionTimeoutId);
                let errorMsg = 'Unknown WebSocket error';
                if (errorEvent && errorEvent.message) errorMsg = errorEvent.message;
                else if (typeof errorEvent === 'string') errorMsg = errorEvent;
                else if (errorEvent.type) errorMsg = `Event type: ${errorEvent.type}`;
                
                logMessage(`OBS WebSocket Error: ${errorMsg}`);
                if(obsStatusIndicator) obsStatusIndicator.classList.add('error');
                if(obsConnectionStatus) obsConnectionStatus.textContent = 'Status: Error';
                if(obsConnectBtn) { obsConnectBtn.textContent = 'Connect'; obsConnectBtn.classList.remove('connected'); obsConnectBtn.classList.add('disconnected');}
                obsConnected = false; 
            };

            obs.onclose = (event) => {
                clearTimeout(connectionTimeoutId);
                let reason = '';
                if (event.code === 4009) reason = 'Authentication Failed - incorrect password or auth required and not provided.';
                else if (event.reason) reason = event.reason;
                else reason = `Code: ${event.code || 'Unknown'}${event.wasClean ? "" : " (Unclean disconnection)"}`;
                
                logMessage(`OBS WebSocket Connection Closed. Reason: ${reason}`);
                onObsDisconnected(); 
            };
        } catch (error) {
            clearTimeout(connectionTimeoutId);
            logMessage(`Error creating OBS WebSocket connection: ${error.message}`);
            if(obsConnectionStatus) obsConnectionStatus.textContent = 'Status: Error';
            if(obsStatusIndicator) obsStatusIndicator.classList.add('error');
            if(obsConnectBtn) { obsConnectBtn.textContent = 'Connect'; obsConnectBtn.classList.remove('connected'); obsConnectBtn.classList.add('disconnected'); }
            obsConnected = false;
        }
      }
      
      async function handleObsEvent(eventMessage) {
        if (!eventMessage || !eventMessage.eventType) return;

        const eventType = eventMessage.eventType;
        const eventData = eventMessage.eventData || {};

        switch (eventType) {
            case 'CurrentProgramSceneChanged':
                logMessage(`OBS Event: Program scene changed to '${eventData.sceneName}'.`);
                currentProgramSceneName = eventData.sceneName;
                if (currentSceneNameText) currentSceneNameText.textContent = currentProgramSceneName || '-';
                await fetchAndRenderCurrentProgramScene();
                break;
            case 'SceneListChanged': 
                logMessage("OBS Event: Scene list changed. Re-fetching scenes.");
                await fetchObsScenes(); 
                if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
                break;
            case 'InputCreated':
                 // logMessage(`OBS Event: Input created ('${eventData.inputName}'). Refreshing current scene if it's the active one.`);
                 if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene();
                 break;
            case 'InputRemoved':
                 logMessage(`OBS Event: Input removed ('${eventData.inputName}').`);
                 const removedVdoInfo = getVdoNinjaInfoFromSourceName(eventData.inputName);
                 if (removedVdoInfo.streamId && activeStreams[removedVdoInfo.streamId]) {
                     // Only mark sourceCreated as false if the *camera* source was removed.
                     // Screen share removal should not affect this flag for the main camera.
                     if (removedVdoInfo.isVdoNinjaCam) { 
                         activeStreams[removedVdoInfo.streamId].sourceCreated = false; 
                         logMessage(`Main camera source '${eventData.inputName}' for stream ${removedVdoInfo.streamId} removed from OBS. Updating internal state.`);
                     }
                     // Update global states if the removed source matches any active focus
                     if (highlightedStreamId === removedVdoInfo.streamId && removedVdoInfo.isVdoNinjaCam) {
                        highlightedStreamId = null;
                        logMessage(`Highlighted source for stream ${removedVdoInfo.streamId} removed.`);
                     }
                     if (screenShareId === removedVdoInfo.streamId && removedVdoInfo.isVdoNinjaScreenShare) {
                        screenShareId = null;
                        logMessage(`Screen share source for stream ${removedVdoInfo.streamId} removed.`);
                     }
                     updateStreamList();
                 }
                 if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene();
                 break;
            case 'InputNameChanged':
                 logMessage(`OBS Event: Input name changed from '${eventData.oldInputName}' to '${eventData.inputName}'. Refreshing current scene.`);
                 // This is complex because a rename could affect highlight state or camera/screen share distinction.
                 // A full refresh of the current scene is the safest way to reflect the change.
                 if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene();
                 break;
            case 'SceneItemCreated':
            case 'SceneItemRemoved':
            case 'SceneItemListReindexed': 
            case 'SceneItemTransformChanged':
            case 'SceneItemEnableStateChanged':
                if (eventData.sceneName === currentProgramSceneName) {
                    // logMessage(`OBS Event: Item change in current scene ('${eventData.sceneName}') due to ${eventType}. Refreshing visualization.`);
                    await fetchAndRenderCurrentProgramScene(); 
                }
                break;
            default:
                break;
        }
      }


      async function generateAuthResponse(password, salt, challenge) {
        const encoder = new TextEncoder();
        try {
            const secretString = password + salt;
            const secretData = encoder.encode(secretString);
            let secretHash;

            if (window.crypto && window.crypto.subtle) {
                const hashBuffer = await window.crypto.subtle.digest('SHA-256', secretData);
                secretHash = new Uint8Array(hashBuffer);
            } else { 
                await loadJsShaLibrary(); 
                const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
                shaObj.update(secretString);
                const hashHex = shaObj.getHash("HEX");
                secretHash = new Uint8Array(hashHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            }
            const secretBase64 = btoa(String.fromCharCode.apply(null, secretHash));
            const authString = secretBase64 + challenge;
            const authData = encoder.encode(authString);
            let authHash;

            if (window.crypto && window.crypto.subtle) {
                const hashBuffer = await window.crypto.subtle.digest('SHA-256', authData);
                authHash = new Uint8Array(hashBuffer);
            } else {
                const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
                shaObj.update(authString);
                const hashHex = shaObj.getHash("HEX");
                authHash = new Uint8Array(hashHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            }
            return btoa(String.fromCharCode.apply(null, authHash));
        } catch (error) {
            logMessage(`OBS Authentication generation error: ${error.message}`);
            throw error; 
        }
      }

      function sendRequest(requestType, requestData = {}, options = {}) {
      	return new Promise((resolve, reject) => {
      		if (!obsConnected || !obs || obs.readyState !== WebSocket.OPEN) {
                logMessage(`Cannot send request '${requestType}': Not connected to OBS or socket not open.`);
                reject(new Error("Not connected to OBS or socket not open"));
                return;
            }
      		const requestId = generateRequestId(requestType);
            requestCallbacks[requestId] = { resolve, reject, requestType, suppressNotFound: !!options.suppressNotFound };

            const requestPayload = {
                op: 6, 
                d: { requestType, requestId, requestData }
            };

            try {
                obs.send(JSON.stringify(requestPayload));
            } catch (error) {
                logMessage(`Error sending OBS request '${requestType}': ${error.message}`);
                if (requestCallbacks[requestId]) { 
                    const failedEntry = requestCallbacks[requestId];
                    delete requestCallbacks[requestId];
                    failedEntry.reject(error); 
                } else { reject(error); }
            }

      		setTimeout(() => { 
      			if (requestCallbacks[requestId]) {
      				const entry = requestCallbacks[requestId];
                    delete requestCallbacks[requestId];
                    logMessage(`OBS Request '${entry.requestType}' (ID: ${requestId}) timed out.`);
      				entry.reject(new Error(`Request timeout for ${entry.requestType}`));
      			}
      		}, 7000); 
      	});
      }

      async function onObsConnected() {
        logMessage("OBS Connection fully established. Fetching initial data...");
        await fetchObsVideoSettings(); 
        await fetchObsScenes(); 

        const preferredMain = localStorage.getItem('preferredMainScene');
        if (preferredMain && obsScenes.some(s => s.sceneName === preferredMain)) obsSceneSelect.value = preferredMain;
        
        const preferredHighlight = localStorage.getItem('preferredHighlightScene');
        if (highlightSceneSelect && (preferredHighlight === "" || (preferredHighlight && obsScenes.some(s => s.sceneName === preferredHighlight)))) highlightSceneSelect.value = preferredHighlight;
        
        // const preferredStream = localStorage.getItem('preferredStreamScene'); // Removed

        const preferredScreenShare = localStorage.getItem('preferredScreenShareScene');
        if (screenShareSceneSelect && (preferredScreenShare === "" || (preferredScreenShare && obsScenes.some(s => s.sceneName === preferredScreenShare)))) screenShareSceneSelect.value = preferredScreenShare;

        obsSceneNameInput.value = obsSceneSelect.value; 
        updateOtherScenesList(); 

        await fetchAndRenderCurrentProgramScene(); 

        if (sourceSizingSelect.value === 'autoGrid' && getTargetScene()) {
          logMessage("Initial rearrange for auto-grid on main target scene after OBS connection.");
          setTimeout(() => rearrangeAllStreamsInScene(getTargetScene()), 1000); 
        }
      }

      function onObsDisconnected() {
        logMessage("OBS Connection has been closed or lost.");
        obsConnected = false;
        if(obsConnectBtn) { obsConnectBtn.textContent = 'Connect'; obsConnectBtn.classList.remove('connected'); obsConnectBtn.classList.add('disconnected'); }
        if(obsConnectionStatus) obsConnectionStatus.textContent = 'Status: Disconnected';
        if(obsStatusIndicator) obsStatusIndicator.classList.remove('connected', 'error');

        Object.values(activeStreams).forEach(stream => stream.sourceCreated = false);
        updateStreamList(); 

        obsScenes = []; 
        updateSceneDropdowns(); 
        updateOtherScenesList(); 

        currentProgramSceneName = null;
        currentSceneItemsData = {};
        if (currentSceneNameText) currentSceneNameText.textContent = '-';
        if (canvasDimensionsText) canvasDimensionsText.textContent = '-';
        if (mainSceneArea) mainSceneArea.innerHTML = '<div style="text-align:center; padding:50px; color:#888;">OBS Disconnected.</div>';
        
        requestCallbacks = {}; 
      }
      
      async function fetchObsScenes() {
        if (!obsConnected || !obs) { logMessage("Cannot fetch OBS scenes: Not connected to OBS."); return; }
        logMessage("Fetching OBS scenes...");
        try {
          const response = await sendRequest('GetSceneList');
          if (response && Array.isArray(response.scenes)) {
            obsScenes = response.scenes; 
            logMessage(`Fetched ${obsScenes.length} scenes from OBS.`);

            const currentMainVal = obsSceneSelect.value;
            const currentHighlightVal = highlightSceneSelect ? highlightSceneSelect.value : "";
            // const currentStreamVal = streamSceneSelect ? streamSceneSelect.value : ""; // Removed
            const currentScreenShareVal = screenShareSceneSelect ? screenShareSceneSelect.value : "";
            
            const mappingSceneSelects = document.querySelectorAll('.mapping-scene-name');
            const currentMappingValues = Array.from(mappingSceneSelects).map(s => s.value);

            updateSceneDropdowns(); 

            if (obsScenes.some(s => s.sceneName === currentMainVal)) obsSceneSelect.value = currentMainVal;
            if (highlightSceneSelect && (currentHighlightVal === "" || obsScenes.some(s => s.sceneName === currentHighlightVal))) highlightSceneSelect.value = currentHighlightVal;
            // if (streamSceneSelect && (currentStreamVal === "" || obsScenes.some(s => s.sceneName === currentStreamVal))) streamSceneSelect.value = currentStreamVal; // Removed
            if (screenShareSceneSelect && (currentScreenShareVal === "" || obsScenes.some(s => s.sceneName === currentScreenShareVal))) screenShareSceneSelect.value = currentScreenShareVal;

            mappingSceneSelects.forEach((select, index) => {
                if (currentMappingValues[index] && obsScenes.some(s => s.sceneName === currentMappingValues[index])) {
                    select.value = currentMappingValues[index];
                }
            });

            obsSceneNameInput.value = obsSceneSelect.value; 
            updateOtherScenesList(); 

          } else { 
            logMessage("Failed to fetch OBS scenes or no scenes returned in expected format."); 
            obsScenes = []; updateSceneDropdowns(); updateOtherScenesList(); 
          }
        } catch (error) { 
          logMessage(`Error fetching OBS scenes: ${error.message}`); 
          obsScenes = []; updateSceneDropdowns(); updateOtherScenesList(); 
        }
      }

      function populateSceneDropdown(scenesData, selectElement, allowNoSwitch = false) { 
        if (!selectElement) { console.warn("populateSceneDropdown: selectElement is null"); return; }
        const currentValue = selectElement.value; 
        
        if (selectElement.id === 'screenShareSceneSelect') {
          selectElement.innerHTML = '<option value="">Same as main (default)</option>';
        } else if (allowNoSwitch && (selectElement.id === 'highlightSceneSelect' /*|| selectElement.id === 'streamSceneSelect'*/)) { // streamSceneSelect removed
          selectElement.innerHTML = '<option value="">Do not switch scene</option>';
        } else {
          selectElement.innerHTML = '<option value="">Select a scene...</option>';
        }

        if (!scenesData || scenesData.length === 0) return; 
        
        scenesData.forEach(scene => {
          const option = document.createElement('option');
          option.value = scene.sceneName; option.textContent = scene.sceneName;
          selectElement.appendChild(option);
        });

        if (currentValue && Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
          selectElement.value = currentValue;
        } 
      }
      
      function updateSceneDropdowns() { 
        populateSceneDropdown(obsScenes, obsSceneSelect);
        if (screenShareSceneSelect) populateSceneDropdown(obsScenes, screenShareSceneSelect); 
        if (highlightSceneSelect) populateSceneDropdown(obsScenes, highlightSceneSelect, true); 
        // if (streamSceneSelect) populateSceneDropdown(obsScenes, streamSceneSelect, true); // Removed

        const mappingSceneSelects = document.querySelectorAll('.mapping-scene-name');
        mappingSceneSelects.forEach(select => {
          populateSceneDropdown(obsScenes, select);
        });
      }

      function updateOtherScenesList() { 
        if (!otherScenesList || !otherScenesContainer) return;
        const mainSceneName = obsSceneSelect.value;
        otherScenesList.innerHTML = ''; 

        if (mainSceneName && obsScenes && obsScenes.length > 1) {
          let hasOtherScenes = false;
          obsScenes.forEach(scene => {
            if (scene.sceneName !== mainSceneName) {
              hasOtherScenes = true;
              const checkboxId = `otherScene_${scene.sceneName.replace(/\s+/g, '_')}`;
              const listItem = document.createElement('div');
              listItem.className = 'checkbox-label';
              listItem.style.marginBottom = "8px"; 

              const checkbox = document.createElement('input');
              checkbox.type = 'checkbox';
              checkbox.id = checkboxId;
              checkbox.value = scene.sceneName;
              checkbox.className = 'other-scene-checkbox'; 
              if (loadedSelectedOtherScenes.includes(scene.sceneName)) checkbox.checked = true;
              checkbox.addEventListener('change', saveSettings); 

              const label = document.createElement('label');
              label.htmlFor = checkboxId;
              label.textContent = scene.sceneName;
              label.style.marginLeft = "0"; 

              listItem.appendChild(checkbox);
              listItem.appendChild(label);
              otherScenesList.appendChild(listItem);
            }
          });
          otherScenesContainer.style.display = hasOtherScenes ? 'block' : 'none';
        } else {
          otherScenesContainer.style.display = 'none';
        }
      }

      function getTargetScene() { return obsSceneSelect.value || ''; } 

      // --- Stream Mapping UI Functions ---
      function addNewStreamMapping(streamId = '', label = '', sceneName = '', matchType = 'streamId', shouldClone = true, shouldSwitch = false) {
          const streamMappingsDiv = document.getElementById('streamMappings');
          if (!streamMappingsDiv) { console.error("Stream Mappings container not found."); return; }
          
          const mappingDiv = document.createElement('div');
          mappingDiv.className = 'stream-mapping';
          const initialStreamId = (typeof streamId === 'object' && streamId !== null && streamId.target) ? '' : String(streamId);

          mappingDiv.innerHTML = `
              <div style="margin-bottom: 5px;">
                  <label style="font-size: 1em; margin-bottom: 6px; display: block; font-weight:500;">Stream Mapping Rule</label>
                  <div class="flex-row" style="align-items: center; margin-bottom: 6px;">
                      <input type="text" placeholder="Stream ID" value="${initialStreamId}" class="mapping-stream-id" title="VDO.Ninja Stream ID">
                      <input type="text" placeholder="Label (optional)" value="${label}" class="mapping-label" title="VDO.Ninja Stream Label">
                      <select class="mapping-match-type" title="How to match stream">
                          <option value="streamId" ${matchType === 'streamId' ? 'selected' : ''}>ID Only</option>
                          <option value="label" ${matchType === 'label' ? 'selected' : ''}>Label Only</option>
                          <option value="both" ${matchType === 'both' ? 'selected' : ''}>Both Required</option>
                          <option value="either" ${matchType === 'either' ? 'selected' : ''}>Either Match</option>
                      </select>
                      <select class="mapping-scene-name" title="Target OBS Scene">
                          <option value="">Select a scene...</option>
                      </select>
                      <button class="remove-mapping-btn" title="Remove this mapping rule">×</button>
                  </div>
                  <div class="flex-row" style="gap: 15px;">
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-clone-to-main" ${shouldClone ? 'checked' : ''}>
                          Clone to default scene
                      </label>
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-switch-to-scene" ${shouldSwitch ? 'checked' : ''}>
                          Switch to scene on add
                      </label>
                  </div>
                  <small style="color: #8a8a9a; font-size: 0.85em; display: block; margin-top: 4px;">
                      Define how incoming streams are routed to OBS scenes.
                  </small>
              </div>
          `;
          streamMappingsDiv.appendChild(mappingDiv);
          const sceneDropdown = mappingDiv.querySelector('.mapping-scene-name');
          populateSceneDropdown(obsScenes, sceneDropdown); 
          if (sceneName && obsScenes.some(scene => scene.sceneName === sceneName)) {
              sceneDropdown.value = sceneName; 
          }
          const removeBtn = mappingDiv.querySelector('.remove-mapping-btn');
          removeBtn.addEventListener('click', () => { mappingDiv.remove(); saveSettings(); });
          
          const inputs = mappingDiv.querySelectorAll('input, select');
          inputs.forEach(input => {
              input.addEventListener('change', saveSettings);
              if(input.type === 'text') input.addEventListener('input', saveSettings); 
          });
      }

      function setupStreamMappingUI() { 
        const addStreamMappingBtn = document.getElementById('addStreamMappingBtn');
        if (addStreamMappingBtn) addStreamMappingBtn.addEventListener('click', () => { addNewStreamMapping(); });
        else console.warn("Add Stream Mapping Button not found.");
        loadStreamMappings();
      }

      function loadStreamMappings() { 
          const mappingsJson = localStorage.getItem('obsNinjaStreamMappings');
          if (mappingsJson) {
              try {
                  const mappings = JSON.parse(mappingsJson);
                  mappings.forEach(mapping => {
                      addNewStreamMapping(
                          mapping.streamId, mapping.label, mapping.sceneName, mapping.matchType,
                          mapping.cloneToMain !== undefined ? mapping.cloneToMain : true, 
                          mapping.switchToScene !== undefined ? mapping.switchToScene : false 
                      );
                  });
                  logMessage(`Loaded ${mappings.length} stream mappings from localStorage.`);
              } catch (e) { logMessage(`Error loading stream mappings from localStorage: ${e.message}`);}
          }
      }

      function getStreamMappings() { 
          const mappings = [];
          document.querySelectorAll('#streamMappings .stream-mapping').forEach(div => {
              const streamIdInput = div.querySelector('.mapping-stream-id');
              const labelInput = div.querySelector('.mapping-label');
              const matchTypeSelect = div.querySelector('.mapping-match-type');
              const sceneNameSelect = div.querySelector('.mapping-scene-name');
              const cloneToMainCheckbox = div.querySelector('.mapping-clone-to-main');
              const switchToSceneCheckbox = div.querySelector('.mapping-switch-to-scene');

              if (streamIdInput && labelInput && matchTypeSelect && sceneNameSelect && cloneToMainCheckbox && switchToSceneCheckbox) {
                  const streamId = streamIdInput.value.trim();
                  const label = labelInput.value.trim();
                  const matchType = matchTypeSelect.value;
                  const sceneName = sceneNameSelect.value.trim();
                  const cloneToMain = cloneToMainCheckbox.checked;
                  const switchToScene = switchToSceneCheckbox.checked;
                  
                  let identifierPresent = false;
                  if (matchType === 'streamId' && streamId) identifierPresent = true;
                  else if (matchType === 'label' && label) identifierPresent = true;
                  else if ((matchType === 'both' || matchType === 'either') && (streamId || label)) identifierPresent = true;

                  if (sceneName && identifierPresent) { 
                      mappings.push({ streamId, label, matchType, sceneName, cloneToMain, switchToScene });
                  }
              } else {
                  logMessage("Warning: Could not find all expected elements in a stream mapping UI div during getStreamMappings.");
              }
          });
          return mappings;
      }
      
      function getTargetSceneForStream(streamId, streamLabel = '') { 
        const mappings = getStreamMappings(); 
        const defaultTargetScene = getTargetScene(); 

        for (const mapping of mappings) {
          let isMatch = false;
          const mappingStreamId = mapping.streamId;
          const mappingLabel = mapping.label;

          switch (mapping.matchType) {
            case 'streamId': isMatch = mappingStreamId && streamId === mappingStreamId; break;
            case 'label':    isMatch = mappingLabel && streamLabel && streamLabel === mappingLabel; break;
            case 'both':     isMatch = mappingStreamId && mappingLabel && streamId === mappingStreamId && streamLabel === mappingLabel; break;
            case 'either':   isMatch = (mappingStreamId && streamId === mappingStreamId) || (mappingLabel && streamLabel && streamLabel === mappingLabel); break;
          }
          if (isMatch && mapping.sceneName) {
            return { scene: mapping.sceneName, mapping: mapping }; 
          }
        }
        return { scene: defaultTargetScene, mapping: null };
      }
      
      function updateStreamList() { 
        if (!streamListContainer) return;
        if (Object.keys(activeStreams).length === 0) {
          streamListContainer.innerHTML = '<div class="stream-item" style="text-align:center; background-color:transparent; border:none; color:#888;">No active streams</div>';
          return;
        }
        streamListContainer.innerHTML = ''; 

        for (const streamId in activeStreams) {
          if (Object.hasOwnProperty.call(activeStreams, streamId)) {
            const stream = activeStreams[streamId];
            const streamDiv = document.createElement('div');
            streamDiv.className = 'stream-item';

            const targetInfo = getTargetSceneForStream(streamId, stream.label);
            const targetSceneName = targetInfo.scene;
            const isDefaultScene = targetSceneName === getTargetScene() && !targetInfo.mapping; 
            const isMappedScene = !!targetInfo.mapping; 

            const isHighlighted = highlightedStreamId === streamId;
            const isCurrentlyScreenSharingThisStream = screenShareId === streamId; // This now covers the "Stream" action

            let streamItemHTML = `
              <div style="font-weight: 600; font-size: 1.05em; color: #E0E0E0;">${stream.label || streamId}</div>
              <small>ID: ${streamId}${stream.label ? ` | Label: ${stream.label}` : ''}</small>
              <small style="display: block; color: #A0A0B0;">
                  → Target Scene: ${targetSceneName || 'Not Set'}
                  ${isDefaultScene && targetSceneName ? '(default)' : isMappedScene && targetSceneName ? '(mapped)' : targetSceneName ? '(main fallback)' : ''}
                  ${targetInfo.mapping?.switchToScene ? ' (Auto-Switch ON)' : ''}
              </small>
              <div style="margin-top: 2px; font-size: 0.9em;">
                ${stream.sourceCreated ? '<span style="color:#28A745">✓ Added to OBS</span>' : '<span style="color:#FFC107">✗ Not in OBS</span>'}
              </div>
              <div style="margin-top: 8px;" class="flex-row">
                  <button class="add-stream-btn" data-stream-id="${streamId}" style="background-color: ${stream.sourceCreated ? '#F44336' : '#4C80AF'};">
                      ${stream.sourceCreated ? 'Remove from OBS' : 'Add to OBS'}
                  </button>`;
            if (stream.sourceCreated) { 
              streamItemHTML += `<button class="highlight-btn" data-stream-id="${streamId}" style="background-color: ${isHighlighted ? '#F44336' : '#4CAF50'};">
                                  ${isHighlighted ? 'Unhighlight' : 'Highlight'}
                                </button>
                                <button class="screen-share-btn" data-stream-id="${streamId}" data-label="${stream.label || streamId}" style="background-color: ${isCurrentlyScreenSharingThisStream ? '#F44336' : '#9C27B0'};">
                                  ${isCurrentlyScreenSharingThisStream ? 'Stop Stream' : 'Stream'}
                                </button>`; // Changed button text
            }
            streamItemHTML += `</div>`;
            streamDiv.innerHTML = streamItemHTML;
            streamListContainer.appendChild(streamDiv);

            const addRemoveBtn = streamDiv.querySelector('.add-stream-btn');
            if (addRemoveBtn) {
              addRemoveBtn.addEventListener('click', async () => {
                stream.sourceCreated ? await removeStreamFromObs(streamId) : await addStreamToObs(streamId, stream.label, targetInfo);
              });
            }
            const highlightBtn = streamDiv.querySelector('.highlight-btn');
            if (highlightBtn) {
              highlightBtn.addEventListener('click', async () => {
                await toggleHighlight(streamId, stream.label, targetInfo);
              });
            }
            const screenShareStreamBtn = streamDiv.querySelector('.screen-share-btn'); // Renamed for clarity
            if (screenShareStreamBtn) {
              screenShareStreamBtn.addEventListener('click', async () => {
                const currentStreamId = screenShareStreamBtn.dataset.streamId;
                const currentStreamLabel = screenShareStreamBtn.dataset.label;
                if (screenShareId === currentStreamId) { // If this stream is already screen sharing, stop it
                    await removeScreenShareFromObs(currentStreamId);
                    // After stopping, check if we need to switch to default scene
                    if (!highlightedStreamId) { // Only switch if nothing else is highlighted
                        const defaultScene = getTargetScene();
                        if (defaultScene && defaultScene !== currentProgramSceneName) {
                            logMessage(`Screen share stopped for ${currentStreamId}, nothing highlighted. Switching to default scene '${defaultScene}'.`);
                            try { await sendRequest('SetCurrentProgramScene', { sceneName: defaultScene }); }
                            catch (e) { logMessage(`Error switching to default scene: ${e.message}`); }
                        }
                    }
                } else { // Start screen sharing for this stream
                    await addScreenShareToObs(currentStreamId, currentStreamLabel);
                    // Scene switch is handled by addScreenShareToObs based on screenShareSceneSelect
                }
              });
            }
          }
        }
      }
      
      // --- OBS Source Management ---
      async function addStreamToObs(streamId, streamLabel, targetInfo = null) { 
        if (!obsConnected || !obs) { logMessage(`Cannot add stream "${streamLabel}" (${streamId}): Not connected to OBS.`); return; }
        
        const resolvedTargetInfo = targetInfo || getTargetSceneForStream(streamId, streamLabel);
        const targetSceneName = resolvedTargetInfo.scene;
        const mappingRule = resolvedTargetInfo.mapping;

        if (!targetSceneName) { logMessage(`Cannot add stream "${streamLabel}" (${streamId}): Target OBS scene not set (no default or mapping).`); return; }

        const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
        const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
        let effectiveSourceName = baseSourceName; 
        let sourceReallyExistsGlobally = false;

        try {
            await sendRequest('GetInputSettings', { inputName: highlightedSourceName }, { suppressNotFound: true });
            effectiveSourceName = highlightedSourceName; 
            sourceReallyExistsGlobally = true;
            if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = true; 
            if (highlightedStreamId !== streamId) { 
                logMessage(`Source ${streamId} found as highlighted ('${highlightedSourceName}') in OBS. Updating internal highlight state.`);
                highlightedStreamId = streamId;
            }
        } catch (e) { 
            try {
                await sendRequest('GetInputSettings', { inputName: baseSourceName }, { suppressNotFound: true });
                effectiveSourceName = baseSourceName; 
                sourceReallyExistsGlobally = true;
                if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = true;
                 if (highlightedStreamId === streamId && effectiveSourceName === baseSourceName) {
                    logMessage(`Source ${streamId} found as base ('${baseSourceName}') in OBS, but tool thought it was highlighted. Clearing internal highlight state.`);
                    highlightedStreamId = null;
                }
            } catch (e2) { 
                effectiveSourceName = baseSourceName; 
                sourceReallyExistsGlobally = false;
                if (highlightedStreamId === streamId) { 
                    logMessage(`Source ${streamId} was marked as highlighted in tool, but not found in OBS. Clearing internal highlight state.`);
                    highlightedStreamId = null;
                }
            }
        }
        
        const mainDefaultScene = getTargetScene(); 
        let shouldCloneThisStreamToMain = mappingRule && mappingRule.cloneToMain && mappingRule.sceneName !== mainDefaultScene;
        let shouldSwitchToThisScene = mappingRule && mappingRule.switchToScene;

        const vdoNinjaStreamUrl = getVdoNinjaViewUrl(streamId); 
        const canvasWidth = obsCanvasDimensions.baseWidth;
        const canvasHeight = obsCanvasDimensions.baseHeight;
        const inputSettings = { url: vdoNinjaStreamUrl, width: canvasWidth, height: canvasHeight, fps: 30, reroute_audio: true, restart_when_active: false, shutdown: false };

        logMessage(`Managing source '${effectiveSourceName}' for stream "${streamLabel}" in OBS scene '${targetSceneName}'. Exists globally: ${sourceReallyExistsGlobally}`);

        try {
            let initialSceneItemId = null;
            let clonedSceneItemId = null;

            if (!sourceReallyExistsGlobally) {
                await sendRequest('CreateInput', { sceneName: targetSceneName, inputName: baseSourceName, inputKind: 'browser_source', inputSettings, sceneItemEnabled: true });
                effectiveSourceName = baseSourceName; 
                logMessage(`Created new global input '${effectiveSourceName}' and added to scene '${targetSceneName}'.`);
            } else {
                await sendRequest('SetInputSettings', { inputName: effectiveSourceName, inputSettings });
                logMessage(`Updated settings for existing global input '${effectiveSourceName}'.`);
            }
            
            try {
                const itemInfo = await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: effectiveSourceName }, { suppressNotFound: true });
                initialSceneItemId = itemInfo.sceneItemId;
            } catch (e) { 
                if (e.message.toLowerCase().includes("not found") || (e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"))) {
                    const createItemResponse = await sendRequest('CreateSceneItem', { sceneName: targetSceneName, sourceName: effectiveSourceName });
                    initialSceneItemId = createItemResponse.sceneItemId;
                    logMessage(`Added source '${effectiveSourceName}' as item to scene '${targetSceneName}'.`);
                } else { throw e; } 
            }

            if (shouldCloneThisStreamToMain && mainDefaultScene && mainDefaultScene !== targetSceneName) {
                logMessage(`Ensuring source '${effectiveSourceName}' is also in main default scene '${mainDefaultScene}'.`);
                try {
                    await sendRequest('GetSceneItemId', { sceneName: mainDefaultScene, sourceName: effectiveSourceName }, { suppressNotFound: true });
                } catch (e) { 
                     if (e.message.toLowerCase().includes("not found") || (e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"))){
                        const createCloneResponse = await sendRequest('CreateSceneItem', { sceneName: mainDefaultScene, sourceName: effectiveSourceName });
                        clonedSceneItemId = createCloneResponse.sceneItemId; 
                        logMessage(`Added source '${effectiveSourceName}' as item to main default scene '${mainDefaultScene}'.`);
                     } else { throw e;}
                }
            }

            if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = true;

            if (initialSceneItemId) await applyTransformAndGrid(targetSceneName, effectiveSourceName, canvasWidth, canvasHeight, initialSceneItemId);
            if (clonedSceneItemId) await applyTransformAndGrid(mainDefaultScene, effectiveSourceName, canvasWidth, canvasHeight, clonedSceneItemId);

            const otherSceneCheckboxes = document.querySelectorAll('#otherScenesList .other-scene-checkbox:checked');
            for (const checkbox of otherSceneCheckboxes) {
                const otherSceneName = checkbox.value;
                if (otherSceneName && otherSceneName !== targetSceneName && (!shouldCloneThisStreamToMain || otherSceneName !== mainDefaultScene)) { 
                    try {
                        await sendRequest('GetSceneItemId', { sceneName: otherSceneName, sourceName: effectiveSourceName }, { suppressNotFound: true });
                    } catch (e) { 
                        if (e.message.toLowerCase().includes("not found") || (e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"))){
                            logMessage(`Adding source '${effectiveSourceName}' as reference to other scene '${otherSceneName}'.`);
                            const createItemResponse = await sendRequest('CreateSceneItem', { sceneName: otherSceneName, sourceName: effectiveSourceName });
                            await applyTransformAndGrid(otherSceneName, effectiveSourceName, canvasWidth, canvasHeight, createItemResponse.sceneItemId);
                        } else { throw e;}
                    }
                }
            }
            
            if (shouldSwitchToThisScene && targetSceneName !== currentProgramSceneName) { 
                logMessage(`Switching to scene '${targetSceneName}' as per mapping rule.`);
                await sendRequest('SetCurrentProgramScene', { sceneName: targetSceneName });
            }

            if (screenShareId === streamId) {
                const reactionSourceName = `${getFullReactionPrefix()}_${streamId}:s`;
                 logMessage(`Stream ${streamId} was screen share, now added as camera. Removing old screen share source ${reactionSourceName}.`);
                await tryRemoveGlobalInput(reactionSourceName); 
                screenShareId = null; 
            }
            logMessage(`Successfully processed stream "${streamLabel}" (${streamId}).`);

        } catch (error) {
            logMessage(`Error managing stream '${effectiveSourceName}' ("${streamLabel}") in OBS: ${error.message}`);
            if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = false; 
        } finally {
            updateStreamList(); 
            if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
        }
      }
      
      async function removeStreamFromObs(streamId) { 
          if (!obsConnected || !obs) { 
              logMessage(`Cannot remove stream ${streamId} from OBS: Not connected to OBS.`); 
              return; 
          }

          const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
          const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
          logMessage(`"Remove from OBS" clicked for stream '${streamId}'. Base: '${baseSourceName}', Highlight: '${highlightedSourceName}'.`);

          const streamInfo = activeStreams[streamId];
          const currentLabel = streamInfo ? streamInfo.label : `Stream ${streamId}`;
    
          // 1. If this stream is currently highlighted, unhighlight it first.
          if (highlightedStreamId === streamId) {
              logMessage(`Stream ${streamId} is highlighted. Unhighlighting as part of full removal.`);
              const targetInfoForUnhighlight = getTargetSceneForStream(streamId, currentLabel); 
              await toggleHighlight(streamId, currentLabel, targetInfoForUnhighlight); 
          }

          // 2. Remove from all scenes first (both base and highlighted versions)
          logMessage(`Removing sources for stream ${streamId} from all scenes...`);
          try {
              const scenes = await sendRequest('GetSceneList');
              for (const scene of scenes.scenes) {
                  try {
                      // Remove base source from scene
                      await tryRemoveFromScene(baseSourceName, scene.sceneName);
                      // Remove highlighted source from scene (if exists)
                      await tryRemoveFromScene(highlightedSourceName, scene.sceneName);
                  } catch (e) {
                      logMessage(`Error removing sources from scene ${scene.sceneName}: ${e.message}`);
                  }
              }
          } catch (e) {
              logMessage(`Error getting scene list for removal: ${e.message}`);
          }

          // 3. Then remove the global inputs (with proper error handling)
          logMessage(`Attempting to remove global inputs for stream ${streamId}.`);

          try {
              await sendRequest('GetInputSettings', { inputName: baseSourceName }, { suppressNotFound: true });
              await tryRemoveGlobalInput(baseSourceName);
          } catch (e) {
              const isNotFound = e.message.toLowerCase().includes("not found") || 
                                (e.message.toLowerCase().includes("code") && 
                                (e.message.includes("600") || e.message.includes("INPUT_NOT_FOUND")));
              if (!isNotFound) {
                  logMessage(`Error checking/removing base source '${baseSourceName}': ${e.message}`);
              }
          }

          try {
              await sendRequest('GetInputSettings', { inputName: highlightedSourceName }, { suppressNotFound: true });
              await tryRemoveGlobalInput(highlightedSourceName);
          } catch (e) {
              const isNotFound = e.message.toLowerCase().includes("not found") || 
                                (e.message.toLowerCase().includes("code") && 
                                (e.message.includes("600") || e.message.includes("INPUT_NOT_FOUND")));
              if (!isNotFound) {
                  logMessage(`Error checking/removing highlighted source '${highlightedSourceName}': ${e.message}`);
              }
          }

          // 4. Remove screen share source if exists
          const reactionSourceName = `${getFullReactionPrefix()}_${streamId}:s`;
          logMessage(`Also attempting to remove associated screen share source '${reactionSourceName}' for stream ${streamId}.`);
          try {
              await sendRequest('GetInputSettings', { inputName: reactionSourceName }, { suppressNotFound: true });
              await tryRemoveGlobalInput(reactionSourceName);
          } catch (e) {
              const isNotFound = e.message.toLowerCase().includes("not found") || 
                                (e.message.toLowerCase().includes("code") && 
                                (e.message.includes("600") || e.message.includes("INPUT_NOT_FOUND")));
              if (!isNotFound) {
                  logMessage(`Error checking/removing screen share source '${reactionSourceName}': ${e.message}`);
              }
          }
    
          if (screenShareId === streamId) { 
              screenShareId = null; 
              logMessage(`Cleared global screen share ID as it was for stream ${streamId}.`);
          }
    
          // 5. Mark as not created in our local state (for the main camera source)
          if (activeStreams[streamId]) {
              activeStreams[streamId].sourceCreated = false;
          }
    
          // 6. Scene switching logic:
          if (!highlightedStreamId && !screenShareId) { 
              const defaultScene = getTargetScene();
              if (defaultScene && defaultScene !== currentProgramSceneName) {
                  logMessage(`All sources for ${streamId} removed, no other focus active. Switching to default scene '${defaultScene}'.`);
                  try { await sendRequest('SetCurrentProgramScene', { sceneName: defaultScene }); }
                  catch (e) { logMessage(`Error switching to default scene after full removal: ${e.message}`); }
              }
          }
    
          // 7. Update UI and save settings
          updateStreamList(); 
          if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
          saveSettings(); 
          logMessage(`Finished "Remove from OBS" for stream ${streamId}.`);
      }

      async function tryRemoveFromScene(sourceName, sceneName) { 
        if (!sceneName) { logMessage(`Cannot remove source '${sourceName}': Scene name not provided.`); return false; }
        try {
          const itemInfo = await sendRequest('GetSceneItemId', { sceneName: sceneName, sourceName: sourceName }, { suppressNotFound: true });
          if (itemInfo && itemInfo.sceneItemId) {
            await sendRequest('RemoveSceneItem', { sceneName: sceneName, sceneItemId: itemInfo.sceneItemId });
            logMessage(`Removed source item '${sourceName}' (ID: ${itemInfo.sceneItemId}) from scene '${sceneName}'.`);
            return true;
          }
          return false; 
        } catch (e) {
          if (!e.message.toLowerCase().includes("not found") && !(e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"))) {
            logMessage(`Error trying to remove source item '${sourceName}' from scene '${sceneName}': ${e.message}`);
          }
          return false;
        }
      }
      
      async function tryRemoveGlobalInput(inputName) { 
        logMessage(`tryRemoveGlobalInput: Attempting to remove input: '${inputName}'`);
        try {
            await sendRequest('RemoveInput', { inputName: inputName });
            logMessage(`Successfully sent RemoveInput request for '${inputName}'. OBS will confirm removal if it existed.`); 
        } catch (e) {
            const isNotFound = e.message.toLowerCase().includes("not found") || 
                               e.message.toLowerCase().includes("no source") || 
                               e.message.toLowerCase().includes("does not exist") ||
                               (e.message.toLowerCase().includes("code") && (e.message.includes("600") || e.message.includes("INPUT_NOT_FOUND")) ); 
            if (!isNotFound) { 
                logMessage(`Error removing global input '${inputName}': ${e.message}.`);
            } else {
                // logMessage(`Global input '${inputName}' not found for removal (or already removed). This is often expected.`);
            }
        }
      }
      
      async function toggleHighlight(clickedStreamId, clickedStreamLabel, clickedTargetInfo) { 
          if (!obsConnected || !obs) { logMessage("Cannot toggle highlight: Not connected to OBS."); return; }
          
          const previouslyGlobalHighlightedStreamId = highlightedStreamId; 
          const camPrefix = getFullCameraPrefix();
          const hlPrefix = getFullHighlightPrefix();
          let sceneChangedByThisAction = false;

          if (previouslyGlobalHighlightedStreamId && previouslyGlobalHighlightedStreamId !== clickedStreamId) {
              const oldHighlightedSourceName = `${hlPrefix}_${previouslyGlobalHighlightedStreamId}`;
              const oldOriginalSourceName = `${camPrefix}_${previouslyGlobalHighlightedStreamId}`;
              try {
                  await sendRequest('GetInputSettings', { inputName: oldHighlightedSourceName }, { suppressNotFound: true });
                  await sendRequest('SetInputName', { inputName: oldHighlightedSourceName, newInputName: oldOriginalSourceName });
                  logMessage(`Stream ${previouslyGlobalHighlightedStreamId} unhighlighted (renamed to ${oldOriginalSourceName}).`);
              } catch (e) { 
                  if (!e.message.toLowerCase().includes("not found") && !(e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"))) {
                      logMessage(`Error unhighlighting previous stream ${previouslyGlobalHighlightedStreamId} (from ${oldHighlightedSourceName}): ${e.message}`);
                  }
              }
          }

          const clickedOriginalSourceName = `${camPrefix}_${clickedStreamId}`;
          const clickedNewHighlightedSourceName = `${hlPrefix}_${clickedStreamId}`;

          if (previouslyGlobalHighlightedStreamId === clickedStreamId) { 
              try {
                  await sendRequest('GetInputSettings', { inputName: clickedNewHighlightedSourceName }, { suppressNotFound: true }); 
                  await sendRequest('SetInputName', { inputName: clickedNewHighlightedSourceName, newInputName: clickedOriginalSourceName });
                  highlightedStreamId = null; 
                  logMessage(`Stream ${clickedStreamId} unhighlighted (renamed to ${clickedOriginalSourceName}).`);
                  
                  if (!screenShareId) { 
                      const defaultScene = getTargetScene();
                      if (defaultScene && defaultScene !== currentProgramSceneName) {
                          logMessage(`Unhighlighted ${clickedStreamId}, no screen share active. Switching to default scene '${defaultScene}'.`);
                          await sendRequest('SetCurrentProgramScene', { sceneName: defaultScene });
                          sceneChangedByThisAction = true;
                      }
                  }
              } catch (e) {
                  const isNotFound = e.message.toLowerCase().includes("not found") || (e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"));
                  if (!isNotFound) logMessage(`Error unhighlighting ${clickedStreamId} (from ${clickedNewHighlightedSourceName}): ${e.message}`);
                  else highlightedStreamId = null; 
              }
          } else { 
              try {
                  await sendRequest('GetInputSettings', { inputName: clickedOriginalSourceName }, { suppressNotFound: true }); 
                  await sendRequest('SetInputName', { inputName: clickedOriginalSourceName, newInputName: clickedNewHighlightedSourceName });
                  highlightedStreamId = clickedStreamId; 
                  logMessage(`Stream ${clickedStreamId} highlighted (renamed to ${clickedNewHighlightedSourceName}).`);
                  
                  const targetHighlightScene = highlightSceneSelect.value;
                  if (targetHighlightScene && targetHighlightScene !== currentProgramSceneName) {
                      logMessage(`Highlighting ${clickedStreamId}. Switching to Highlight Scene '${targetHighlightScene}'.`);
                      await sendRequest('SetCurrentProgramScene', { sceneName: targetHighlightScene });
                      sceneChangedByThisAction = true;
                  }
              } catch (e) {
                  const isNotFound = e.message.toLowerCase().includes("not found") || (e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"));
                  if (!isNotFound) logMessage(`Error highlighting ${clickedStreamId} (from ${clickedOriginalSourceName}): ${e.message}`);
                  else { 
                      try {
                          await sendRequest('GetInputSettings', { inputName: clickedNewHighlightedSourceName }, { suppressNotFound: true });
                          highlightedStreamId = clickedStreamId; 
                          logMessage(`Stream ${clickedStreamId} appears to be already named ${clickedNewHighlightedSourceName}. State confirmed.`);
                          const targetHighlightScene = highlightSceneSelect.value;
                          if (targetHighlightScene && targetHighlightScene !== currentProgramSceneName) {
                            await sendRequest('SetCurrentProgramScene', { sceneName: targetHighlightScene });
                            sceneChangedByThisAction = true;
                          }
                      } catch (e2) { 
                           logMessage(`Cannot highlight ${clickedStreamId}: Neither ${clickedOriginalSourceName} nor ${clickedNewHighlightedSourceName} found.`);
                           if (highlightedStreamId === clickedStreamId) highlightedStreamId = null; 
                      }
                  }
              }
          }
          
          if (sourceSizingSelect.value === 'autoGrid') {
              const scenesToUpdate = new Set();
              if (clickedTargetInfo && clickedTargetInfo.scene) scenesToUpdate.add(clickedTargetInfo.scene);
              if (clickedTargetInfo && clickedTargetInfo.mapping?.cloneToMain && getTargetScene() && getTargetScene() !== clickedTargetInfo.scene) {
                  scenesToUpdate.add(getTargetScene());
              }
              for (const sceneName of scenesToUpdate) {
                  if (sceneName) setTimeout(() => rearrangeAllStreamsInScene(sceneName), 100); 
              }
          }
          updateStreamList(); 
          if (!sceneChangedByThisAction && currentProgramSceneName) { 
            await fetchAndRenderCurrentProgramScene(); 
          }
          saveSettings(); 
      }

      async function addScreenShareToObs(streamId, streamLabel) { 
          if (!obsConnected || !obs) { logMessage("Cannot add screen share: Not connected to OBS."); return; }
          
          const room = vdoNinjaRoomInput.value.trim();
          if (!room) { logMessage("Cannot add screen share: VDO.Ninja Room name required for screen share URL context."); return; }

          const previousGlobalScreenShareId = screenShareId; 
          screenShareId = streamId; 

          const width = parseInt(screenShareWidthInput.value) || 1920;
          const height = parseInt(screenShareHeightInput.value) || 1080;
          let targetSceneName = screenShareSceneSelect.value || getTargetScene(); 
          if (!targetSceneName) {
            logMessage("Cannot add screen share: Target OBS scene (specific or default) is required.");
            screenShareId = previousGlobalScreenShareId; 
            updateStreamList(); 
            return;
          }

          const sourceName = `${getFullReactionPrefix()}_${streamId}:s`; 
          const screenShareUrl = getVdoNinjaViewUrl(streamId, true); 

          const inputSettings = { url: screenShareUrl, width, height, fps: 30, reroute_audio: true, restart_when_active: false, shutdown: false };
          logMessage(`Adding/Updating screen share source '${sourceName}' (URL: ${screenShareUrl}) to scene '${targetSceneName}'`);
          let sceneChangedByThisAction = false;

          try {
              const sourcesResponse = await sendRequest('GetInputList', { inputKind: 'browser_source' }, { suppressNotFound: true });
              const existingOtherScreenShareSource = sourcesResponse.inputs.find(input =>
                  input.inputName.startsWith(getFullReactionPrefix() + '_') && input.inputName.endsWith(':s') &&
                  input.inputName !== sourceName 
              );

              if (existingOtherScreenShareSource) { 
                  logMessage(`Reconfiguring existing screen share source '${existingOtherScreenShareSource.inputName}' to be '${sourceName}'.`);
                  await sendRequest('SetInputSettings', { inputName: existingOtherScreenShareSource.inputName, inputSettings });
                  if (existingOtherScreenShareSource.inputName !== sourceName) {
                      await sendRequest('SetInputName', { inputName: existingOtherScreenShareSource.inputName, newInputName: sourceName });
                  }
                  try {
                     await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName }, { suppressNotFound: true });
                     const itemInfo = await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName }); 
                     await sendRequest('SetSceneItemEnabled', { sceneName: targetSceneName, sceneItemId: itemInfo.sceneItemId, sceneItemEnabled: true });
                  } catch (e) { 
                      if (e.message.toLowerCase().includes("not found") || (e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"))){
                         await sendRequest('CreateSceneItem', { sceneName: targetSceneName, sourceName: sourceName, sceneItemEnabled: true });
                      } else { throw e; }
                  }
              } else { 
                  const exactSourceExists = sourcesResponse.inputs.find(input => input.inputName === sourceName);
                  if (exactSourceExists) { 
                       await sendRequest('SetInputSettings', { inputName: sourceName, inputSettings }); 
                       try { 
                           await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName }, { suppressNotFound: true });
                           const itemInfo = await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName });
                           await sendRequest('SetSceneItemEnabled', { sceneName: targetSceneName, sceneItemId: itemInfo.sceneItemId, sceneItemEnabled: true });
                       } catch (e) { 
                           if (e.message.toLowerCase().includes("not found") || (e.message.toLowerCase().includes("code") && e.message.toLowerCase().includes("600"))){
                              await sendRequest('CreateSceneItem', { sceneName: targetSceneName, sourceName: sourceName, sceneItemEnabled: true });
                           } else { throw e; }
                       }
                  } else { 
                      await sendRequest('CreateInput', { sceneName: targetSceneName, inputName: sourceName, inputKind: 'browser_source', inputSettings, sceneItemEnabled: true });
                  }
              }

              let sceneItemId;
              try {
                  const itemInfo = await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName });
                  sceneItemId = itemInfo.sceneItemId;
                  const transform = calculateTransform('defaultSize', width, height, obsCanvasDimensions.baseWidth, obsCanvasDimensions.baseHeight); 
                  await sendRequest('SetSceneItemTransform', { sceneName: targetSceneName, sceneItemId: sceneItemId, sceneItemTransform: transform });
                  await sendRequest('SetSceneItemEnabled', { sceneName: targetSceneName, sceneItemId: sceneItemId, sceneItemEnabled: true }); 
              } catch(e){
                  logMessage(`Could not get scene item ID for screen share '${sourceName}' in '${targetSceneName}' to apply transform: ${e.message}`);
              }
              
              // Switch to the target scene for screen share
              if (targetSceneName && targetSceneName !== currentProgramSceneName) {
                  logMessage(`Screen share started for ${streamId}. Switching to scene '${targetSceneName}'.`);
                  await sendRequest('SetCurrentProgramScene', { sceneName: targetSceneName });
                  sceneChangedByThisAction = true;
              }
              logMessage(`Successfully configured screen share for stream ${streamId} ("${streamLabel}").`);

          } catch (error) {
            logMessage(`Error adding/updating screen share source '${sourceName}': ${error.message}.`);
            screenShareId = previousGlobalScreenShareId; 
          } finally {
            updateStreamList(); 
            if (!sceneChangedByThisAction && currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
          }
      }

      async function removeScreenShareFromObs(streamIdToRemove) { 
          if (!obsConnected || !obs || !streamIdToRemove) {
            if(screenShareId === streamIdToRemove) screenShareId = null; 
            updateStreamList();
            if (obsConnected && currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
            return;
          }

          const sourceName = `${getFullReactionPrefix()}_${streamIdToRemove}:s`;
          logMessage(`Removing screen share source '${sourceName}' from OBS.`);
          let sceneChangedByThisAction = false;

          try {
              await tryRemoveGlobalInput(sourceName); 
          } catch (error) {
              logMessage(`Error during screen share removal process for '${sourceName}': ${error.message}`);
          } finally {
              if (screenShareId === streamIdToRemove) {
                  screenShareId = null; 
                  // If stopping screen share and nothing is highlighted, switch to default scene
                  if (!highlightedStreamId) {
                      const defaultScene = getTargetScene();
                      if (defaultScene && defaultScene !== currentProgramSceneName) {
                          logMessage(`Screen share stopped for ${streamIdToRemove}, nothing highlighted. Switching to default scene '${defaultScene}'.`);
                          try { 
                              await sendRequest('SetCurrentProgramScene', { sceneName: defaultScene });
                              sceneChangedByThisAction = true;
                          } catch (e) { logMessage(`Error switching to default scene: ${e.message}`); }
                      }
                  }
              }
              updateStreamList(); 
              if (!sceneChangedByThisAction && currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
          }
      }

      // --- Visualization Core Functions ---
      async function fetchObsVideoSettings() {
        if (!obsConnected) { logMessage("Cannot fetch video settings: OBS not connected."); return; }
        try {
          const settings = await sendRequest('GetVideoSettings');
          obsCanvasDimensions = {
            baseWidth: settings.baseWidth || 1920,
            baseHeight: settings.baseHeight || 1080
          };
          if (canvasDimensionsText) canvasDimensionsText.textContent = `${obsCanvasDimensions.baseWidth}x${obsCanvasDimensions.baseHeight}`;
        } catch (error) {
          logMessage(`Error fetching OBS video settings: ${error.message}. Using default ${obsCanvasDimensions.baseWidth}x${obsCanvasDimensions.baseHeight}.`);
        }
      }

      async function fetchAndRenderCurrentProgramScene() {
        if (!obsConnected || !mainSceneArea) { 
            if (mainSceneArea && !obsConnected) mainSceneArea.innerHTML = '<div style="text-align:center; padding:50px; color:#888;">OBS Disconnected.</div>';
            return; 
        }
        try {
          const sceneData = await sendRequest('GetCurrentProgramScene');
          currentProgramSceneName = sceneData.currentProgramSceneName; 
          if (currentSceneNameText) currentSceneNameText.textContent = currentProgramSceneName || '-';

          if (!currentProgramSceneName) {
            mainSceneArea.innerHTML = '<div style="text-align:center; padding:50px; color:#888;">No active program scene in OBS.</div>';
            currentSceneItemsData = {}; return;
          }

          const itemsResponse = await sendRequest('GetSceneItemList', { sceneName: currentProgramSceneName });
          const newSceneItemsData = {};

          for (const item of itemsResponse.sceneItems) {
            try {
              const transformResponse = await sendRequest('GetSceneItemTransform', { sceneName: currentProgramSceneName, sceneItemId: item.sceneItemId });
              const enabledResponse = await sendRequest('GetSceneItemEnabled', { sceneName: currentProgramSceneName, sceneItemId: item.sceneItemId });
              const cropInfo = {
                top: transformResponse.sceneItemTransform.cropTop || 0,
                bottom: transformResponse.sceneItemTransform.cropBottom || 0,
                left: transformResponse.sceneItemTransform.cropLeft || 0,
                right: transformResponse.sceneItemTransform.cropRight || 0
              };
              const vdoInfo = getVdoNinjaInfoFromSourceName(item.sourceName);
              newSceneItemsData[item.sceneItemId] = {
                id: item.sceneItemId,
                sourceName: item.sourceName,
                inputKind: item.inputKind || 'unknown', 
                transform: transformResponse.sceneItemTransform,
                crop: cropInfo,
                sceneItemEnabled: enabledResponse.sceneItemEnabled,
                isVdoNinjaCam: vdoInfo.isVdoNinjaCam,
                isVdoNinjaScreenShare: vdoInfo.isVdoNinjaScreenShare,
                streamId: vdoInfo.streamId,
                isHighlighted: (vdoInfo.isVdoNinjaCam && highlightedStreamId === vdoInfo.streamId),
                // isMainStream: (vdoInfo.isVdoNinjaCam && mainStreamId === vdoInfo.streamId) // Removed
              };
            } catch (itemError) {
              logMessage(`Error fetching details for item ${item.sourceName} (ID: ${item.sceneItemId}) in scene '${currentProgramSceneName}': ${itemError.message}`);
            }
          }
          currentSceneItemsData = newSceneItemsData;
          renderSceneVisualization();
        } catch (error) {
          logMessage(`Error fetching current program scene details: ${error.message}`);
          if (mainSceneArea) mainSceneArea.innerHTML = `<div style="text-align:center; padding:50px; color:#888;">Error loading scene: ${error.message}</div>`;
          currentSceneItemsData = {}; 
        }
      }

      function renderSceneVisualization() {
        if (!mainSceneArea) return;
        mainSceneArea.innerHTML = ''; 

        const { baseWidth: canvasW, baseHeight: canvasH } = obsCanvasDimensions;
        const areaW = mainSceneArea.clientWidth;
        const areaH = mainSceneArea.clientHeight;

        if (areaW === 0 || areaH === 0) { return; }

        const scaleX = areaW / canvasW;
        const scaleY = areaH / canvasH;
        const scale = Math.min(scaleX, scaleY); 

        const scaledCanvasWidth = canvasW * scale;
        const scaledCanvasHeight = canvasH * scale;
        const offsetX = (areaW - scaledCanvasWidth) / 2;
        const offsetY = (areaH - scaledCanvasHeight) / 2;

        for (const itemId in currentSceneItemsData) {
          const item = currentSceneItemsData[itemId];
          const div = document.createElement('div');
          div.className = 'scene-item-visual';
          div.id = `vis-item-${itemId}`;
          for (const streamId in activeStreams) {
              if (activeStreams[streamId].sourceCreated) { 
                  const stream = activeStreams[streamId];
                  if (streamId == item.streamId){item.label = stream.label}}}
          div.title = `${item.sourceName}\nType: ${item.inputKind}\nEnabled: ${item.sceneItemEnabled}\nID: ${item.id}\nStreamID: ${item.streamId || 'N/A'}\nCrop: T${item.crop.top} B${item.crop.bottom} L${item.crop.left} R${item.crop.right}`;


          const itemTransform = item.transform;
          const visibleWidth = item.transform.width - item.crop.left - item.crop.right;
          const visibleHeight = item.transform.height - item.crop.top - item.crop.bottom;

          let itemDisplayWidth = visibleWidth * scale;
          let itemDisplayHeight = visibleHeight * scale;

          let itemDisplayX = (item.transform.positionX) * scale + offsetX;
          let itemDisplayY = (item.transform.positionY) * scale + offsetY;

          div.style.width = `${Math.max(itemDisplayWidth, 10)}px`; 
          div.style.height = `${Math.max(itemDisplayHeight, 10)}px`; 
          div.style.left = `${itemDisplayX}px`;
          div.style.top = `${itemDisplayY}px`;

          if (item.crop.top > 0 || item.crop.bottom > 0 || item.crop.left > 0 || item.crop.right > 0) {
              const cropOverlay = document.createElement('div');
              cropOverlay.className = 'crop-overlay';
              cropOverlay.style.position = 'absolute';
              cropOverlay.style.top = '0';
              cropOverlay.style.left = '0';
              cropOverlay.style.width = '100%';
              cropOverlay.style.height = '100%';
              cropOverlay.style.borderStyle = 'dashed';
              cropOverlay.style.borderWidth = '1px';
              cropOverlay.style.borderColor = 'rgba(255, 255, 255, 0.5)';
              cropOverlay.style.pointerEvents = 'none';
              div.appendChild(cropOverlay);
          }
          const nameSpan = document.createElement('div');
          nameSpan.className = 'item-name';
          nameSpan.textContent = item.label;
          const kindSpan = document.createElement('div');
          kindSpan.className = 'item-kind';
          kindSpan.textContent = `(${item.inputKind || 'N/A'})`;
          div.appendChild(nameSpan);
          div.appendChild(kindSpan);

          if (!item.sceneItemEnabled) div.classList.add('not-visible');
          
          if (item.isVdoNinjaCam) {
            div.classList.add('vdo-camera');
            div.dataset.streamId = item.streamId; 
            div.dataset.sourceName = item.sourceName; 
            if (item.isHighlighted) div.classList.add('highlighted');
            // if (item.isMainStream) div.classList.add('main-stream-active'); // Removed
            div.addEventListener('contextmenu', handleSceneItemContextMenu);
          } else if (item.isVdoNinjaScreenShare) {
            div.classList.add('vdo-screenshare');
            div.dataset.streamId = item.streamId; 
            div.dataset.sourceName = item.sourceName;
          }
          mainSceneArea.appendChild(div);
        }
      }

      function getVdoNinjaInfoFromSourceName(sourceName) { 
        const cameraPrefixVal = getFullCameraPrefix();
        const highlightPrefixVal = getFullHighlightPrefix();
        const reactionPrefixVal = getFullReactionPrefix();

        let isVdoNinjaCam = false;
        let isVdoNinjaScreenShare = false;
        let streamId = null;

        if (sourceName.startsWith(highlightPrefixVal + "_")) { 
          isVdoNinjaCam = true; 
          streamId = sourceName.substring((highlightPrefixVal + "_").length);
        } else if (sourceName.startsWith(cameraPrefixVal + "_")) {
          isVdoNinjaCam = true;
          streamId = sourceName.substring((cameraPrefixVal + "_").length);
        } else if (sourceName.startsWith(reactionPrefixVal + "_") && sourceName.endsWith(":s")) { 
          isVdoNinjaScreenShare = true;
          streamId = sourceName.substring((reactionPrefixVal + "_").length, sourceName.length - 2); 
        }
        return { isVdoNinjaCam, isVdoNinjaScreenShare, streamId };
      }

      // --- Context Menu Functions ---
      function handleSceneItemContextMenu(event) {
        event.preventDefault();
        closeActiveContextMenu(); 

        activeContextMenuTarget = event.currentTarget; 
        const streamId = activeContextMenuTarget.dataset.streamId;
        const sourceName = activeContextMenuTarget.dataset.sourceName; 

        if (!streamId || !activeStreams[streamId]) {
          logMessage(`Context menu: Stream ID '${streamId}' not found in active VDO.Ninja streams or sourceName missing.`);
          return;
        }

        const streamDataFromNinja = activeStreams[streamId]; 
        let isSourceInObs = false; 
        let isCurrentlyHighlighted = (highlightedStreamId === streamId); 
        let isCurrentlyScreenSharing = (screenShareId === streamId); 

        for (const itemId in currentSceneItemsData) {
            const sceneItem = currentSceneItemsData[itemId];
            if (sceneItem.streamId === streamId && sceneItem.sourceName === sourceName) { 
                isSourceInObs = true; 
                break; 
            }
        }
        if (!isSourceInObs) isSourceInObs = streamDataFromNinja.sourceCreated; 

        sceneItemContextMenu.style.left = `${event.pageX}px`;
        sceneItemContextMenu.style.top = `${event.pageY}px`;
        sceneItemContextMenu.innerHTML = ''; 

        const ul = document.createElement('ul');

        const highlightOpt = document.createElement('li');
        highlightOpt.textContent = isCurrentlyHighlighted ? 'Unhighlight Stream' : 'Highlight Stream';
        highlightOpt.onclick = async () => {
          closeActiveContextMenu();
          const targetInfo = getTargetSceneForStream(streamId, streamDataFromNinja.label); 
          await toggleHighlight(streamId, streamDataFromNinja.label, targetInfo); 
        };
        ul.appendChild(highlightOpt);

        const streamActionOpt = document.createElement('li');
        streamActionOpt.textContent = isCurrentlyScreenSharing ? 'Stop Stream (Screen Share)' : 'Stream (Screen Share)';
        streamActionOpt.onclick = async () => {
            closeActiveContextMenu();
            let sceneChanged = false;
            if (isCurrentlyScreenSharing) { // Stop Stream action
                await removeScreenShareFromObs(streamId); // This will only remove the screen share source
                // After stopping, if nothing else is highlighted, switch to default scene
                if (!highlightedStreamId) {
                    const defaultScene = getTargetScene();
                    if (defaultScene && defaultScene !== currentProgramSceneName) {
                        logMessage(`Screen share stopped for ${streamId}, nothing highlighted. Switching to default scene '${defaultScene}'.`);
                        try { await sendRequest('SetCurrentProgramScene', { sceneName: defaultScene }); sceneChanged = true; }
                        catch (e) { logMessage(`Error switching to default scene: ${e.message}`); }
                    }
                }
            } else { // Start Stream action
                await addScreenShareToObs(streamId, streamDataFromNinja.label); 
                // addScreenShareToObs handles switching to the screenShareSceneSelect or default scene
            }
            updateStreamList(); 
            if (!sceneChanged && currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
        };
        ul.appendChild(streamActionOpt);
        
        ul.appendChild(document.createElement('hr')); 

        const closeOpt = document.createElement('li');
        closeOpt.textContent = '✖ Close Menu';
        closeOpt.onclick = closeActiveContextMenu;
        ul.appendChild(closeOpt);

        sceneItemContextMenu.appendChild(ul);
        sceneItemContextMenu.style.display = 'block';

        document.addEventListener('click', closeActiveContextMenuOnClickOutside, true);
      }

      function closeActiveContextMenu() {
        if (sceneItemContextMenu) sceneItemContextMenu.style.display = 'none';
        activeContextMenuTarget = null;
        document.removeEventListener('click', closeActiveContextMenuOnClickOutside, true);
      }

      function closeActiveContextMenuOnClickOutside(event) {
        if (sceneItemContextMenu && sceneItemContextMenu.style.display === 'block' && !sceneItemContextMenu.contains(event.target) && event.target !== activeContextMenuTarget && (!activeContextMenuTarget || !activeContextMenuTarget.contains(event.target))) {
          closeActiveContextMenu();
        }
      }
      
      function loadJsShaLibrary() { 
        return new Promise((resolve, reject) => {
            if (typeof jsSHA !== 'undefined') { resolve(); return; } 
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jsSHA/2.4.2/sha.js'; 
            script.onload = () => {
                logMessage("jsSHA library loaded successfully (fallback for Web Crypto).");
                resolve();
            };
            script.onerror = () => {
                logMessage("Error: Failed to load jsSHA library. OBS authentication might fail if Web Crypto is also unavailable.");
                reject(new Error('Failed to load jsSHA library for OBS authentication.'));
            };
            document.head.appendChild(script);
        });
      }
      
      // --- Transform and Grid Logic ---
      async function applyTransformAndGrid(sceneName, sourceName, canvasWidth, canvasHeight, sceneItemId = null) {
        if (!sceneName || !sourceName) { logMessage(`applyTransformAndGrid: Missing sceneName or sourceName.`); return; }
        let itemIdToTransform = sceneItemId;

        if (!itemIdToTransform) { 
            try {
                const itemInfo = await sendRequest('GetSceneItemId', { sceneName, sourceName }, { suppressNotFound: true });
                if (itemInfo && itemInfo.sceneItemId) itemIdToTransform = itemInfo.sceneItemId;
                else { logMessage(`Could not find scene item ID for '${sourceName}' in '${sceneName}'. Cannot apply transform.`); return; }
            } catch (error) {
                 const isNotFound = error.message.toLowerCase().includes("not found") || (error.message.toLowerCase().includes("code") && error.message.toLowerCase().includes("600"));
                 if (!isNotFound) logMessage(`Error fetching scene item ID for transform of '${sourceName}' in '${sceneName}': ${error.message}.`);
                 return; 
            }
        }
        if (!itemIdToTransform) return; 

        if (sourceSizingSelect.value === 'autoGrid') {
            await rearrangeAllStreamsInScene(sceneName); 
        } else { 
            try {
                const transform = calculateTransform(sourceSizingSelect.value, canvasWidth, canvasHeight, canvasWidth, canvasHeight); 
                await sendRequest('SetSceneItemTransform', { sceneName, sceneItemId: itemIdToTransform, sceneItemTransform: transform });
            } catch (error) {
                logMessage(`Error applying non-grid transform to '${sourceName}' (Item ID: ${itemIdToTransform}) in '${sceneName}': ${error.message}`);
            }
        }
      }

      async function rearrangeAllStreamsInScene(sceneName) {
        if (!obsConnected || !obs || !sceneName || sourceSizingSelect.value !== 'autoGrid') {
          if (sourceSizingSelect.value !== 'autoGrid' && sceneName) { return; }
          if (!obsConnected || !sceneName) {logMessage(`Cannot rearrange streams in scene '${sceneName}': OBS not connected or scene name missing.`); return;}
        }

        try {
            const sceneItemsResponse = await sendRequest('GetSceneItemList', { sceneName });
            const camPrefixWithUnderscore = getFullCameraPrefix() + "_";
            const hlPrefixWithUnderscore = getFullHighlightPrefix() + "_";

            const vdoNinjaSourcesInScene = sceneItemsResponse.sceneItems.filter(item => {
                const isRegularCam = item.sourceName.startsWith(camPrefixWithUnderscore);
                const isHighlightedCam = item.sourceName.startsWith(hlPrefixWithUnderscore);
                let streamIdFromSource = null;
                if (isHighlightedCam) streamIdFromSource = item.sourceName.substring(hlPrefixWithUnderscore.length);
                else if (isRegularCam) streamIdFromSource = item.sourceName.substring(camPrefixWithUnderscore.length);
                
                return (isRegularCam || isHighlightedCam) && 
                       streamIdFromSource && 
                       activeStreams[streamIdFromSource] && 
                       activeStreams[streamIdFromSource].connected && 
                       activeStreams[streamIdFromSource].sourceCreated; 
            });

            if (vdoNinjaSourcesInScene.length === 0) { return; }

            vdoNinjaSourcesInScene.sort((a, b) => {
                const aIsHighlighted = highlightedStreamId === getVdoNinjaInfoFromSourceName(a.sourceName).streamId;
                const bIsHighlighted = highlightedStreamId === getVdoNinjaInfoFromSourceName(b.sourceName).streamId;
                if (aIsHighlighted && !bIsHighlighted) return -1;
                if (!aIsHighlighted && bIsHighlighted) return 1;
                return (getVdoNinjaInfoFromSourceName(a.sourceName).streamId || '').localeCompare(getVdoNinjaInfoFromSourceName(b.sourceName).streamId || '');
            });

            const positions = calculateGridPositions(vdoNinjaSourcesInScene.length, obsCanvasDimensions.baseWidth, obsCanvasDimensions.baseHeight);

            for (let i = 0; i < vdoNinjaSourcesInScene.length; i++) {
                const item = vdoNinjaSourcesInScene[i];
                const gridPos = positions[i];
                if (gridPos) { 
                    const transform = calculateTransform('autoGrid', obsCanvasDimensions.baseWidth, obsCanvasDimensions.baseHeight, obsCanvasDimensions.baseWidth, obsCanvasDimensions.baseHeight, gridPos);
                    await sendRequest('SetSceneItemTransform', { sceneName, sceneItemId: item.sceneItemId, sceneItemTransform: transform });
                }
            }
        } catch (error) {
            logMessage(`Error rearranging streams in scene '${sceneName}': ${error.message}`);
        }
        if (sceneName === currentProgramSceneName) {
             await fetchAndRenderCurrentProgramScene();
        }
      }

      function calculateTransform(sizingMode, sourceWidth, sourceHeight, canvasWidth, canvasHeight, gridPosition = null) {
        let transform = { 
            alignment: 5, 
            boundsType: "OBS_BOUNDS_NONE", 
            boundsAlignment: 0, 
            boundsWidth: sourceWidth, 
            boundsHeight: sourceHeight,
            positionX: 0, 
            positionY: 0,
            scaleX: 1.0, 
            scaleY: 1.0,
            rotation: 0.0,
            cropTop: 0, cropBottom: 0, cropLeft: 0, cropRight: 0,
            sourceWidth: sourceWidth, 
            sourceHeight: sourceHeight,
            width: sourceWidth, 
            height: sourceHeight 
        };

        switch (sizingMode) {
            case 'defaultSize': 
                transform.positionX = (canvasWidth - sourceWidth) / 2;
                transform.positionY = (canvasHeight - sourceHeight) / 2;
                transform.width = sourceWidth;
                transform.height = sourceHeight;
                if (sourceWidth > canvasWidth || sourceHeight > canvasHeight) {
                    transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; 
                    transform.boundsWidth = canvasWidth;
                    transform.boundsHeight = canvasHeight;
                }
                break;
            case 'bestFit': 
                transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
                transform.boundsWidth = canvasWidth;
                transform.boundsHeight = canvasHeight;
                transform.positionX = 0; 
                transform.positionY = 0;
                transform.width = canvasWidth; 
                transform.height = canvasHeight;
                break;
            case 'stretchToFill': 
                transform.boundsType = "OBS_BOUNDS_STRETCH";
                transform.boundsWidth = canvasWidth;
                transform.boundsHeight = canvasHeight;
                transform.positionX = 0;
                transform.positionY = 0;
                transform.width = canvasWidth;
                transform.height = canvasHeight;
                break;
            case 'autoGrid':
                if (gridPosition) {
                    transform.positionX = gridPosition.x;
                    transform.positionY = gridPosition.y;
                    transform.width = gridPosition.width;
                    transform.height = gridPosition.height;
                    transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; 
                    transform.boundsWidth = gridPosition.width;
                    transform.boundsHeight = gridPosition.height;
                } else { 
                    logMessage("Warning: autoGrid sizing mode called without gridPosition. Applying 'bestFit' to canvas.");
                    transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
                    transform.boundsWidth = canvasWidth; transform.boundsHeight = canvasHeight;
                    transform.width = canvasWidth; transform.height = canvasHeight;
                    transform.positionX = 0; transform.positionY = 0;
                }
                break;
            default: 
                 transform.positionX = (canvasWidth - sourceWidth) / 2;
                 transform.positionY = (canvasHeight - sourceHeight) / 2;
                 transform.width = sourceWidth;
                 transform.height = sourceHeight;
                 if (sourceWidth > canvasWidth || sourceHeight > canvasHeight) {
                    transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
                    transform.boundsWidth = canvasWidth;
                    transform.boundsHeight = canvasHeight;
                }
                break;
        }
        return transform;
      }
      
      async function applyStandardTransformToAllManagedStreamsInScene(sceneName) { 
        if (!obsConnected || !sceneName || sourceSizingSelect.value === 'autoGrid') return;

        try {
            const sceneItemsResponse = await sendRequest('GetSceneItemList', { sceneName: sceneName });
            const camPrefixWithUnderscore = getFullCameraPrefix() + "_";
            const hlPrefixWithUnderscore = getFullHighlightPrefix() + "_";

            for (const item of sceneItemsResponse.sceneItems) {
                const isManagedSource = (item.sourceName.startsWith(camPrefixWithUnderscore) || item.sourceName.startsWith(hlPrefixWithUnderscore)) &&
                                        (item.inputKind === 'browser_source'); 
                
                if (isManagedSource) {
                    const vdoInfo = getVdoNinjaInfoFromSourceName(item.sourceName);
                    if (activeStreams[vdoInfo.streamId] && activeStreams[vdoInfo.streamId].sourceCreated) { 
                        const transform = calculateTransform(sourceSizingSelect.value, obsCanvasDimensions.baseWidth, obsCanvasDimensions.baseHeight, obsCanvasDimensions.baseWidth, obsCanvasDimensions.baseHeight);
                        await sendRequest('SetSceneItemTransform', { sceneName, sceneItemId: item.sceneItemId, sceneItemTransform: transform });
                    }
                }
            }
        } catch (error) {
            logMessage(`Error applying standard transform in scene '${sceneName}': ${error.message}`);
        }
        if (sceneName === currentProgramSceneName) {
            await fetchAndRenderCurrentProgramScene(); 
        }
    }


      // --- Event Listeners for UI elements ---
      obsSceneSelect.addEventListener('change', async () => { 
        obsSceneNameInput.value = obsSceneSelect.value; 
        saveSettings();
        updateOtherScenesList(); 
        updateStreamList(); 
        if (obsConnected) {
            if (sourceSizingSelect.value === 'autoGrid' && getTargetScene()) {
              await rearrangeAllStreamsInScene(getTargetScene());
            }
            if (obsSceneSelect.value === currentProgramSceneName) {
                await fetchAndRenderCurrentProgramScene();
            }
        }
      });
      
      [ obsWsUrlInput, obsWsPasswordInput, vdoNinjaBaseUrlInput, vdoNinjaRoomInput, 
        vdoNinjaPasswordInput, vdoNinjaStreamIdsInput, autoAddSourcesCheckbox, 
        autoRemoveSourcesCheckbox, screenShareSceneSelect, highlightSceneSelect, /*streamSceneSelect,*/ // streamSceneSelect removed
        screenShareWidthInput, screenShareHeightInput
      ].forEach(el => {
        if (el) el.addEventListener('change', saveSettings);
      });

      sourceSizingSelect.addEventListener('change', async () => { 
        saveSettings();
        if (obsConnected) {
            const mainTargetScene = getTargetScene();
            if (sourceSizingSelect.value === 'autoGrid') {
                if (mainTargetScene) await rearrangeAllStreamsInScene(mainTargetScene);
            } else {
                if (mainTargetScene) await applyStandardTransformToAllManagedStreamsInScene(mainTargetScene);
            }
            if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
        }
      });

      sourceCodecSelect.addEventListener('change', async () => { 
        saveSettings();
        if (obsConnected) {
            logMessage(`Codec changed to: ${sourceCodecSelect.value || 'none'}. Updating relevant OBS sources...`);
            for (const streamId in activeStreams) {
                if (activeStreams[streamId].sourceCreated) { 
                    const stream = activeStreams[streamId];
                    const targetInfo = getTargetSceneForStream(streamId, stream.label);
                    await addStreamToObs(streamId, stream.label, targetInfo); 
                }
            }
            if (screenShareId && activeStreams[screenShareId]) {
                await addScreenShareToObs(screenShareId, activeStreams[screenShareId].label);
            }
            logMessage("Codec update for OBS sources complete.");
            if (currentProgramSceneName) await fetchAndRenderCurrentProgramScene(); 
        }
      });

      loadScenesBtn.addEventListener('click', async () => { 
        await fetchObsScenes(); 
        if(obsConnected && currentProgramSceneName) {
            await fetchAndRenderCurrentProgramScene(); 
        }
      });


      // --- Initial Load and Setup ---
      document.addEventListener('DOMContentLoaded', () => {
        const sidebarIsCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
        if (sidebar) {
             sidebar.classList.toggle('collapsed', sidebarIsCollapsed);
             document.body.classList.toggle('sidebar-collapsed', sidebarIsCollapsed);
        }

        loadSettings(); 
        logMessage("VDO.Ninja OBS Control Dock Initialized (Enhanced v4.2).");
        updateVdoNinjaButtonState(false); 
        toggleVdoNinjaInputs(false); 

        const secureFields = document.querySelectorAll('#vdoNinjaRoom, #vdoNinjaStreamIds, #vdoNinjaPassword');
        secureFields.forEach(field => {
          field.classList.add('blur-field');
          field.addEventListener('focus', () => field.classList.remove('blur-field'));
          field.addEventListener('blur', () => { if (field.value === '') field.classList.add('blur-field'); });
          if (field.value !== '') field.classList.remove('blur-field'); 
        });

        startVdoNinjaConnectionMonitor();
        updatePrefixLabels(); 
        updateStreamList(); 

        if (mainSceneArea) mainSceneArea.innerHTML = '<div style="text-align:center; padding:50px; color:#888;">Connect to OBS to see scene visualization.</div>';
        
        window.addEventListener('resize', () => {
            if (obsConnected && currentProgramSceneName) {
                renderSceneVisualization(); 
            }
        });
      });
    </script>
  </body>
</html>
