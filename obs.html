<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VDO.Ninja OBS Control Dock</title>
    <style>
      body {
          font-family: sans-serif;
          margin: 5px;
          background-color: #13141A;
          color: #e0e0e0;
          font-size: 13px;
      }
      .container {
          margin-bottom: 10px;
          padding: 8px;
          background-color: #272A33;
          border-radius: 5px;
          border: 1px solid #3a3a48;
      }
      .collapsible {
          cursor: pointer;
          user-select: none;
          padding: 8px 0;
          position: relative;
          font-weight: bold;
          background: rgba(255,255,255,0.03);
          margin: -8px -8px 8px -8px;
          padding-left: 12px;
          border-bottom: 1px solid #3a3a48;
      }
      .collapsible::after {
          content: '▼';
          position: absolute;
          right: 12px;
          font-size: 12px;
          color: #8a8a9a;
          transition: transform 0.2s ease;
      }
      .collapsible.collapsed::after {
          content: '►';
          transform: none;
      }
      .collapsible:hover {
          background: rgba(255,255,255,0.08);
      }
      .collapsible::before {
          content: 'Click to ' attr(data-state);
          position: absolute;
          right: 30px;
          font-size: 10px;
          color: #666;
          font-weight: normal;
      }
      .collapsible[data-state="expand"]::before {
          content: 'Click to expand';
      }
      .collapsible[data-state="collapse"]::before {
          content: 'Click to collapse';
      }
      .collapsible-content {
          max-height: 1000px;
          overflow: hidden;
          transition: max-height 0.2s ease-out;
          padding-top: 5px;
      }
      .collapsible-content.collapsed {
          max-height: 0;
          padding-top: 0;
      }
      label {
          display: block;
          margin-bottom: 5px;
      }
      input[type="text"], input[type="password"], input[type="number"], select {
          width: calc(100% - 16px);
          padding: 5px;
          margin-bottom: 8px;
          border: 1px solid #424254;
          border-radius: 3px;
          background-color: #3C404D;
          color: #e0e0e0;
      }
      select {
          padding: 6px 5px;
          height: auto;
      }
      button {
          padding: 6px 10px;
          background-color: #3C404D;
          color: white;
          border: none;
          border-radius: 3px;
          cursor: pointer;
          margin-right: 3px;
          margin-bottom: 3px;
          font-size: 12px;
      }
      button.connected {
          background-color: #4C80AF;
      }
      button.disconnected {
          background-color: #484860;
      }
      button:hover {
          background-color: #5a5a7a;
      }
      .blur-field {
          filter: blur(5px);
          transition: filter 0.2s ease;
      }
      .blur-field:focus {
          filter: blur(0);
      }
      #vdoNinjaIframe {
          width: 1px;
          height: 1px;
          position: absolute;
          left: -1000px;
          top: -1000px;
          border: 0;
      }
      .log-area {
          height: 100px;
          background-color: #1a1a24;
          color: #ccc;
          border: 1px solid #424254;
          overflow-y: scroll;
          padding: 5px;
          font-family: monospace;
          font-size: 0.9em;
          margin-top: 5px;
          white-space: pre-wrap;
      }
      .status-indicator {
          display: inline-block;
          width: 8px;
          height: 8px;
          border-radius: 50%;
          margin-left: 5px;
          background-color: #555;
      }
      .status-indicator.connected {
          background-color: #4C80AF;
      }
      .status-indicator.error {
          background-color: #f44336;
      }
      .stream-list {
          background-color: #1a1a24;
          border: 1px solid #424254;
          border-radius: 3px;
          padding: 5px;
          margin-top: 3px;
          transition: max-height 0.3s ease;
      }
      .stream-list:empty {
          min-height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
      }
      .stream-item {
          padding: 4px;
          border-bottom: 1px solid #3c3c4a;
          font-size: 12px;
          word-break: break-word;
      }
      .stream-item:last-child {
          border-bottom: none;
      }
      h1, h2 {
          color: #c8c8c8;
          margin: 5px 0;
          font-size: 1.1em;
      }
      h1 {
          font-size: 1.2em;
      }
      small {
          color: #8a8a9a;
          font-size: 0.85em;
      }
      .add-stream-btn {
          background-color: #4C80AF;
          color: white;
          padding: 2px 4px;
          font-size: 11px;
      }
      .highlight-btn {
          padding: 2px 4px;
          color: white;
          cursor: pointer;
          font-size: 11px;
          transition: background-color 0.2s;
      }
      .screen-share-btn {
          background-color: #9C27B0;
          color: white;
          padding: 2px 4px;
          font-size: 11px;
      }
      .status-line {
          font-size: 12px;
          margin-top: 5px;
          display: flex;
          align-items: center;
      }
      input[type="checkbox"] {
          accent-color: #4C80AF;
          margin-right: 5px;
      }
      .checkbox-label {
          display: flex;
          align-items: center;
          margin-bottom: 3px;
      }
      .checkbox-label input {
          margin-right: 4px;
      }
      ::-webkit-scrollbar {
          width: 6px;
          height: 6px;
      }
      ::-webkit-scrollbar-track {
          background: #1a1a24;
          border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb {
          background: #3C404D;
          border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
          background: #4C80AF;
      }
      * {
          scrollbar-width: thin;
          scrollbar-color: #3C404D #1a1a24;
      }
      .flex-row {
          display: flex;
          gap: 4px;
          flex-wrap: wrap;
      }
      #obsSceneNameInput {
          display: none !important;
      }
      #loadScenesBtn {
          display: inline-block;
          margin-left: 5px;
          vertical-align: top;
      }
      .container:nth-child(6) .collapsible-content { /* Adjusted for new container holding Active Streams */
          max-height: none !important;
          overflow: visible !important;
      }
      .prefix-input-label {
        margin-bottom: 2px;
        display: block;
      }
      .prefix-group {
        margin-bottom: 8px;
      }
    </style>
  </head>
  <body>
    <h1>VDO.Ninja OBS Control</h1>

    <div class="container">
      <h2 class="collapsible" data-state="collapse">
        OBS WebSocket Connection
      </h2>
      <div class="collapsible-content">
        <label for="obsWsUrl">WebSocket URL:</label>
        <input type="text" id="obsWsUrl" value="ws://localhost:4455" />

        <label for="obsWsPassword">Password:</label>
        <input type="password" id="obsWsPassword" value="" />

        <label for="cameraPrefix" id="cameraSubPrefixLabelText" class="prefix-input-label">Camera prefix:</label>
        <input type="text" id="cameraPrefix" value="VDO_">

        <label for="reactionSubPrefix" id="reactionSubPrefixLabelText" class="prefix-input-label">Reaction prefix: VDO.</label>
        <input type="text" id="reactionSubPrefix" value="Screen_">

        <label for="highlightSubPrefix" id="highlightSubPrefixLabelText" class="prefix-input-label">Highlight prefix: VDO.</label>
        <input type="text" id="highlightSubPrefix" value="Highlight_">

        <div class="status-line">
          <button id="obsConnectBtn">Connect to OBS</button>
          <span id="obsConnectionStatus">Status: Disconnected</span>
          <span id="obsStatusIndicator" class="status-indicator"></span>
        </div>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="collapse">VDO.Ninja Settings</h2>
      <div class="collapsible-content">
        <label for="vdoNinjaBaseUrl">VDO.Ninja Base URL:</label>
        <input
          type="text"
          id="vdoNinjaBaseUrl"
          placeholder="https://vdo.ninja"
          value="https://vdo.ninja"
        />

        <label for="vdoNinjaRoom">Room Name:</label>
        <input
          type="text"
          id="vdoNinjaRoom"
          placeholder="e.g., MyNinjaRoom"
          class="blur-field"
        />

        <label for="vdoNinjaPassword">Password:</label>
        <input
          type="password"
          id="vdoNinjaPassword"
          placeholder="Room or &password"
        />

        <label for="vdoNinjaStreamIds">Stream IDs:</label>
        <input
          type="text"
          id="vdoNinjaStreamIds"
          placeholder="streamId1,streamId2"
          class="blur-field"
        />
        <small>Room Name or Stream ID(s) needed</small>
        </div>
    </div>
    
    <div class="container">
      <h2 class="collapsible" data-state="expand">Stream ID Mappings</h2>
      <div class="collapsible-content collapsed">
        <div id="streamMappingContainer">
          <div id="streamMappings">
            </div>
          <button id="addStreamMappingBtn">Add New Mapping</button>
        </div>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="expand">OBS Target Settings</h2>
      <div class="collapsible-content collapsed">
        <label for="obsSceneSelect">Target Scene:</label>
        <div style="display: flex; align-items: center; gap: 5px;">
          <select id="obsSceneSelect" style="flex: 1;">
            <option value="">Select a scene...</option>
          </select>
          <button id="loadScenesBtn">Re-Fetch Scenes</button>
        </div>
        
        <div
          id="otherScenesContainer"
          style="margin-top: 10px; border-top: 1px solid #3a3a48; padding-top: 10px; display: none;"
        >
          <label>Copy sources to other scenes (reference):</label>
          <div id="otherScenesList">
            </div>
        </div>
        <input type="text" id="obsSceneNameInput" style="display:none;" /> <div
          style="margin-top: 10px; border-top: 1px solid #3a3a48; padding-top: 10px;"
        >
          <label>Screen Sharing Settings:</label>
          <div style="display: flex; gap: 10px; margin-bottom: 8px;">
            <div>
              <label style="font-size: 11px;">Width:</label>
              <input
                type="number"
                id="screenShareWidth"
                value="1920"
                style="width: 80px;"
              />
            </div>
            <div>
              <label style="font-size: 11px;">Height:</label>
              <input
                type="number"
                id="screenShareHeight"
                value="1080"
                style="width: 80px;"
              />
            </div>
            <div>
              <label style="font-size: 11px;">Target Scene:</label>
              <select id="screenShareSceneSelect" style="width: 150px;">
                <option value="">Same as main</option>
                </select>
            </div>
          </div>
        </div>

        <label for="sourceSizing">New Source Sizing:</label>
        <select id="sourceSizing">
          <option value="defaultSize">Default (1920x1080 at 0,0)</option>
          <option value="bestFit">Best Fit (Preserve Aspect)</option>
          <option value="stretchToFill">Stretch to Fill Screen</option>
          <option value="autoGrid">Auto Grid Layout</option>
        </select>

        <div id="autoSourceOptions">
          <label class="checkbox-label">
            <input type="checkbox" id="autoAddSources" checked />
            Auto-add new streams as sources
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="autoRemoveSources" checked />
            Auto-remove sources on disconnect
          </label>
        </div>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="expand">Active Streams</h2>
      <div class="collapsible-content collapsed">
        <div id="streamList" class="stream-list">
          <div class="stream-item">No active streams</div>
        </div>
      </div>
    </div>

    <iframe
      id="vdoNinjaIframe"
      allow="encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;midi *;geolocation;camera *;microphone *;fullscreen;picture-in-picture;display-capture;accelerometer;autoplay;gyroscope;screen-wake-lock;"
    ></iframe>

    <div class="container">
      <h2 class="collapsible" data-state="expand">Log</h2>
      <div class="collapsible-content collapsed">
        <div id="logArea" class="log-area">
          </div>
      </div>
    </div>

    <script>
      // DOM elements
      const obsWsUrlInput = document.getElementById('obsWsUrl');
      const obsWsPasswordInput = document.getElementById('obsWsPassword');
      const obsConnectBtn = document.getElementById('obsConnectBtn');
      const obsConnectionStatus = document.getElementById('obsConnectionStatus');
      const obsStatusIndicator = document.getElementById('obsStatusIndicator');

      const cameraPrefixInput = document.getElementById('cameraPrefix');
      const reactionSubPrefixInput = document.getElementById('reactionSubPrefix');
      const highlightSubPrefixInput = document.getElementById('highlightSubPrefix');
      const cameraSubPrefixLabelText = document.getElementById('cameraSubPrefixLabelText'); // For dynamic label updates
      const reactionSubPrefixLabelText = document.getElementById('reactionSubPrefixLabelText'); // For dynamic label updates
      const highlightSubPrefixLabelText = document.getElementById('highlightSubPrefixLabelText'); // For dynamic label updates

      const vdoNinjaBaseUrlInput = document.getElementById('vdoNinjaBaseUrl');
      const vdoNinjaRoomInput = document.getElementById('vdoNinjaRoom');
      const vdoNinjaPasswordInput = document.getElementById('vdoNinjaPassword');
      const vdoNinjaStreamIdsInput = document.getElementById('vdoNinjaStreamIds');
      const vdoNinjaIframe = document.getElementById('vdoNinjaIframe');

      const obsSceneNameInput = document.getElementById('obsSceneNameInput'); // Hidden input, mirrors obsSceneSelect
      const obsSceneSelect = document.getElementById('obsSceneSelect');
      const sourceSizingSelect = document.getElementById('sourceSizing');
      const autoAddSourcesCheckbox = document.getElementById('autoAddSources');
      const autoRemoveSourcesCheckbox = document.getElementById('autoRemoveSources');
      const streamListContainer = document.getElementById('streamList');
      const logArea = document.getElementById('logArea');
      const loadScenesBtn = document.getElementById('loadScenesBtn');
      
      // State variables
      let obs = null; // WebSocket connection object for OBS
      let obsConnected = false; // Flag for OBS connection status
      let vdoNinjaConnected = false; // Flag for VDO.Ninja iframe connection status
      let activeStreams = {}; // Stores information about currently active VDO.Ninja streams
      let obsScenes = []; // Array to store fetched OBS scene names
      let requestCallbacks = {}; // Stores callbacks for OBS WebSocket requests

      let vdoNinjaLastActivityTime = 0; // Timestamp of the last message from VDO.Ninja iframe
      let vdoNinjaConnectionCheckTimer = null; // Timer for VDO.Ninja connection timeout

      let screenShareId = null; // Stream ID currently being screen shared
      let highlightedStreamId = null; // Stream ID currently highlighted
      let loadedSelectedOtherScenes = []; // Array to store selected "other scenes" from localStorage

      // Setup for collapsible UI sections
      document.querySelectorAll('.collapsible').forEach(header => {
          header.addEventListener('click', function() {
              this.classList.toggle('collapsed');
              const content = this.nextElementSibling;
              if (content.classList.contains('collapsible-content')) {
                  content.classList.toggle('collapsed');
                  // Update the data-state attribute for ARIA/styling
                  if (content.classList.contains('collapsed')) {
                      this.setAttribute('data-state', 'expand');
                  } else {
                      this.setAttribute('data-state', 'collapse');
                  }
              }
          });
      });

      // Create and inject VDO.Ninja connection controls dynamically
      const vdoNinjaConnectBtn = document.createElement('button');
      vdoNinjaConnectBtn.id = 'vdoNinjaConnectBtn';
      vdoNinjaConnectBtn.textContent = 'Connect to VDO.Ninja';
      vdoNinjaConnectBtn.style.marginTop = '5px';

      const vdoNinjaStatusIndicator = document.createElement('span');
      vdoNinjaStatusIndicator.id = 'vdoNinjaStatusIndicator';
      vdoNinjaStatusIndicator.className = 'status-indicator';

      const vdoNinjaConnectionStatus = document.createElement('span');
      vdoNinjaConnectionStatus.id = 'vdoNinjaConnectionStatus';
      vdoNinjaConnectionStatus.textContent = 'Status: Disconnected';
      vdoNinjaConnectionStatus.style.marginLeft = '5px';

      const vdoNinjaSettingsContainer = document.querySelector('.container:nth-child(2)'); // VDO.Ninja Settings container
      const buttonsDiv = document.createElement('div'); // Container for the VDO.Ninja connect button and status
      buttonsDiv.style.marginTop = '5px';
      buttonsDiv.className = 'status-line';
      buttonsDiv.appendChild(vdoNinjaConnectBtn);
      buttonsDiv.appendChild(vdoNinjaConnectionStatus);
      buttonsDiv.appendChild(vdoNinjaStatusIndicator);
      // Append to the VDO.Ninja settings collapsible content
      vdoNinjaSettingsContainer.querySelector('.collapsible-content').appendChild(buttonsDiv);

      // Event listener for VDO.Ninja connect/disconnect button
      vdoNinjaConnectBtn.addEventListener('click', () => {
          if (vdoNinjaConnected) {
              disconnectFromVdoNinja();
          } else {
              connectToVdoNinja();
          }
      });


      /**
       * Logs a message to the console and the on-screen log area.
       * @param {string} message - The message to log.
       */
      function logMessage(message) {
      	console.log(message); // Also log to browser console for more detailed debugging
      	const timestamp = new Date().toLocaleTimeString();
      	logArea.innerHTML += `[${timestamp}] ${message}\n`;
      	logArea.scrollTop = logArea.scrollHeight; // Auto-scroll to the latest message
      }

      /**
       * Generates a unique request ID for OBS WebSocket messages.
       * @param {string} type - A prefix for the request type (e.g., "GetSceneList").
       * @returns {string} A unique request ID.
       */
      function generateRequestId(type) {
      	return `${type}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      }

      /**
       * Gets the base URL for VDO.Ninja, defaulting if not set.
       * @returns {string} The VDO.Ninja base URL.
       */
      function getVdoNinjaBaseUrl() {
          const customUrl = vdoNinjaBaseUrlInput.value.trim();
          return customUrl || "https://vdo.ninja"; // Default VDO.Ninja URL
      }

      /**
       * Gets the full camera prefix from input.
       * @returns {string} The camera prefix.
       */
      function getFullCameraPrefix() { return cameraPrefixInput.value.trim(); }
      /**
       * Gets the full reaction prefix (camera prefix + reaction sub-prefix).
       * @returns {string} The full reaction prefix.
       */
      function getFullReactionPrefix() { return `${cameraPrefixInput.value.trim()}.${reactionSubPrefixInput.value.trim()}`; }
      /**
       * Gets the full highlight prefix (camera prefix + highlight sub-prefix).
       * @returns {string} The full highlight prefix.
       */
      function getFullHighlightPrefix() { return `${cameraPrefixInput.value.trim()}.${highlightSubPrefixInput.value.trim()}`; }

      /**
       * Updates the descriptive labels for prefixes next to their input fields.
       */
      function updatePrefixLabels() {
          const cameraPrefix = getFullCameraPrefix();
          const reactionPrefix = getFullReactionPrefix();
          const highlightPrefix = getFullHighlightPrefix();
          // Update the labels to show the current full prefix being used
          cameraSubPrefixLabelText.textContent = `Camera prefix: ${cameraPrefix || ''}${cameraPrefix ? '_' : ''}`; // Show (none) if empty
          reactionSubPrefixLabelText.textContent = `Reaction prefix: ${cameraPrefix || ''}${cameraPrefix ? '.' : ''}${reactionSubPrefixInput.value.trim() || ''}${reactionSubPrefixInput.value.trim() ? '_' : ''}`;
          highlightSubPrefixLabelText.textContent = `Highlight prefix: ${cameraPrefix || ''}${cameraPrefix ? '.' : ''}${highlightSubPrefixInput.value.trim() || ''}${highlightSubPrefixInput.value.trim() ? '_' : ''}`;
      }
      // Add event listeners to prefix inputs to update labels and save settings on change
      cameraPrefixInput.addEventListener('input', () => {
          updatePrefixLabels();
          saveSettings();
      });
      reactionSubPrefixInput.addEventListener('input', () => {
          updatePrefixLabels();
          saveSettings();
      });
      highlightSubPrefixInput.addEventListener('input', () => {
          updatePrefixLabels();
          saveSettings();
      });


      /**
       * Toggles the disabled state of VDO.Ninja input fields.
       * @param {boolean} disabled - True to disable, false to enable.
       */
      function toggleVdoNinjaInputs(disabled) {
          vdoNinjaBaseUrlInput.disabled = disabled;
          vdoNinjaRoomInput.disabled = disabled;
          vdoNinjaPasswordInput.disabled = disabled;
          vdoNinjaStreamIdsInput.disabled = disabled;
      }

      /**
       * Updates the VDO.Ninja connection button and status display.
       * @param {boolean} isVdoConnected - Current connection state to VDO.Ninja.
       */
      function updateVdoNinjaButtonState(isVdoConnected) {
          vdoNinjaConnected = isVdoConnected; // Update global state
          if (vdoNinjaConnected) {
              vdoNinjaConnectBtn.textContent = 'Disconnect from VDO.Ninja';
              vdoNinjaConnectBtn.classList.remove('disconnected');
              vdoNinjaConnectBtn.classList.add('connected');
              vdoNinjaConnectionStatus.textContent = 'Status: Connected';
              vdoNinjaStatusIndicator.classList.add('connected');
              vdoNinjaStatusIndicator.classList.remove('error');
          } else {
              vdoNinjaConnectBtn.textContent = 'Connect to VDO.Ninja';
              vdoNinjaConnectBtn.classList.remove('connected');
              vdoNinjaConnectBtn.classList.add('disconnected');
              vdoNinjaConnectionStatus.textContent = 'Status: Disconnected';
              vdoNinjaStatusIndicator.classList.remove('connected', 'error');
          }
          // Toggle input fields based on connection state
          toggleVdoNinjaInputs(vdoNinjaConnected);
          saveSettings(); // Save settings which might include connection state if relevant
      }

      /**
       * Saves current settings to localStorage.
       */
      function saveSettings() {
          const otherSceneCheckboxes = document.querySelectorAll('.other-scene-checkbox:checked');
          const selectedOtherScenes = Array.from(otherSceneCheckboxes).map(cb => cb.value);

          const settings = {
              obsWsUrl: obsWsUrlInput.value,
              obsWsPassword: obsWsPasswordInput.value,
              cameraPrefix: cameraPrefixInput.value,
              reactionSubPrefix: reactionSubPrefixInput.value,
              highlightSubPrefix: highlightSubPrefixInput.value,
              vdoNinjaBaseUrl: vdoNinjaBaseUrlInput.value,
              vdoNinjaRoom: vdoNinjaRoomInput.value,
              vdoNinjaPassword: vdoNinjaPasswordInput.value,
              vdoNinjaStreamIds: vdoNinjaStreamIdsInput.value,
              obsSceneName: obsSceneSelect.value,
              selectedOtherScenes: selectedOtherScenes, // Save the list of additionally selected scenes
              sourceSizing: sourceSizingSelect.value,
              autoAddSources: autoAddSourcesCheckbox.checked,
              autoRemoveSources: autoRemoveSourcesCheckbox.checked,
              // vdoNinjaConnected: vdoNinjaConnected, // Typically not saved, dock should start disconnected
              screenShareWidth: document.getElementById('screenShareWidth').value,
              screenShareHeight: document.getElementById('screenShareHeight').value,
              screenShareScene: document.getElementById('screenShareSceneSelect').value
          };
          localStorage.setItem('obsNinjaSettings', JSON.stringify(settings));

          const mappings = getStreamMappings();
          localStorage.setItem('obsNinjaStreamMappings', JSON.stringify(mappings));
          // logMessage("Settings saved."); // Optional: log settings save
      }

      /**
       * Calculates positions for sources in a grid layout.
       * @param {number} totalSources - The total number of sources to arrange.
       * @param {number} canvasWidth - The width of the OBS canvas.
       * @param {number} canvasHeight - The height of the OBS canvas.
       * @returns {Array<Object>} An array of position objects {x, y, width, height}.
       */
      function calculateGridPositions(totalSources, canvasWidth, canvasHeight) {
          const positions = [];
          if (totalSources === 0) return positions;

          let cols = Math.ceil(Math.sqrt(totalSources));
          let rows = Math.ceil(totalSources / cols);

          // Adjust rows and columns for better aspect ratio if possible, e.g., for 3 sources, prefer 3x1 or 1x3 over 2x2
          if (totalSources === 3) { // Example: 3 sources, 2x2 grid leaves one empty.
              cols = 3; rows = 1; // More visually appealing often
          }
          // Add more specific layout logic here if needed for other counts

          const cellWidth = canvasWidth / cols;
          const cellHeight = canvasHeight / rows;

          // Calculate offset for the last row if it's not full, to center its items
          const itemsInLastRow = totalSources - ((rows - 1) * cols);
          let lastRowHorizontalOffset = 0;
          if (rows > 1 && itemsInLastRow > 0 && itemsInLastRow < cols) {
             lastRowHorizontalOffset = (cols - itemsInLastRow) * cellWidth / 2;
          }


          for (let i = 0; i < totalSources; i++) {
              const row = Math.floor(i / cols);
              const col = i % cols;

              let x = col * cellWidth;
              if (row === rows - 1) { // If it's the last row
                  x += lastRowHorizontalOffset;
              }
              const y = row * cellHeight;
              positions.push({ x, y, width: cellWidth, height: cellHeight });
          }
          return positions;
      }

      /**
       * Disconnects from the VDO.Ninja iframe and resets related states.
       */
      function disconnectFromVdoNinja() {
          vdoNinjaIframe.src = 'about:blank'; // Clear the iframe
          if (vdoNinjaConnectionCheckTimer) {
              clearTimeout(vdoNinjaConnectionCheckTimer);
              vdoNinjaConnectionCheckTimer = null;
          }
          activeStreams = {}; // Clear active streams
          updateStreamList(); // Update the UI
          updateVdoNinjaButtonState(false); // Set VDO.Ninja to disconnected state
          logMessage("Disconnected from VDO.Ninja.");
      }

      /**
       * Initiates a connection to VDO.Ninja via the iframe.
       */
      function connectToVdoNinja() {
          if (vdoNinjaConnected) { // Should not happen if button state is correct
              logMessage("Already connected to VDO.Ninja.");
              return;
          }

          const room = vdoNinjaRoomInput.value.trim();
          const streamIds = vdoNinjaStreamIdsInput.value.trim();

          if (!room && !streamIds) {
              logMessage("VDO.Ninja Error: Room Name or Stream ID(s) must be provided.");
              return;
          }
    
          initializeVdoNinjaIframe(); // Sets up the iframe src
          vdoNinjaConnectionStatus.textContent = 'Status: Connecting...';
          vdoNinjaConnectBtn.textContent = 'Cancel'; // Allow user to cancel connection attempt

          // Clear any existing timeout
          if (vdoNinjaConnectionCheckTimer) {
              clearTimeout(vdoNinjaConnectionCheckTimer);
          }
          // Set a timeout for the connection attempt
          vdoNinjaConnectionCheckTimer = setTimeout(() => {
              // Check if connection is still not established (vdoNinjaConnected is false)
              // and if there hasn't been any activity (vdoNinjaLastActivityTime is old)
              if (!vdoNinjaConnected && (Date.now() - vdoNinjaLastActivityTime > 10000)) { 
                  logMessage("VDO.Ninja connection timed out. No activity received from iframe.");
                  vdoNinjaConnectionStatus.textContent = 'Status: Connection Failed';
                  vdoNinjaStatusIndicator.classList.add('error');
                  // Revert button to "Connect" but don't call disconnectFromVdoNinja as it wasn't fully connected
                  vdoNinjaConnectBtn.textContent = 'Connect to VDO.Ninja';
                  toggleVdoNinjaInputs(false); // Re-enable inputs
              }
          }, 10000); // 10-second timeout

          toggleVdoNinjaInputs(true); // Disable inputs while attempting to connect
          saveSettings(); // Save current settings (like base URL) before attempting connection
      }

      /**
       * Adds a new stream mapping UI element.
       * @param {string} [streamId=''] - The VDO.Ninja Stream ID.
       * @param {string} [label=''] - The VDO.Ninja label.
       * @param {string} [sceneName=''] - The target OBS scene name.
       * @param {string} [matchType='streamId'] - The matching type ('streamId', 'label', 'both', 'either').
       * @param {boolean} [shouldClone=true] - Whether to clone to the main scene.
       * @param {boolean} [shouldSwitch=false] - Whether to switch to the target scene on add.
       */
      function addNewStreamMapping(streamId = '', label = '', sceneName = '', matchType = 'streamId', shouldClone = true, shouldSwitch = false) {
          const streamMappingsDiv = document.getElementById('streamMappings');
          const mappingDiv = document.createElement('div');
          mappingDiv.className = 'stream-mapping'; // For styling and selection
          mappingDiv.style.margin = '5px 0';
          mappingDiv.style.padding = '5px';
          mappingDiv.style.border = '1px dashed #424254'; // Visually group each mapping
          mappingDiv.style.borderRadius = '3px';


          // Sanitize input if it's a PointerEvent (e.g. from button click with no params)
          const initialStreamId = (streamId instanceof PointerEvent || typeof streamId === 'object' && streamId !== null && streamId.target) ? '' : streamId;


          mappingDiv.innerHTML = `
              <div style="margin-bottom: 5px;">
                  <label style="font-size: 11px; margin-bottom: 2px; display: block;">Stream Mapping Rule</label>
                  <div class="flex-row" style="align-items: center; flex-wrap: nowrap; margin-bottom: 2px;">
                      <input type="text" placeholder="Stream ID" value="${initialStreamId}" class="mapping-stream-id" style="width:80px; margin-right: 4px; font-size:11px;">
                      <input type="text" placeholder="Label (optional)" value="${label}" class="mapping-label" style="width:120px; margin-right: 4px; font-size:11px;">
                      <select class="mapping-match-type" style="width:90px; margin-right: 4px; font-size:11px;">
                          <option value="streamId" ${matchType === 'streamId' ? 'selected' : ''}>ID Only</option>
                          <option value="label" ${matchType === 'label' ? 'selected' : ''}>Label Only</option>
                          <option value="both" ${matchType === 'both' ? 'selected' : ''}>Both Required</option>
                          <option value="either" ${matchType === 'either' ? 'selected' : ''}>Either Match</option>
                      </select>
                      <select class="mapping-scene-name" style="width:130px; font-size:11px;">
                          <option value="">Select a scene...</option>
                      </select>
                      <button class="remove-mapping-btn" style="width:auto; padding:3px 5px; margin-left: 4px; background-color:#d32f2f;">×</button>
                  </div>
                  <div class="flex-row" style="margin-top: 3px; gap: 8px;">
                      <label class="checkbox-label" style="margin-bottom: 0; font-size:11px;">
                          <input type="checkbox" class="mapping-clone-to-main" ${shouldClone ? 'checked' : ''}>
                          Clone to main scene
                      </label>
                      <label class="checkbox-label" style="margin-bottom: 0; font-size:11px;">
                          <input type="checkbox" class="mapping-switch-to-scene" ${shouldSwitch ? 'checked' : ''}>
                          Switch to scene on add
                      </label>
                  </div>
                  <small style="color: #8a8a9a; font-size: 10px; display: block; margin-top: 2px;">
                      Define how incoming streams are routed to OBS scenes.
                  </small>
              </div>
          `;

          streamMappingsDiv.appendChild(mappingDiv);
          const sceneDropdown = mappingDiv.querySelector('.mapping-scene-name');
          
          // Populate the scene dropdown for this new mapping
          populateSceneDropdown(obsScenes, sceneDropdown); 
          // Set the selected scene if a valid one was provided
          if (sceneName && obsScenes.some(scene => scene.sceneName === sceneName)) {
              sceneDropdown.value = sceneName;
          }

          // Event listener for the remove button of this mapping
          const removeBtn = mappingDiv.querySelector('.remove-mapping-btn');
          removeBtn.addEventListener('click', () => {
              mappingDiv.remove(); // Remove the mapping's div from DOM
              saveSettings(); // Update saved settings
          });

          // Add change listeners to all inputs/selects within this mapping to save on change
          const inputs = mappingDiv.querySelectorAll('input, select');
          inputs.forEach(input => {
              input.addEventListener('change', saveSettings);
          });
      }

      /**
       * Sets up the UI for stream mappings, including the "Add New Mapping" button.
       */
      function setupStreamMappingUI() {
          const addStreamMappingBtn = document.getElementById('addStreamMappingBtn');
          addStreamMappingBtn.addEventListener('click', () => {
              addNewStreamMapping(); // Add a new blank mapping rule
          });
          loadStreamMappings(); // Load any saved mappings from localStorage
      }

      /**
       * Loads settings from localStorage and applies them to the UI.
       */
      function loadSettings() {
          const settingsJson = localStorage.getItem('obsNinjaSettings');
          if (settingsJson) {
              try {
                  const settings = JSON.parse(settingsJson);
                  obsWsUrlInput.value = settings.obsWsUrl || 'ws://localhost:4455';
                  obsWsPasswordInput.value = settings.obsWsPassword || '';
                  
                  cameraPrefixInput.value = settings.cameraPrefix || 'VDO';
                  reactionSubPrefixInput.value = settings.reactionSubPrefix || 'Screen';
                  highlightSubPrefixInput.value = settings.highlightSubPrefix || 'Highlight';
                  
                  vdoNinjaBaseUrlInput.value = settings.vdoNinjaBaseUrl || 'https://vdo.ninja';
                  vdoNinjaRoomInput.value = settings.vdoNinjaRoom || '';
                  vdoNinjaPasswordInput.value = settings.vdoNinjaPassword || '';
                  vdoNinjaStreamIdsInput.value = settings.vdoNinjaStreamIds || '';
                  
                  // OBS scene related settings will be validated/set after scenes are fetched
                  loadedSelectedOtherScenes = settings.selectedOtherScenes || []; 

                  sourceSizingSelect.value = settings.sourceSizing || 'defaultSize';
                  autoAddSourcesCheckbox.checked = settings.autoAddSources !== false; // Default to true if undefined
                  autoRemoveSourcesCheckbox.checked = settings.autoRemoveSources !== false; // Default to true if undefined

                  const screenShareWidthInput = document.getElementById('screenShareWidth');
                  const screenShareHeightInput = document.getElementById('screenShareHeight');
                  
                  if (screenShareWidthInput) screenShareWidthInput.value = settings.screenShareWidth || '1920';
                  if (screenShareHeightInput) screenShareHeightInput.value = settings.screenShareHeight || '1080';
                  
                  // Actual selection for obsSceneSelect and screenShareSceneSelect happens in fetchObsScenes after scenes are loaded

                  updatePrefixLabels(); // Update prefix display labels based on loaded values
                  logMessage("Settings loaded from localStorage.");

              } catch (e) {
                  logMessage(`Error loading settings from localStorage: ${e.message}. Using defaults.`);
                  // Apply defaults if parsing fails to prevent errors
                  cameraPrefixInput.value = 'VDO';
                  reactionSubPrefixInput.value = 'Screen';
                  highlightSubPrefixInput.value = 'Highlight';
                  updatePrefixLabels();
                  vdoNinjaBaseUrlInput.value = 'https://vdo.ninja';
                  sourceSizingSelect.value = 'defaultSize';
              }
          } else {
              // Apply defaults if no settings are found in localStorage
              logMessage("No saved settings found. Using default values.");
              cameraPrefixInput.value = 'VDO';
              reactionSubPrefixInput.value = 'Screen';
              highlightSubPrefixInput.value = 'Highlight';
              updatePrefixLabels();
              vdoNinjaBaseUrlInput.value = 'https://vdo.ninja';
              sourceSizingSelect.value = 'defaultSize';
          }
          setupStreamMappingUI(); // This also calls loadStreamMappings
      }

      /**
       * Updates the list of "other scenes" checkboxes based on the main selected scene.
       */
      function updateOtherScenesList() {
          const mainSceneName = obsSceneSelect.value;
          const otherScenesListDiv = document.getElementById('otherScenesList'); 
          const container = document.getElementById('otherScenesContainer');

          otherScenesListDiv.innerHTML = ''; // Clear previous list of checkboxes

          if (mainSceneName && obsScenes && obsScenes.length > 1) {
              container.style.display = 'block'; // Show the container
              obsScenes.forEach(scene => {
                  if (scene.sceneName !== mainSceneName) { // Don't list the main scene as an "other" scene
                      const checkboxId = `otherScene_${scene.sceneName.replace(/\s+/g, '_')}`; // Create a unique ID
                      const listItem = document.createElement('div');
                      listItem.className = 'checkbox-label';

                      const checkbox = document.createElement('input');
                      checkbox.type = 'checkbox';
                      checkbox.id = checkboxId;
                      checkbox.value = scene.sceneName;
                      checkbox.className = 'other-scene-checkbox';
                      
                      // Check if this scene was previously selected (from loaded settings)
                      if (loadedSelectedOtherScenes.includes(scene.sceneName)) {
                          checkbox.checked = true;
                      }
                      checkbox.addEventListener('change', saveSettings); // Save settings when checkbox state changes

                      const label = document.createElement('label');
                      label.htmlFor = checkboxId;
                      label.textContent = scene.sceneName;

                      listItem.appendChild(checkbox);
                      listItem.appendChild(label);
                      otherScenesListDiv.appendChild(listItem); // Add to the list
                  }
              });
          } else {
              container.style.display = 'none'; // Hide if no main scene or no other scenes
          }
      }

      /**
       * Updates the list of active VDO.Ninja streams in the UI.
       */
      function updateStreamList() {
          // The container for active streams is the 5th .container element (index 4)
          // This was previously hardcoded and might need adjustment if layout changes.
          // const activeStreamsContainer = document.querySelectorAll('.container')[4]; 
          // if (activeStreamsContainer) {
          //     const collapsibleContent = activeStreamsContainer.querySelector('.collapsible-content');
          //     // The CSS rule `.container:nth-child(6) .collapsible-content` handles expansion.
          // }
          
          if (Object.keys(activeStreams).length === 0) {
              streamListContainer.innerHTML = '<div class="stream-item">No active streams</div>';
              return;
          }
          streamListContainer.innerHTML = ''; // Clear previous list

          for (const streamId in activeStreams) {
              // Ensure it's a direct property of activeStreams
              if (Object.hasOwnProperty.call(activeStreams, streamId)) {
                  const stream = activeStreams[streamId]; // Current stream object
                  const streamDiv = document.createElement('div');
                  streamDiv.className = 'stream-item';

                  // Determine target scene information for this stream
                  const targetInfo = getTargetSceneForStream(streamId, stream.label);
                  const targetSceneName = targetInfo.scene;
                  const isDefaultScene = targetSceneName === getTargetScene(); // Is it the main default scene?

                  // Check highlight and screen share states
                  const isHighlighted = highlightedStreamId === streamId;
                  const isCurrentlyScreenSharingThisStream = screenShareId === streamId;

                  // Build HTML for the stream item
                  let streamItemHTML = `
                      <div style="font-weight: bold;">${stream.label || streamId}</div>
                      <small>ID: ${streamId}${stream.label ? ` | Label: ${stream.label}` : ''}</small>
                      <small style="display: block; color: #8a8a9a;">
                          → Target Scene: ${targetSceneName || 'Not Set'} 
                          ${isDefaultScene && targetSceneName ? '(default)' : targetSceneName ? '(mapped)' : ''}
                      </small>
                      ${stream.sourceCreated ? '<span style="color:#4CAF50"> ✓ Added to OBS</span>' : '<span style="color:#FFA000"> ✗ Not in OBS</span>'}
                      <div style="margin-top: 5px;">
                          <button class="add-stream-btn" data-stream-id="${streamId}"
                              style="background-color: ${stream.sourceCreated ? '#F44336' : '#4C80AF'}; margin-right: 5px;">
                                  ${stream.sourceCreated ? 'Remove from OBS' : 'Add to OBS'}
                          </button>`;
                  
                  // Add Highlight button if source is in OBS
                  if (stream.sourceCreated) {
                      streamItemHTML += `
                          <button class="highlight-btn" data-stream-id="${streamId}"
                              style="background-color: ${isHighlighted ? '#F44336' : '#4CAF50'};">
                                  ${isHighlighted ? 'Unhighlight' : 'Highlight'}
                          </button>`;
                  }
                  
                  // Add Screen Share button if source is in OBS
                  if (stream.sourceCreated) { // Only show if the main stream source is in OBS
                       streamItemHTML += `
                          <button class="screen-share-btn" data-stream-id="${streamId}"
                                  style="background-color: ${isCurrentlyScreenSharingThisStream ? '#F44336' : '#9C27B0'}; margin-left: 5px;">
                              ${isCurrentlyScreenSharingThisStream ? 'Stop Screen Share' : 'Screen Share'}
                          </button>`;
                  }
                  streamItemHTML += `</div>`; // Close buttons div
                  streamDiv.innerHTML = streamItemHTML;
                  streamListContainer.appendChild(streamDiv);

                  // Add event listeners for buttons in this stream item
                  const addRemoveBtn = streamDiv.querySelector('.add-stream-btn');
                  if (addRemoveBtn) {
                      addRemoveBtn.addEventListener('click', () => {
                          if (stream.sourceCreated) {
                              removeStreamFromObs(streamId);
                          } else {
                              // targetInfo already calculated for this specific stream
                              addStreamToObs(streamId, stream.label, targetInfo);
                          }
                      });
                  }
                  const highlightBtn = streamDiv.querySelector('.highlight-btn');
                  if (highlightBtn) {
                      highlightBtn.addEventListener('click', () => {
                          // targetInfo already calculated
                          toggleHighlight(streamId, stream.label, targetInfo);
                      });
                  }
                  const screenShareBtn = streamDiv.querySelector('.screen-share-btn');
                  if (screenShareBtn) {
                      screenShareBtn.addEventListener('click', async () => {
                          const clickedStreamIdForScreenShare = streamId; // Closure captures this
                          const currentActiveScreenShareGlobal = screenShareId; 
                          if (currentActiveScreenShareGlobal === clickedStreamIdForScreenShare) {
                              await removeScreenShareFromObs(clickedStreamIdForScreenShare);
                          } else {
                              // If another stream is sharing, removeScreenShareFromObs will be called by addScreenShareToObs
                              await addScreenShareToObs(clickedStreamIdForScreenShare, stream.label);
                          }
                      });
                  }
              }
          }
      }

      /**
       * Adds or updates a screen share source in OBS for a given stream.
       * If another screen share is active, it's removed first.
       * @param {string} streamId - The VDO.Ninja Stream ID to screen share.
       * @param {string} streamLabel - The label of the stream (for logging).
       */
      async function addScreenShareToObs(streamId, streamLabel) {
          const previousGlobalScreenShareId = screenShareId; // Store current screen share ID
          
          if (!obsConnected || !obs) {
              logMessage("Cannot add screen share: Not connected to OBS.");
              updateStreamList(); // Revert UI if screenShareId was tentatively set
              return;
          }

          const room = vdoNinjaRoomInput.value.trim();
          if (!room) {
              logMessage("Cannot add screen share: VDO.Ninja Room name is required for screen sharing URLs.");
              updateStreamList();
              return;
          }
          
          // Set the new active screen share ID (globally)
          screenShareId = streamId; 

          const width = parseInt(document.getElementById('screenShareWidth').value) || 1920;
          const height = parseInt(document.getElementById('screenShareHeight').value) || 1080;
          const screenShareSceneSelect = document.getElementById('screenShareSceneSelect');
          let targetSceneName = screenShareSceneSelect.value || getTargetScene(); // Use main scene if specific not set

          if (!targetSceneName) {
              logMessage("Cannot add screen share: Target OBS scene is required.");
              screenShareId = previousGlobalScreenShareId; // Revert global state
              updateStreamList();
              return;
          }

          const sourceName = `${getFullReactionPrefix()}_${streamId}:s`; // ":s" for screen share typically in VDO.Ninja
          const baseUrl = getVdoNinjaBaseUrl();
          let screenShareUrl = `${baseUrl}/?view=${encodeURIComponent(streamId)}:s&solo&room=${encodeURIComponent(room)}&codec=h264`;
          if (vdoNinjaPasswordInput.value) {
              screenShareUrl += `&password=${encodeURIComponent(vdoNinjaPasswordInput.value)}`;
          }
          // Add other common parameters for clean output
          screenShareUrl += "&cleanoutput&transparent&नोсси批发&proaudio";


          const inputSettings = { 
              url: screenShareUrl, 
              width: width, 
              height: height, 
              fps: 30, 
              reroute_audio: true, // Important for capturing audio from the share
              restart_when_active: false, 
              shutdown: false // Don't shut down when not visible
          };

          logMessage(`Adding/Updating screen share source '${sourceName}' (URL: ${screenShareUrl}) to scene '${targetSceneName}'`);

          try {
              const sourcesResponse = await sendRequest('GetInputList');
              const existingSourceWithSamePrefix = sourcesResponse.inputs.find(input =>
                  input.inputName.startsWith(getFullReactionPrefix() + '_') && // Belongs to this tool's screen shares
                  input.inputName.endsWith(':s') &&
                  input.inputName !== sourceName && // Not the one we are trying to create/update now
                  input.inputKind === 'browser_source'
              );

              // If an old screen share source from this tool exists (different streamId), reconfigure and rename it.
              if (existingSourceWithSamePrefix) {
                  logMessage(`Reconfiguring existing screen share source '${existingSourceWithSamePrefix.inputName}' to be '${sourceName}'.`);
                  await sendRequest('SetInputSettings', { 
                      inputName: existingSourceWithSamePrefix.inputName, 
                      inputSettings: inputSettings // Update URL, dimensions, etc.
                  });
                  if (existingSourceWithSamePrefix.inputName !== sourceName) {
                      await sendRequest('SetInputName', { 
                          inputName: existingSourceWithSamePrefix.inputName, 
                          newInputName: sourceName 
                      });
                  }
                  logMessage(`Reconfigured and renamed existing screen share source to '${sourceName}'.`);
              } else {
                  // Check if the exact source 'sourceName' already exists
                  const exactSourceExists = sourcesResponse.inputs.find(input => input.inputName === sourceName && input.inputKind === 'browser_source');
                  if (exactSourceExists) {
                       logMessage(`Screen share source '${sourceName}' already exists. Updating its settings.`);
                       await sendRequest('SetInputSettings', { 
                           inputName: sourceName, 
                           inputSettings: inputSettings 
                       });
                  } else {
                      logMessage(`Creating new screen share source '${sourceName}'.`);
                      await sendRequest('CreateInput', { 
                          sceneName: targetSceneName, // Add to scene directly
                          inputName: sourceName, 
                          inputKind: 'browser_source', 
                          inputSettings, 
                          sceneItemEnabled: true // Make it visible by default
                      });
                  }
              }

              // Ensure the source is a scene item in the target scene and get its ID
              let sceneItemId;
              try {
                  const itemInfo = await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName });
                  sceneItemId = itemInfo.sceneItemId;
                  logMessage(`Source '${sourceName}' found in scene '${targetSceneName}', item ID: ${sceneItemId}. Ensuring it's enabled.`);
                  // Ensure it's visible
                  await sendRequest('SetSceneItemEnabled', { sceneName: targetSceneName, sceneItemId: sceneItemId, sceneItemEnabled: true });
              } catch (e) {
                  if (e.message.toLowerCase().includes("not found")) {
                      logMessage(`Source '${sourceName}' not found as an item in scene '${targetSceneName}'. Creating scene item.`);
                      const createItemResponse = await sendRequest('CreateSceneItem', { sceneName: targetSceneName, sourceName: sourceName });
                      sceneItemId = createItemResponse.sceneItemId;
                      logMessage(`Created scene item for '${sourceName}' in '${targetSceneName}', item ID: ${sceneItemId}.`);
                  } else {
                      throw e; // Re-throw other errors
                  }
              }

              // Apply transform if we have a scene item ID
              if (sceneItemId) {
                  // Using 'defaultSize' for screen share, but could be configurable
                  const transform = calculateTransform('defaultSize', width, height, width, height); 
                  await sendRequest('SetSceneItemTransform', { 
                      sceneName: targetSceneName, 
                      sceneItemId: sceneItemId, 
                      sceneItemTransform: transform 
                  });
                  logMessage(`Applied transform to screen share source '${sourceName}' in '${targetSceneName}'.`);
              }
              logMessage(`Successfully configured screen share for stream ${streamId} (${streamLabel}).`);

          } catch (error) {
              logMessage(`Error adding/updating screen share source '${sourceName}': ${error.message}.`);
              screenShareId = previousGlobalScreenShareId; // Revert global state on error
          } finally {
              updateStreamList(); // Update UI based on final screenShareId state
          }
      }

      /**
       * Toggles the highlighted state of a stream in OBS.
       * Only one stream can be highlighted at a time. Highlighting involves renaming the OBS source.
       * @param {string} clickedStreamId - The ID of the stream to toggle highlight for.
       * @param {string} clickedStreamLabel - The label of the clicked stream.
       * @param {Object} clickedTargetInfo - The target scene information for the clicked stream.
       */
      async function toggleHighlight(clickedStreamId, clickedStreamLabel, clickedTargetInfo) {
          if (!obsConnected || !obs) {
              logMessage("Cannot toggle highlight: Not connected to OBS.");
              return;
          }

          const previouslyGlobalHighlightedStreamId = highlightedStreamId; // ID of stream highlighted *before* this call
          const camPrefix = getFullCameraPrefix(); // Base prefix for camera sources
          const hlPrefix = getFullHighlightPrefix(); // Prefix for highlighted sources

          // --- Phase 1: Unhighlight the *previously* highlighted stream IF it's different from the clicked one ---
          if (previouslyGlobalHighlightedStreamId && previouslyGlobalHighlightedStreamId !== clickedStreamId) {
              logMessage(`Switching highlight: Unhighlighting previous stream ${previouslyGlobalHighlightedStreamId}.`);
              const oldStreamDetails = activeStreams[previouslyGlobalHighlightedStreamId]; // Get details of the old stream
              const oldStreamLabel = oldStreamDetails ? oldStreamDetails.label : '';
              // Fetch target info for the stream being unhighlighted (it might differ from the clicked one's target)
              const oldTargetInfo = getTargetSceneForStream(previouslyGlobalHighlightedStreamId, oldStreamLabel); 

              const oldHighlightedSourceName = `${hlPrefix}_${previouslyGlobalHighlightedStreamId}`;
              const oldOriginalSourceName = `${camPrefix}_${previouslyGlobalHighlightedStreamId}`;

              try {
                  // Check if the source to unhighlight actually exists in its highlighted form
                  await sendRequest('GetInputSettings', { inputName: oldHighlightedSourceName });
                  // If it exists, rename it back to its original (non-highlighted) name
                  await sendRequest('SetInputName', {
                      inputName: oldHighlightedSourceName,
                      newInputName: oldOriginalSourceName
                  });
                  logMessage(`Stream ${previouslyGlobalHighlightedStreamId} unhighlighted (renamed from ${oldHighlightedSourceName} to ${oldOriginalSourceName}).`);

                  // If using autoGrid, rearrange the scene where the old stream was
                  if (sourceSizingSelect.value === 'autoGrid') {
                      if (oldTargetInfo.scene) await rearrangeAllStreamsInScene(oldTargetInfo.scene);
                      // Also handle cloneToMain if the old stream was cloned to the default scene
                      if (oldTargetInfo.mapping?.cloneToMain && getTargetScene() && getTargetScene() !== oldTargetInfo.scene) {
                          await rearrangeAllStreamsInScene(getTargetScene());
                      }
                  }
              } catch (e) {
                  if (!e.message.toLowerCase().includes("not found") || !e.message.toLowerCase().includes("does not exist") || !e.message.toLowerCase().includes("no source")) {
                      logMessage(`Source ${oldHighlightedSourceName} for previous highlight ${previouslyGlobalHighlightedStreamId} not found. Assuming it was already ${oldOriginalSourceName} or removed.`);
                  } else {
                      logMessage(`Error unhighlighting previous stream ${previouslyGlobalHighlightedStreamId} (from ${oldHighlightedSourceName}): ${e.message}`);
                  }
              }
          }

          // --- Phase 2: Process the *clicked* stream ---
          const clickedOriginalSourceName = `${camPrefix}_${clickedStreamId}`;
          const clickedNewHighlightedSourceName = `${hlPrefix}_${clickedStreamId}`;

          if (previouslyGlobalHighlightedStreamId === clickedStreamId) {
              // Intent: Unhighlight the clicked stream (it was the one globally highlighted)
              logMessage(`Unhighlighting clicked stream ${clickedStreamId}.`);
              try {
                  // Check if it's in highlighted form before trying to rename
                  await sendRequest('GetInputSettings', { inputName: clickedNewHighlightedSourceName });
                  await sendRequest('SetInputName', {
                      inputName: clickedNewHighlightedSourceName,
                      newInputName: clickedOriginalSourceName
                  });
                  highlightedStreamId = null; // Update global state: no stream is highlighted now
                  logMessage(`Stream ${clickedStreamId} successfully unhighlighted (renamed to ${clickedOriginalSourceName}).`);

                  if (sourceSizingSelect.value === 'autoGrid') {
                      if (clickedTargetInfo.scene) await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
                      if (clickedTargetInfo.mapping?.cloneToMain && getTargetScene() && getTargetScene() !== clickedTargetInfo.scene) {
                          await rearrangeAllStreamsInScene(getTargetScene());
                      }
                  }
              } catch (e) {
                  if (!e.message.toLowerCase().includes("not found") || !e.message.toLowerCase().includes("does not exist") || !e.message.toLowerCase().includes("no source")) {
                      logMessage(`Cannot unhighlight ${clickedStreamId}: Source ${clickedNewHighlightedSourceName} not found. Assuming it's already ${clickedOriginalSourceName}.`);
                  } else {
                      logMessage(`Error unhighlighting ${clickedStreamId} (from ${clickedNewHighlightedSourceName}): ${e.message}`);
                  }
                  highlightedStreamId = null; // Ensure state is cleared on error too
              }
          } else {
              // Intent: Highlight the clicked stream
              logMessage(`Highlighting clicked stream ${clickedStreamId}.`);
              try {
                  // Check if it's in its original form before trying to rename
                  await sendRequest('GetInputSettings', { inputName: clickedOriginalSourceName });
                  await sendRequest('SetInputName', {
                      inputName: clickedOriginalSourceName,
                      newInputName: clickedNewHighlightedSourceName
                  });
                  highlightedStreamId = clickedStreamId; // Update global state
                  logMessage(`Stream ${clickedStreamId} successfully highlighted (renamed to ${clickedNewHighlightedSourceName}).`);

                  if (sourceSizingSelect.value === 'autoGrid') {
                       if (clickedTargetInfo.scene) await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
                       if (clickedTargetInfo.mapping?.cloneToMain && getTargetScene() && getTargetScene() !== clickedTargetInfo.scene) {
                          await rearrangeAllStreamsInScene(getTargetScene());
                       }
                   }
              } catch (e) {
                  if (!e.message.toLowerCase().includes("not found") || !e.message.toLowerCase().includes("does not exist") || !e.message.toLowerCase().includes("no source")) {
                      logMessage(`Cannot highlight ${clickedStreamId}: Original source ${clickedOriginalSourceName} not found. Checking if already highlighted.`);
                       try {
                          // It might be that original is gone, but highlighted one exists due to prior issue.
                          await sendRequest('GetInputSettings', { inputName: clickedNewHighlightedSourceName });
                          logMessage(`Stream ${clickedStreamId} appears to be already named ${clickedNewHighlightedSourceName}. Setting as highlighted.`);
                          highlightedStreamId = clickedStreamId; // Correct internal state
                      } catch (e2) {
                           logMessage(`Failed to highlight ${clickedStreamId}: Neither ${clickedOriginalSourceName} nor ${clickedNewHighlightedSourceName} found. Source may be missing.`);
                           if (highlightedStreamId === clickedStreamId) highlightedStreamId = null; // Clear if it was this one
                      }
                  } else {
                      logMessage(`Error highlighting ${clickedStreamId} (from ${clickedOriginalSourceName}): ${e.message}`);
                      if (highlightedStreamId === clickedStreamId) highlightedStreamId = null; // Clear if error occurred for this one
                  }
              }
          }
          updateStreamList(); // Refresh UI to reflect new highlight state
          saveSettings(); // Save changes (like highlightedStreamId if it were part of settings)
      }

      // Event listener for OBS connect/disconnect button
      obsConnectBtn.addEventListener('click', () => {
          if (obsConnected && obs) {
              logMessage("Disconnecting from OBS WebSocket...");
              if (obs) { 
                  obs.onclose = null; // Prevent onObsDisconnected from firing again if already closing
                  obs.close(); 
                  obs = null; 
              }
              // Manually trigger disconnected state if obs.close() doesn't fire onclose immediately or reliably
              onObsDisconnected(); 
          } else {
              connectToOBS();
          }
      });

      /**
       * Determines the target OBS scene for a given stream based on mappings or default.
       * @param {string} streamId - The VDO.Ninja Stream ID.
       * @param {string} [streamLabel=''] - The label of the stream.
       * @returns {Object} An object { scene: string, mapping: Object|null }
       */
      function getTargetSceneForStream(streamId, streamLabel = '') {
          const mappings = getStreamMappings(); // Get current mapping rules
          const defaultTargetScene = getTargetScene(); // The scene selected in the main "Target Scene" dropdown

          for (const mapping of mappings) {
              let isMatch = false;
              switch (mapping.matchType) {
                  case 'streamId': isMatch = mapping.streamId && streamId === mapping.streamId; break;
                  case 'label':    isMatch = mapping.label && streamLabel && streamLabel === mapping.label; break;
                  case 'both':     isMatch = mapping.streamId && mapping.label && streamId === mapping.streamId && streamLabel === mapping.label; break;
                  case 'either':   isMatch = (mapping.streamId && streamId === mapping.streamId) || (mapping.label && streamLabel && streamLabel === mapping.label); break;
              }
              // If a match is found and the mapping specifies a scene name
              if (isMatch && mapping.sceneName) {
                  return { scene: mapping.sceneName, mapping: mapping }; // Return scene name and the mapping rule
              }
          }
          // If no mapping rule matches, or matched rule has no scene, use the default target scene
          return { scene: defaultTargetScene, mapping: null }; 
      }

      /**
       * Updates all scene selection dropdowns with the current list of OBS scenes.
       * Preserves existing selections if they are still valid.
       */
      function updateSceneDropdowns() {
          // Store current values before clearing and repopulating dropdowns
          const currentMainSceneValue = obsSceneSelect.value;
          const currentScreenShareSceneValue = document.getElementById('screenShareSceneSelect').value;
          const mappingSceneSelects = document.querySelectorAll('.mapping-scene-name');
          const currentMappingSceneValues = Array.from(mappingSceneSelects).map(select => select.value);

          // Populate the main target scene dropdown
          populateSceneDropdown(obsScenes, obsSceneSelect);
          // Populate the screen share target scene dropdown
          populateSceneDropdown(obsScenes, document.getElementById('screenShareSceneSelect'));
          
          // Restore main scene selection if it's still a valid scene
          if (currentMainSceneValue && obsScenes.some(scene => scene.sceneName === currentMainSceneValue)) {
              obsSceneSelect.value = currentMainSceneValue;
          }
          // Restore screen share scene selection (empty value for "Same as main" is also valid)
          if (currentScreenShareSceneValue === "" || (currentScreenShareSceneValue && obsScenes.some(scene => scene.sceneName === currentScreenShareSceneValue))) {
              document.getElementById('screenShareSceneSelect').value = currentScreenShareSceneValue;
          }


          // Populate and restore selections for scene dropdowns in stream mappings
          mappingSceneSelects.forEach((select, index) => {
              populateSceneDropdown(obsScenes, select);
              if (currentMappingSceneValues[index] && obsScenes.some(scene => scene.sceneName === currentMappingSceneValues[index])) {
                  select.value = currentMappingSceneValues[index];
              }
          });
          // After updating all dropdowns, update the "other scenes" list as it depends on the main scene selection
          updateOtherScenesList();
      }

      /**
       * Loads stream mapping rules from localStorage.
       */
      function loadStreamMappings() {
          const mappingsJson = localStorage.getItem('obsNinjaStreamMappings');
          if (mappingsJson) {
              try {
                  const mappings = JSON.parse(mappingsJson);
                  mappings.forEach(mapping => {
                      addNewStreamMapping(
                          mapping.streamId, 
                          mapping.label, 
                          mapping.sceneName, 
                          mapping.matchType,
                          mapping.cloneToMain !== undefined ? mapping.cloneToMain : true, // Default to true
                          mapping.switchToScene !== undefined ? mapping.switchToScene : false // Default to false
                      );
                  });
                  // If scenes are already loaded, update the dropdowns within the newly added mappings
                  if (obsScenes && obsScenes.length > 0) {
                      updateSceneDropdowns(); // This will repopulate and try to restore selections
                  }
                  logMessage(`Loaded ${mappings.length} stream mappings.`);
              } catch (e) { 
                logMessage(`Error loading stream mappings from localStorage: ${e.message}`); 
              }
          }
      }
      /**
       * Retrieves current stream mapping rules from the UI.
       * @returns {Array<Object>} An array of mapping rule objects.
       */
      function getStreamMappings() {
          const mappings = [];
          document.querySelectorAll('.stream-mapping').forEach(div => {
              const streamIdInput = div.querySelector('.mapping-stream-id');
              const labelInput = div.querySelector('.mapping-label');
              const matchTypeSelect = div.querySelector('.mapping-match-type');
              const sceneNameSelect = div.querySelector('.mapping-scene-name');
              const cloneToMainCheckbox = div.querySelector('.mapping-clone-to-main');
              const switchToSceneCheckbox = div.querySelector('.mapping-switch-to-scene');

              // Ensure all elements are found before trying to access their values
              if (streamIdInput && labelInput && matchTypeSelect && sceneNameSelect && cloneToMainCheckbox && switchToSceneCheckbox) {
                  const streamId = streamIdInput.value.trim();
                  const label = labelInput.value.trim();
                  const matchType = matchTypeSelect.value;
                  const sceneName = sceneNameSelect.value.trim();
                  const cloneToMain = cloneToMainCheckbox.checked;
                  const switchToScene = switchToSceneCheckbox.checked;
                  
                  // A mapping rule is valid if it has a target scene and at least one identifier (ID or label)
                  if (sceneName && (streamId || label)) {
                      mappings.push({ streamId, label, matchType, sceneName, cloneToMain, switchToScene });
                  }
              } else {
                  logMessage("Warning: Could not find all expected elements in a stream mapping UI div.");
              }
          });
          return mappings;
      }

      /**
       * Connects to the OBS WebSocket server.
       */
      async function connectToOBS() {
          // Validate essential prefix inputs
          if (cameraPrefixInput.value.trim() === '' || reactionSubPrefixInput.value.trim() === '' || highlightSubPrefixInput.value.trim() === '') {
              logMessage("Error: Camera, Reaction, and Highlight prefixes are required for OBS connection.");
              obsStatusIndicator.classList.add('error');
              obsConnectionStatus.textContent = 'Status: Error - Prefixes missing';
              return;
          }

          let url = obsWsUrlInput.value.trim();
          const password = obsWsPasswordInput.value; // Password can be empty

          if (!url) { 
              logMessage("Error: OBS WebSocket URL is required."); 
              obsStatusIndicator.classList.add('error');
              obsConnectionStatus.textContent = 'Status: Error - URL missing';
              return; 
          }
          // Prepend ws:// if no protocol is specified
          if (!url.startsWith('ws://') && !url.startsWith('wss://')) { 
              url = 'ws://' + url; 
              obsWsUrlInput.value = url; // Update the input field
          }
          
          obsConnectionStatus.textContent = 'Status: Connecting...';
          obsStatusIndicator.classList.remove('connected', 'error');
          logMessage(`Attempting to connect to OBS WebSocket at ${url}...`);

          // Timeout for the connection attempt
          const connectionTimeoutId = setTimeout(() => {
              if (obs && obs.readyState !== WebSocket.OPEN && obs.readyState !== WebSocket.CONNECTING) {
                  logMessage("OBS WebSocket connection attempt timed out.");
                  if (obs) { try { obs.close(); } catch (e) {} obs = null; } // Clean up
                  obsConnectionStatus.textContent = 'Status: Error - Connection timed out';
                  obsStatusIndicator.classList.add('error');
                  obsConnectBtn.textContent = 'Connect to OBS'; // Reset button
                  obsConnectBtn.classList.remove('connected');
                  obsConnectBtn.classList.add('disconnected');
              }
          }, 10000); // 10 seconds

          try {
              obs = new WebSocket(url); // Create the WebSocket connection

              obs.onopen = () => {
                  logMessage("OBS WebSocket connection opened. Waiting for Server Hello...");
                  // Server will send OpCode 0 (Hello)
              };

              obs.onmessage = async (event) => {
                  try {
                      const message = JSON.parse(event.data);
                      // logMessage(`OBS RX (${message.op}): ${JSON.stringify(message.d || message)}`); // Verbose logging

                      if (message.op === 0) { // OpCode 0: Hello from server
                          logMessage("Received Hello from OBS. Sending Identify...");
                          const identifyPayload = { 
                              op: 1, // OpCode 1: Identify
                              d: { 
                                  rpcVersion: 1,
                                  // Subscribe to events (e.g., SceneListChanged, InputCreated, etc.)
                                  // Bitmask: (1<<0) General, (1<<1) Config, (1<<2) Scenes, (1<<3) Inputs, etc.
                                  eventSubscriptions: (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9) // Common subscriptions
                              } 
                          };
                          // Handle authentication if required by the server
                          if (message.d && message.d.authentication) {
                              const { challenge, salt } = message.d.authentication;
                              if (password) {
                                  identifyPayload.d.authentication = await generateAuthResponse(password, salt, challenge);
                                  logMessage("Authentication data prepared for Identify message.");
                              } else { 
                                  logMessage("Warning: OBS server requires authentication, but no password provided.");
                                  // Connection will likely fail at Identified stage or close with auth error
                              }
                          }
                          obs.send(JSON.stringify(identifyPayload));
                      } else if (message.op === 2) { // OpCode 2: Identified (successfully connected and authenticated)
                          clearTimeout(connectionTimeoutId); // Connection successful, clear timeout
                          logMessage("OBS WebSocket Authentication successful! Connection established.");
                          obsConnected = true;
                          obsConnectBtn.textContent = 'Disconnect';
                          obsConnectBtn.classList.add('connected'); 
                          obsConnectBtn.classList.remove('disconnected');
                          obsConnectionStatus.textContent = 'Status: Connected';
                          obsStatusIndicator.classList.add('connected');
                          obsStatusIndicator.classList.remove('error');
                          onObsConnected(); // Perform actions after successful connection
                      } else if (message.op === 7) { // OpCode 7: RequestResponse
                          if (message.d && message.d.requestId && requestCallbacks[message.d.requestId]) {
                              requestCallbacks[message.d.requestId](message.d); // Call the stored callback
                              delete requestCallbacks[message.d.requestId]; // Clean up callback
                          }
                          // Log errors from requests if not successful
                          if (message.d && message.d.requestStatus && message.d.requestStatus.code !== 100) {
                              logMessage(`OBS Request Error (Type: ${message.d.requestType || 'Unknown'}, ID: ${message.d.requestId}): ${message.d.requestStatus.comment || 'Unknown error'}`);
                          }
                      } else if (message.op === 5) { // OpCode 5: Event
                          // logMessage(`OBS Event: ${message.d ? message.d.eventType : 'Unknown'} - ${JSON.stringify(message.d.eventData)}`);
                          // Handle specific events if needed, e.g., scene changes, input creation/removal
                           if (message.d && message.d.eventType === 'SceneListChanged') {
                               logMessage("OBS Event: Scene list changed. Re-fetching scenes.");
                               fetchObsScenes();
                           }
                      } else {
                         // logMessage(`Received unhandled OBS message op ${message.op}: ${JSON.stringify(message)}`);
                      }
                  } catch (error) { 
                      logMessage(`Error processing OBS WebSocket message: ${error.message}. Data: ${event.data}`); 
                  }
              };

              obs.onerror = (errorEvent) => {
                  clearTimeout(connectionTimeoutId);
                  // Try to get more details from the error event if possible
                  let errorMsg = 'Unknown WebSocket error';
                  if (errorEvent && errorEvent.message) {
                      errorMsg = errorEvent.message;
                  } else if (typeof errorEvent === 'string') {
                      errorMsg = errorEvent;
                  }
                  logMessage(`OBS WebSocket Error: ${errorMsg}`);
                  obsStatusIndicator.classList.add('error');
                  obsConnectionStatus.textContent = 'Status: Error';
                  // Ensure button is in connect state if an error occurs before connection
                  obsConnectBtn.textContent = 'Connect to OBS';
                  obsConnectBtn.classList.remove('connected');
                  obsConnectBtn.classList.add('disconnected');
                  obsConnected = false; // Ensure connection state is false
              };

              obs.onclose = (event) => {
                  clearTimeout(connectionTimeoutId);
                  let reason = '';
                  if (event.code === 4009) { // Authentication failed specifically
                     reason = 'Authentication Failed - incorrect password or auth required and not provided.';
                  } else if (event.reason) {
                     reason = event.reason;
                  } else {
                     reason = `Code: ${event.code || 'Unknown'}${event.wasClean ? "" : " (Unclean disconnection)"}`;
                  }
                  logMessage(`OBS WebSocket Connection Closed. Reason: ${reason}`);
                  onObsDisconnected(); // Handle UI and state changes for disconnection
              };
          } catch (error) { // Catch errors from `new WebSocket()` itself (e.g., invalid URL format)
              clearTimeout(connectionTimeoutId);
              logMessage(`Error creating OBS WebSocket connection: ${error.message}`);
              obsConnectionStatus.textContent = 'Status: Error';
              obsStatusIndicator.classList.add('error');
              obsConnectBtn.textContent = 'Connect to OBS';
              obsConnectBtn.classList.remove('connected');
              obsConnectBtn.classList.add('disconnected');
              obsConnected = false;
          }
      }

      /**
       * Generates the authentication string for OBS WebSocket v5.
       * @param {string} password - The OBS WebSocket password.
       * @param {string} salt - The salt provided by the server.
       * @param {string} challenge - The challenge provided by the server.
       * @returns {Promise<string>} The base64 encoded authentication string.
       */
      async function generateAuthResponse(password, salt, challenge) {
          const encoder = new TextEncoder();
          try {
              // Step 1: Concatenate password and salt, then SHA256 hash
              const secretString = password + salt;
              const secretData = encoder.encode(secretString);
              let secretHash; // Uint8Array

              if (window.crypto && window.crypto.subtle) { // Prefer modern Web Crypto API
                  const hashBuffer = await window.crypto.subtle.digest('SHA-256', secretData);
                  secretHash = new Uint8Array(hashBuffer);
              } else { // Fallback to jsSHA library
                  await loadJsShaLibrary(); // Ensure jsSHA is loaded
                  const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
                  shaObj.update(secretString);
                  const hashHex = shaObj.getHash("HEX");
                  // Convert hex string to Uint8Array
                  secretHash = new Uint8Array(hashHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
              }
              
              // Step 2: Base64 encode the hashed secret
              const secretBase64 = btoa(String.fromCharCode.apply(null, secretHash));

              // Step 3: Concatenate the base64 secret with the challenge, then SHA256 hash
              const authString = secretBase64 + challenge;
              const authData = encoder.encode(authString);
              let authHash; // Uint8Array

              if (window.crypto && window.crypto.subtle) {
                  const hashBuffer = await window.crypto.subtle.digest('SHA-256', authData);
                  authHash = new Uint8Array(hashBuffer);
              } else {
                  // jsSHA should be loaded by now if crypto.subtle wasn't available
                  const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
                  shaObj.update(authString);
                  const hashHex = shaObj.getHash("HEX");
                  authHash = new Uint8Array(hashHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
              }

              // Step 4: Base64 encode the final hashed auth string
              return btoa(String.fromCharCode.apply(null, authHash));
          } catch (error) {
              logMessage(`OBS Authentication generation error: ${error.message}`);
              throw error; // Re-throw to be caught by the caller
          }
      }
      
      /**
       * Sends a request to the OBS WebSocket server.
       * @param {string} requestType - The type of request (e.g., "GetSceneList").
       * @param {Object} [requestData={}] - The data for the request.
       * @returns {Promise<Object>} A promise that resolves with the response data.
       */
      function sendRequest(requestType, requestData = {}) {
      	return new Promise((resolve, reject) => {
      		if (!obsConnected || !obs) { 
                logMessage(`Cannot send request '${requestType}': Not connected to OBS.`);
                reject(new Error("Not connected to OBS")); 
                return; 
            }
      		const requestId = generateRequestId(requestType);
      		
            // Store callback for this request ID
            requestCallbacks[requestId] = (response) => {
      			if (response.requestStatus && response.requestStatus.code === 100) { // Code 100 is success
                    resolve(response.responseData || {}); // Resolve with responseData or empty object
                } else { 
                    const errorMessage = response.requestStatus ? response.requestStatus.comment : "Unknown error";
                    logMessage(`OBS Request '${requestType}' (ID: ${requestId}) failed: ${errorMessage} (Code: ${response.requestStatus ? response.requestStatus.code : 'N/A'})`);
                    reject(new Error(`Request ${requestType} failed: ${errorMessage}`));
                }
      		};
      		
            const requestPayload = { 
                op: 6, // OpCode 6: Request
                d: { 
                    requestType, 
                    requestId, 
                    requestData 
                } 
            };
            // logMessage(`OBS TX (${requestPayload.op}): ${requestType} - ${JSON.stringify(requestData)}`); // Verbose logging
      		
            try { 
                obs.send(JSON.stringify(requestPayload)); 
            } catch (error) { 
                logMessage(`Error sending OBS request '${requestType}': ${error.message}`);
                delete requestCallbacks[requestId]; // Clean up callback if send fails
                reject(error); 
            }

            // Timeout for the request
      		setTimeout(() => {
      			if (requestCallbacks[requestId]) { // If callback still exists, it means no response was received
      				delete requestCallbacks[requestId];
                    logMessage(`OBS Request '${requestType}' (ID: ${requestId}) timed out.`);
      				reject(new Error(`Request timeout for ${requestType}`));
      			}
      		}, 5000); // 5-second timeout
      	});
      }

      /**
       * Called when the OBS WebSocket connection is successfully established and identified.
       */
      function onObsConnected() {
          logMessage("OBS Connection fully established. Fetching initial data...");
          fetchObsScenes().then(() => {
              // Attempt to reconnect to VDO.Ninja if it was connected before a page reload (if settings indicate so)
              // This logic is typically handled by user action or initial load, vdoNinjaConnected state is not saved.
              // const settingsJson = localStorage.getItem('obsNinjaSettings');
              // if (settingsJson) {
              //     try {
              //         const settings = JSON.parse(settingsJson);
              //         if (settings.vdoNinjaWasConnected && (settings.vdoNinjaRoom || settings.vdoNinjaStreamIds)) {
              //             logMessage("Attempting to auto-reconnect to VDO.Ninja...");
              //             connectToVdoNinja();
              //         }
              //     } catch (e) { 
              //         logMessage(`Error during VDO.Ninja auto-reconnect attempt: ${e.message}`);
              //     }
              // }

              // If auto-grid is enabled, trigger a rearrange for the currently selected target scene
              if (sourceSizingSelect.value === 'autoGrid' && getTargetScene()) {
                  logMessage("Initial rearrange for auto-grid on main target scene after OBS connection.");
                  setTimeout(() => rearrangeAllStreamsInScene(getTargetScene()), 1000); // Delay slightly
              }
          }).catch(error => {
              logMessage(`Error during post-OBS connection setup (fetching scenes): ${error.message}`);
          });
      }

      /**
       * Called when the OBS WebSocket connection is closed or fails.
       */
      function onObsDisconnected() {
          logMessage("OBS Connection has been closed or lost.");
          obsConnected = false;
          obsConnectBtn.textContent = 'Connect to OBS';
          obsConnectBtn.classList.remove('connected'); 
          obsConnectBtn.classList.add('disconnected');
          obsConnectionStatus.textContent = 'Status: Disconnected';
          obsStatusIndicator.classList.remove('connected', 'error');
          
          // Mark all active VDO.Ninja streams as not having their source created in OBS
          Object.values(activeStreams).forEach(stream => stream.sourceCreated = false);
          updateStreamList(); // Refresh UI to reflect sources are not in OBS

          // Clear scene lists as they are no longer valid/live
          obsScenes = [];
          updateSceneDropdowns(); // This will clear options or show "Select a scene..."
          updateOtherScenesList(); // Clear other scenes checkboxes
      }

      /**
       * Fetches the list of scenes from OBS and updates relevant UI elements.
       */
      async function fetchObsScenes() {
          if (!obsConnected || !obs) {
              logMessage("Cannot fetch OBS scenes: Not connected to OBS.");
              return;
          }
          logMessage("Fetching OBS scenes...");
          try {
              const response = await sendRequest('GetSceneList');
              if (response && response.scenes) {
                  obsScenes = response.scenes; 
                  logMessage(`Workspaceed ${obsScenes.length} scenes from OBS.`);
                  
                  // Store current selections to try and reapply them
                  const previouslySelectedMainScene = obsSceneSelect.value;
                  const previouslySelectedScreenShareScene = document.getElementById('screenShareSceneSelect').value;
                  
                  updateSceneDropdowns(); // This populates all scene dropdowns with new obsScenes data

                  // Try to restore the main scene selection if it's still valid
                  if (previouslySelectedMainScene && obsScenes.some(s => s.sceneName === previouslySelectedMainScene)) {
                      obsSceneSelect.value = previouslySelectedMainScene;
                  } else if (previouslySelectedMainScene) {
                      logMessage(`Previously selected main scene "${previouslySelectedMainScene}" no longer found. Please reselect.`);
                      obsSceneSelect.value = ""; // Reset if not found
                  }

                  // Try to restore the screen share scene selection
                  const screenShareSelectElement = document.getElementById('screenShareSceneSelect');
                  if (previouslySelectedScreenShareScene === "" || (previouslySelectedScreenShareScene && obsScenes.some(s => s.sceneName === previouslySelectedScreenShareScene))) {
                      screenShareSelectElement.value = previouslySelectedScreenShareScene;
                  } else if (previouslySelectedScreenShareScene) {
                      logMessage(`Previously selected screen share scene "${previouslySelectedScreenShareScene}" no longer found. Defaulting to "Same as main".`);
                      screenShareSelectElement.value = ""; // Reset to default if not found
                  }
                  
                  // This also restores selections in mapping dropdowns if they are valid
                  // updateOtherScenesList() is called within updateSceneDropdowns indirectly or should be called after.
                  // Ensure other scenes checkboxes are also updated based on the new main scene.
                  updateOtherScenesList(); 

                  // Restore mapping scene selections based on saved mappings (done by updateSceneDropdowns if mappings exist)
                  const savedMappingsJson = localStorage.getItem('obsNinjaStreamMappings');
                   if (savedMappingsJson) {
                      try {
                          const mappings = JSON.parse(savedMappingsJson);
                          document.querySelectorAll('.mapping-scene-name').forEach((select, index) => {
                              if (mappings[index] && mappings[index].sceneName) {
                                  if (obsScenes.some(scene => scene.sceneName === mappings[index].sceneName)) {
                                      select.value = mappings[index].sceneName;
                                  } else {
                                      logMessage(`Saved scene "${mappings[index].sceneName}" for mapping rule ${index + 1} not found.`);
                                  }
                              }
                          });
                      } catch (e) {
                          logMessage(`Error applying saved scene selections to stream mappings: ${e.message}`);
                      }
                  }
                  obsSceneNameInput.value = obsSceneSelect.value; // Sync hidden input
              } else {
                  logMessage("Failed to fetch OBS scenes or no scenes returned.");
                  obsScenes = []; // Clear local cache
                  updateSceneDropdowns(); // Update UI to reflect no scenes
                  updateOtherScenesList();
              }
          } catch (error) { 
              logMessage(`Error fetching OBS scenes: ${error.message}`); 
              obsScenes = [];
              updateSceneDropdowns();
              updateOtherScenesList();
          }
      }

      /**
       * Populates a given select element with OBS scene names.
       * @param {Array<Object>} scenesData - Array of scene objects from OBS.
       * @param {HTMLSelectElement} selectElement - The select element to populate.
       */
      function populateSceneDropdown(scenesData, selectElement) {
          const currentValue = selectElement.value; // Preserve current selection if valid after repopulation
          
          // Set default option(s) based on the select element's purpose
          if (selectElement.id === 'screenShareSceneSelect') {
              selectElement.innerHTML = '<option value="">Same as main</option>';
          } else { // For main scene select and mapping selects
              selectElement.innerHTML = '<option value="">Select a scene...</option>';
          }

          if (!scenesData || scenesData.length === 0) {
              // logMessage(`No scenes data to populate dropdown: ${selectElement.id}`);
              return; // No scenes to add
          }

          // Add each scene as an option
          scenesData.forEach(scene => { 
              const option = document.createElement('option');
              option.value = scene.sceneName;
              option.textContent = scene.sceneName;
              selectElement.appendChild(option); 
          });

          // Try to restore the previously selected value if it still exists in the new list of options
          if (currentValue && Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
              selectElement.value = currentValue;
          } else if (selectElement.id === 'obsSceneSelect' && selectElement.options.length > 1 && currentValue === "") {
              // For the main scene selector, if it was "Select a scene..." and there are scenes, keep it that way unless a specific one was restored.
          } else if (selectElement.options.length > 1 && selectElement.id !== 'screenShareSceneSelect' && currentValue === "") {
              // For mapping dropdowns, keep "Select a scene..." if it was the previous value.
          }
          // No automatic selection of the first scene if the previous value is no longer valid, to force user choice.
      }

      /**
       * Gets the currently selected main target scene from the UI.
       * @returns {string} The name of the selected OBS scene, or empty string if none.
       */
      function getTargetScene() { return obsSceneSelect.value || ''; }

      /**
       * Constructs the VDO.Ninja view URL for a given stream ID.
       * @param {string} streamId - The VDO.Ninja Stream ID.
       * @param {boolean} [includeCommonParams=true] - Whether to include common viewing parameters.
       * @returns {string} The constructed VDO.Ninja URL.
       */
      function getVdoNinjaViewUrl(streamId, includeCommonParams = true) {
          const room = vdoNinjaRoomInput.value.trim();
          const ninjaPassword = vdoNinjaPasswordInput.value;
          const baseUrl = getVdoNinjaBaseUrl(); // Use the potentially custom base URL
          let url = `${baseUrl}/?`;

          if (room) { // If a room name is provided, use room context
              url += `view=${encodeURIComponent(streamId)}&solo&room=${encodeURIComponent(room)}`;
          } else { // Otherwise, view the stream ID directly
              url += `view=${encodeURIComponent(streamId)}`;
          }

          if (ninjaPassword) { // Add password if provided
              url += `&password=${encodeURIComponent(ninjaPassword)}`;
          }
          if (includeCommonParams) { // Add common parameters for clean OBS source viewing
              url += "&cleanoutput&proaudio&ab=160&transparent&autoplay&codec=h264&noheader&webcursor"; 
          }
          return url;
      }

      /**
       * Initializes and loads the VDO.Ninja iframe with the appropriate URL.
       */
      function initializeVdoNinjaIframe() {
          const room = vdoNinjaRoomInput.value.trim();
          const streamIdsInput = vdoNinjaStreamIdsInput.value.trim(); // Comma-separated list of stream IDs
          
          if (!room && !streamIdsInput) { 
              logMessage("VDO.Ninja: Room Name or specific Stream ID(s) must be provided to connect."); 
              updateVdoNinjaButtonState(false); // Ensure UI reflects failed attempt
              return; 
          }
          
          const baseUrl = getVdoNinjaBaseUrl();
          let vdoNinjaUrl = `${baseUrl}/?`;

          if (room) {
              vdoNinjaUrl += `room=${encodeURIComponent(room)}`;
              // If specific stream IDs are also provided with a room, view only those IDs within the room
              if (streamIdsInput) {
                  const viewStreamIds = streamIdsInput.split(',').map(s => s.trim()).filter(s => s).join(',');
                  if (viewStreamIds) vdoNinjaUrl += `&view=${encodeURIComponent(viewStreamIds)}&solo`;
              }
          } else if (streamIdsInput) { // If no room, but stream IDs are provided, view them directly
              const viewStreamIds = streamIdsInput.split(',').map(s => s.trim()).filter(s => s).join(',');
              if (viewStreamIds) vdoNinjaUrl += `view=${encodeURIComponent(viewStreamIds)}`;
              else { // Should not happen if initial check passes, but defensive
                  logMessage("VDO.Ninja: Stream IDs provided but were empty after trimming.");
                  updateVdoNinjaButtonState(false);
                  return;
              }
          }

          if (vdoNinjaPasswordInput.value) { // Add password if provided
              vdoNinjaUrl += `&password=${encodeURIComponent(vdoNinjaPasswordInput.value)}`;
          }
          
          // Parameters for data-only connection to receive events from VDO.Ninja
          vdoNinjaUrl += "&cleanoutput&dataonly&nocursor&nopush&debug&noaudio&novideo&cors="+encodeURIComponent(window.location.origin);
          
          logMessage(`Initializing VDO.Ninja iframe with URL: ${vdoNinjaUrl}`);
          vdoNinjaIframe.src = 'about:blank'; // Clear previous content first
          vdoNinjaIframe.setAttribute('crossorigin', 'anonymous'); // Important for cross-origin communication
          // The 'allow' attribute is set in HTML, ensure it covers necessary permissions
          
          // Load the actual URL after a short delay to ensure 'about:blank' takes effect
          setTimeout(() => { 
              vdoNinjaIframe.src = vdoNinjaUrl; 
              vdoNinjaLastActivityTime = Date.now(); // Initialize activity time
          }, 100); 
      }

      // Event listener for messages from the VDO.Ninja iframe
      window.addEventListener("message", (event) => {
          const expectedOriginBase = getVdoNinjaBaseUrl(); // Get current base URL setting
          let parsedExpectedOrigin;
          try { 
              parsedExpectedOrigin = new URL(expectedOriginBase); 
          } catch (e) { 
              logMessage(`Invalid VDO.Ninja base URL in settings: ${expectedOriginBase}`);
              return; // Cannot validate origin if base URL is malformed
          }

          // Security check: ensure message is from the expected VDO.Ninja origin and iframe window
          if (event.origin !== parsedExpectedOrigin.origin || event.source !== vdoNinjaIframe.contentWindow) {
              // logMessage(`Ignoring message from unexpected origin (${event.origin}) or source.`); // For debugging
              return;
          }
          
          const data = event.data; // The message payload from VDO.Ninja
          vdoNinjaLastActivityTime = Date.now(); // Update last activity timestamp

          if (!vdoNinjaConnected) { // This is the first message, signifies successful iframe load and communication
              vdoNinjaConnected = true; // This state is set here, not in updateVdoNinjaButtonState
              updateVdoNinjaButtonState(true); // Update UI to connected state (enables inputs, changes button)
              if (vdoNinjaConnectionCheckTimer) { 
                  clearTimeout(vdoNinjaConnectionCheckTimer); 
                  vdoNinjaConnectionCheckTimer = null; 
              }
              logMessage("VDO.Ninja iframe connection established and active.");
          }

          // Process specific VDO.Ninja events
          if (data && data.streamID) {
              const streamId = data.streamID;
              const label = data.label || `Stream ${streamId}`; // Use a default label if none provided

              // Handle stream connection events
              if ((data.action === "view-connection" && data.value === true) || 
                  (data.action === "guest-connected") || // Guest joining a room
                  (data.action === "push-connection" && data.value === true)) { // Director push starting
                  logMessage(`VDO.Ninja stream connected/active: "${label}" (ID: ${streamId})`);
                  activeStreams[streamId] = { 
                      label, 
                      sourceCreated: false, // Initial state: not yet added to OBS
                      streamId, 
                      uuid: data.UUID || null, // Store UUID if available
                      connected: true 
                  };
                  updateStreamList(); // Update UI list of active streams
                  
                  // Automatically add source to OBS if checkbox is checked
                  if (autoAddSourcesCheckbox.checked) {
                      logMessage(`Auto-adding stream ${streamId} to OBS.`);
                      const targetInfo = getTargetSceneForStream(streamId, label);
                      addStreamToObs(streamId, label, targetInfo);
                  }
              } 
              // Handle stream disconnection events
              else if ((data.action === "view-connection" && data.value === false) ||
                         (data.action === "push-connection" && data.value === false)) {
                  if (activeStreams[streamId]) { // Check if we are tracking this stream
                      logMessage(`VDO.Ninja stream disconnected/inactive: "${label}" (ID: ${streamId})`);
                      // Automatically remove source from OBS if checkbox is checked
                      if (autoRemoveSourcesCheckbox && autoRemoveSourcesCheckbox.checked) {
                          logMessage(`Auto-removing stream ${streamId} from OBS.`);
                          removeStreamFromObs(streamId); // removeStreamFromObs handles OBS removal and state update
                      }
                      delete activeStreams[streamId]; // Remove from our tracked list
                      updateStreamList(); // Update UI
                  }
              } 
              // Handle label updates for an existing stream
              else if (data.action === "view-connection-info" && data.value && data.value.label) {
                  if (activeStreams[streamId]) {
                      if (activeStreams[streamId].label !== data.value.label) {
                          logMessage(`VDO.Ninja stream label updated for ID ${streamId}: "${data.value.label}" (was "${activeStreams[streamId].label}")`);
                          activeStreams[streamId].label = data.value.label;
                          updateStreamList(); // Update UI to reflect new label
                      }
                  }
              }
              // else if (data.action !== 'view-stats-updated') { // Avoid logging frequent stat updates
              //    logMessage(`VDO.Ninja message (ID: ${streamId}, Action: ${data.action}): ${JSON.stringify(data.value)}`);
              // }
          }
      }, false);

      /**
       * Starts a monitor to check for VDO.Ninja iframe connection activity.
       * If no activity for a while, assumes connection is lost.
       */
      function startVdoNinjaConnectionMonitor() {
          setInterval(() => {
              if (vdoNinjaConnected && (Date.now() - vdoNinjaLastActivityTime > 45000)) { // 45 seconds of inactivity
                  logMessage("VDO.Ninja connection lost (no activity from iframe). Attempting to reset.");
                  // Update UI to show lost connection, but keep inputs enabled for user to retry
                  vdoNinjaConnectionStatus.textContent = 'Status: Connection Lost';
                  vdoNinjaStatusIndicator.classList.add('error'); // Show error state
                  vdoNinjaStatusIndicator.classList.remove('connected');
                  
                  // Call disconnect which resets button to "Connect" and clears iframe
                  disconnectFromVdoNinja(); 
              }
          }, 30000); // Check every 30 seconds
      }

       /**
       * Adds a VDO.Ninja stream as a browser source to OBS.
       * @param {string} streamId - The VDO.Ninja Stream ID.
       * @param {string} streamLabel - The label of the stream.
       * @param {Object} [targetInfo=null] - Pre-calculated target scene info, or null to determine it.
       */
       /**
       * Adds a VDO.Ninja stream as a browser source to OBS.
       * It first checks if a highlighted version of the source exists; if so, it manages that.
       * Otherwise, it checks for a base version. If neither exists, it creates the base version.
       * @param {string} streamId - The VDO.Ninja Stream ID.
       * @param {string} streamLabel - The label of the stream.
       * @param {Object} [targetInfo=null] - Pre-calculated target scene info, or null to determine it.
       */
      /**
       * Adds a VDO.Ninja stream as a browser source to OBS.
       * It first checks if a highlighted version of the source exists; if so, it manages that and updates highlight state.
       * Otherwise, it checks for a base version. If neither exists, it creates the base version.
       * It also checks for and associates existing screen share sources for the stream.
       * @param {string} streamId - The VDO.Ninja Stream ID.
       * @param {string} streamLabel - The label of the stream.
       * @param {Object} [targetInfo=null] - Pre-calculated target scene info, or null to determine it.
       */

      async function addStreamToObs(streamId, streamLabel, targetInfo = null) {
          if (!obsConnected || !obs) {
              logMessage(`Cannot add stream "${streamLabel}" (${streamId}) to OBS: Not connected to OBS.`);
              return;
          }

          const resolvedTargetInfo = targetInfo || getTargetSceneForStream(streamId, streamLabel);
          const targetSceneName = resolvedTargetInfo.scene;
          const mappingRule = resolvedTargetInfo.mapping;

          if (!targetSceneName) {
              logMessage(`Cannot add stream "${streamLabel}" (${streamId}): Target OBS scene name is required but not set (no default and no mapping).`);
              return;
          }

          const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
          const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
          let effectiveSourceName = baseSourceName; // Default to base name, will be updated if highlighted or base exists
          let sourceReallyExistsGlobally = false;

          // --- MODIFIED EXISTENCE CHECK ---
          try {
              // Check for highlighted version first
              await sendRequest('GetInputSettings', { inputName: highlightedSourceName });
              logMessage(`Highlighted version '${highlightedSourceName}' found for stream ${streamId}. This will be managed.`);
              effectiveSourceName = highlightedSourceName;
              sourceReallyExistsGlobally = true;
              if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = true; // Mark as 'created' early
              highlightedStreamId = streamId; // Set global state if highlighted version is found
          } catch (e) {
              // Highlighted source doesn't exist or error checking it.
              if (!e.message.toLowerCase().includes("not found") || !e.message.toLowerCase().includes("does not exist") || !e.message.toLowerCase().includes("no source")) {
                  logMessage(`Error checking for highlighted source '${highlightedSourceName}': ${e.message}. Will check for base source.`);
              }
              // Now check for base version
              try {
                  await sendRequest('GetInputSettings', { inputName: baseSourceName });
                  logMessage(`Base version '${baseSourceName}' found for stream ${streamId}. This will be managed.`);
                  effectiveSourceName = baseSourceName; // Already default, but explicit.
                  sourceReallyExistsGlobally = true;
                  if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = true; // Mark as 'created'
                  // If base is found, it means it's not highlighted, so if this stream was previously highlightedStreamId, clear it
                  // However, this could conflict if another stream was highlighted.
                  // It's safer to let toggleHighlight manage clearing highlightedStreamId explicitly.
                  // If we found the base, and this IS the highlightedStreamId, something is inconsistent.
                  // For now, we only set highlightedStreamId if the *highlighted* source is found.
              } catch (e2) {
                  // Base source also doesn't exist or error checking it.
                  if (!e2.message.toLowerCase().includes("not found") && !e2.message.toLowerCase().includes("does not exist") || !e2.message.toLowerCase().includes("no source")) {
                      logMessage(`Error checking for base source '${baseSourceName}': ${e2.message}. Will attempt to create.`);
                  }
                  effectiveSourceName = baseSourceName; // Will be created with this name
                  sourceReallyExistsGlobally = false;
              }
          }
          // --- END MODIFIED EXISTENCE CHECK ---

          const mainDefaultScene = getTargetScene();
          let shouldCloneThisStreamToMain = false;
          if (mappingRule && mappingRule.sceneName !== mainDefaultScene && mappingRule.cloneToMain) {
              shouldCloneThisStreamToMain = true;
          }
          let shouldSwitchToThisScene = false;
          if (mappingRule && mappingRule.switchToScene) {
              shouldSwitchToThisScene = true;
          }

          const vdoNinjaStreamUrl = getVdoNinjaViewUrl(streamId);
          let canvasWidth = 1920, canvasHeight = 1080;
          try {
              const videoSettings = await sendRequest('GetVideoSettings');
              if (videoSettings && videoSettings.baseWidth && videoSettings.baseHeight) {
                  canvasWidth = videoSettings.baseWidth;
                  canvasHeight = videoSettings.baseHeight;
              }
          } catch (error) {
              logMessage(`Error getting OBS canvas size: ${error.message}. Using default ${canvasWidth}x${canvasHeight}.`);
          }

          const inputSettings = {
              url: vdoNinjaStreamUrl,
              width: canvasWidth,
              height: canvasHeight,
              fps: 30,
              reroute_audio: true,
              restart_when_active: false,
              shutdown: false
          };

          logMessage(`Managing source '${effectiveSourceName}' (exists: ${sourceReallyExistsGlobally}) for stream "${streamLabel}" in OBS scene '${targetSceneName}'. URL: ${vdoNinjaStreamUrl}`);
          if (shouldCloneThisStreamToMain) logMessage(` - Will also clone to main scene '${mainDefaultScene}'.`);
          if (shouldSwitchToThisScene) logMessage(` - Will also switch OBS to scene '${targetSceneName}'.`);

          try {
              let initialSceneItemId = null;
              let clonedSceneItemId = null;

              if (!sourceReallyExistsGlobally) {
                  logMessage(`Source '${baseSourceName}' does not exist globally. Creating it in scene '${targetSceneName}'.`);
                  await sendRequest('CreateInput', {
                      sceneName: targetSceneName,
                      inputName: baseSourceName,
                      inputKind: 'browser_source',
                      inputSettings,
                      sceneItemEnabled: true
                  });
                  effectiveSourceName = baseSourceName;
                  logMessage(`Source '${effectiveSourceName}' created and added to scene '${targetSceneName}'.`);
                  try {
                      const itemInfo = await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: effectiveSourceName });
                      initialSceneItemId = itemInfo.sceneItemId;
                  } catch (e) {
                      logMessage(`Warning: Couldn't get scene item ID for new source '${effectiveSourceName}' in '${targetSceneName}': ${e.message}`);
                  }
              } else {
                  logMessage(`Source '${effectiveSourceName}' already exists globally. Updating its settings.`);
                  await sendRequest('SetInputSettings', { inputName: effectiveSourceName, inputSettings });
                  try {
                      const itemInfo = await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: effectiveSourceName });
                      initialSceneItemId = itemInfo.sceneItemId;
                      logMessage(`Source '${effectiveSourceName}' found as item in scene '${targetSceneName}'.`);
                  } catch (e) {
                      if (e.message.toLowerCase().includes("not found") || e.message.toLowerCase().includes("no scene items")) {
                          logMessage(`Source '${effectiveSourceName}' exists globally but not in scene '${targetSceneName}'. Adding it.`);
                          const createItemResponse = await sendRequest('CreateSceneItem', { sceneName: targetSceneName, sourceName: effectiveSourceName });
                          initialSceneItemId = createItemResponse.sceneItemId;
                      } else { throw e; }
                  }
              }

              if (shouldCloneThisStreamToMain && mainDefaultScene && mainDefaultScene !== targetSceneName) {
                  logMessage(`Attempting to clone source '${effectiveSourceName}' to main scene '${mainDefaultScene}'.`);
                  try {
                      const itemInfo = await sendRequest('GetSceneItemId', { sceneName: mainDefaultScene, sourceName: effectiveSourceName });
                      clonedSceneItemId = itemInfo.sceneItemId;
                      logMessage(`Source '${effectiveSourceName}' already exists as an item in main scene '${mainDefaultScene}'.`);
                  } catch (e) {
                      if (e.message.toLowerCase().includes("not found") || e.message.toLowerCase().includes("no scene items")) {
                          logMessage(`Cloning source '${effectiveSourceName}' to main scene '${mainDefaultScene}'.`);
                          const createCloneResponse = await sendRequest('CreateSceneItem', { sceneName: mainDefaultScene, sourceName: effectiveSourceName });
                          clonedSceneItemId = createCloneResponse.sceneItemId;
                      } else {
                          logMessage(`Error checking for '${effectiveSourceName}' in main scene '${mainDefaultScene}' before cloning: ${e.message}`);
                      }
                  }
              }

              if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = true;

              if (initialSceneItemId) {
                  await applyTransformAndGrid(targetSceneName, effectiveSourceName, canvasWidth, canvasHeight, initialSceneItemId);
              }
              if (clonedSceneItemId) {
                  await applyTransformAndGrid(mainDefaultScene, effectiveSourceName, canvasWidth, canvasHeight, clonedSceneItemId);
              }

              const otherSceneCheckboxes = document.querySelectorAll('.other-scene-checkbox:checked');
              for (const checkbox of otherSceneCheckboxes) {
                  const otherSceneName = checkbox.value;
                  if (otherSceneName && otherSceneName !== targetSceneName && (!shouldCloneThisStreamToMain || otherSceneName !== mainDefaultScene)) {
                      logMessage(`Attempting to add/clone source '${effectiveSourceName}' to other selected scene '${otherSceneName}'.`);
                      try {
                          let otherSceneItemId = null;
                          try {
                               const itemInfo = await sendRequest('GetSceneItemId', { sceneName: otherSceneName, sourceName: effectiveSourceName });
                               otherSceneItemId = itemInfo.sceneItemId;
                               logMessage(`Source '${effectiveSourceName}' already an item in other scene '${otherSceneName}'.`);
                          } catch(e) { /* OK if not found */ }

                          if (!otherSceneItemId) {
                            logMessage(`Adding source '${effectiveSourceName}' as item to other scene '${otherSceneName}'.`);
                            const createItemResponse = await sendRequest('CreateSceneItem', { sceneName: otherSceneName, sourceName: effectiveSourceName });
                            otherSceneItemId = createItemResponse.sceneItemId;
                            if (otherSceneItemId) {
                                await applyTransformAndGrid(otherSceneName, effectiveSourceName, canvasWidth, canvasHeight, otherSceneItemId);
                            }
                          }
                      } catch (e) {
                          logMessage(`Error adding/cloning source '${effectiveSourceName}' to other scene '${otherSceneName}': ${e.message}`);
                      }
                  }
              }

              if (shouldSwitchToThisScene) {
                  logMessage(`Switching OBS current program scene to '${targetSceneName}'.`);
                  await sendRequest('SetCurrentProgramScene', { sceneName: targetSceneName });
              }
              logMessage(`Successfully processed stream "${streamLabel}" (${streamId}), effective OBS source: '${effectiveSourceName}'.`);

              // --- CHECK FOR EXISTING SCREEN SHARE SOURCE ---
              const screenShareSourceNameToCheck = `${getFullReactionPrefix()}_${streamId}:s`;
              try {
                  await sendRequest('GetInputSettings', { inputName: screenShareSourceNameToCheck });
                  logMessage(`Existing screen share source '${screenShareSourceNameToCheck}' found for stream ${streamId}. Associating it.`);
                  screenShareId = streamId; // Update global screenShareId
              } catch (e) {
                  // Screen share source doesn't exist, or error checking it. No action needed if not found.
                  if (!e.message.toLowerCase().includes("not found") || !e.message.toLowerCase().includes("does not exist") || !e.message.toLowerCase().includes("no source")) {
                      logMessage(`Error checking for existing screen share source '${screenShareSourceNameToCheck}': ${e.message}`);
                  }
                  // If the screen share was for this streamId and is now not found,
                  // removeScreenShareFromObs (called by user or auto-remove) would handle clearing screenShareId.
                  // Here we only *set* it if found.
              }
              // --- END CHECK FOR EXISTING SCREEN SHARE SOURCE ---

          } catch (error) {
              logMessage(`Error managing stream '${effectiveSourceName}' ("${streamLabel}") in OBS: ${error.message}`);
              if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = false;
          } finally {
              updateStreamList(); // This will now reflect updated highlightedStreamId and screenShareId
          }
      }

      /**
       * Applies transform (sizing, position) to a source in a scene, or triggers grid rearrangement.
       * @param {string} sceneName - The name of the OBS scene.
       * @param {string} sourceName - The name of the source.
       * @param {number} canvasWidth - The width of the OBS canvas.
       * @param {number} canvasHeight - The height of the OBS canvas.
       * @param {number} [sceneItemId=null] - The ID of the scene item (optional, will be fetched if null).
       */
      async function applyTransformAndGrid(sceneName, sourceName, canvasWidth, canvasHeight, sceneItemId = null) {
          if (!sceneName) {
              logMessage(`Cannot apply transform for source '${sourceName}': Scene name not provided.`);
              return;
          }
          let itemIdToTransform = sceneItemId;

          // If sceneItemId is not provided, try to fetch it
          if (!itemIdToTransform) { 
              try {
                  logMessage(`Workspaceing scene item ID for '${sourceName}' in '${sceneName}' to apply transform.`);
                  const itemInfo = await sendRequest('GetSceneItemId', { sceneName, sourceName });
                  if (itemInfo && itemInfo.sceneItemId) {
                      itemIdToTransform = itemInfo.sceneItemId;
                  } else {
                      logMessage(`Could not find scene item ID for '${sourceName}' in '${sceneName}'. Cannot apply transform.`);
                      return;
                  }
              } catch (error) {
                  logMessage(`Error fetching scene item ID for transform of '${sourceName}' in '${sceneName}': ${error.message}. Cannot apply transform.`);
                  return;
              }
          }

          if (!itemIdToTransform) { // Should be redundant if above logic is correct, but as a safeguard
              logMessage(`Cannot apply transform for '${sourceName}' in '${sceneName}': Valid Scene Item ID not available.`);
              return;
          }

          // If auto-grid is selected, rearrange all relevant streams in the scene
          if (sourceSizingSelect.value === 'autoGrid') {
              logMessage(`Auto-grid enabled for scene '${sceneName}'. Triggering rearrange.`);
              // It's generally better to call rearrangeAllStreamsInScene once after all items for a scene are processed.
              await rearrangeAllStreamsInScene(sceneName); 
          } else { // Otherwise, apply individual transform based on selected sizing mode
              try {
                  const transform = calculateTransform(sourceSizingSelect.value, canvasWidth, canvasHeight, canvasWidth, canvasHeight); // Assuming source is canvas sized initially
                  logMessage(`Applying non-grid transform ('${sourceSizingSelect.value}') to '${sourceName}' (Item ID: ${itemIdToTransform}) in '${sceneName}'.`);
                  await sendRequest('SetSceneItemTransform', { 
                      sceneName, 
                      sceneItemId: itemIdToTransform, 
                      sceneItemTransform: transform 
                  });
              } catch (error) {
                  logMessage(`Error applying non-grid transform to '${sourceName}' (Item ID: ${itemIdToTransform}) in '${sceneName}': ${error.message}`);
              }
          }
      }

      /**
       * Rearranges all VDO.Ninja sources in a given scene according to the auto-grid layout.
       * @param {string} sceneName - The name of the OBS scene to rearrange.
       */
      async function rearrangeAllStreamsInScene(sceneName) {
          if (!obsConnected || !obs || !sceneName || sourceSizingSelect.value !== 'autoGrid') {
              if (sourceSizingSelect.value !== 'autoGrid') return; // Only run if autoGrid is selected
              logMessage(`Cannot rearrange streams in scene '${sceneName}': OBS not connected, scene name missing, or auto-grid not selected.`);
              return;
          }
          logMessage(`Rearranging VDO.Ninja streams in scene '${sceneName}' using autoGrid layout.`);
          
          try {
              let canvasWidth = 1920, canvasHeight = 1080; // Default canvas size
              try { // Get actual OBS canvas dimensions
                  const videoSettings = await sendRequest('GetVideoSettings');
                  if (videoSettings && videoSettings.baseWidth && videoSettings.baseHeight) {
                      canvasWidth = videoSettings.baseWidth; 
                      canvasHeight = videoSettings.baseHeight;
                  }
              } catch (error) { 
                  logMessage(`Canvas size error during rearrange for scene '${sceneName}': ${error.message}. Using default ${canvasWidth}x${canvasHeight}.`);
              }

              const sceneItemsResponse = await sendRequest('GetSceneItemList', { sceneName });
              const camPrefixWithUnderscore = getFullCameraPrefix() + "_"; // For precise matching

              // Filter for active VDO.Ninja camera sources in the scene
              // This includes regular sources and sources that might be currently highlighted (which have a different prefix)
              const vdoNinjaSourcesInScene = sceneItemsResponse.sceneItems.filter(item => {
                  const isRegularCameraSource = item.sourceName.startsWith(camPrefixWithUnderscore);
                  const isHighlightedCameraSource = item.sourceName.startsWith(getFullHighlightPrefix() + "_");
                  
                  // Check if the source (regular or highlighted) corresponds to an *active* stream
                  let streamIdFromSourceName = null;
                  if (isRegularCameraSource) {
                      streamIdFromSourceName = item.sourceName.substring(camPrefixWithUnderscore.length);
                  } else if (isHighlightedCameraSource) {
                      streamIdFromSourceName = item.sourceName.substring((getFullHighlightPrefix() + "_").length);
                  }

                  return (isRegularCameraSource || isHighlightedCameraSource) &&
                         streamIdFromSourceName &&
                         activeStreams[streamIdFromSourceName] && 
                         activeStreams[streamIdFromSourceName].connected &&
                         activeStreams[streamIdFromSourceName].sourceCreated; // Ensure it's meant to be in OBS
              });


              if (vdoNinjaSourcesInScene.length === 0) {
                  logMessage(`No active VDO.Ninja sources found in scene '${sceneName}' to rearrange for auto-grid.`);
                  return;
              }

              const positions = calculateGridPositions(vdoNinjaSourcesInScene.length, canvasWidth, canvasHeight);
              
              logMessage(`Calculated ${positions.length} grid positions for ${vdoNinjaSourcesInScene.length} sources in '${sceneName}'.`);

              for (let i = 0; i < vdoNinjaSourcesInScene.length; i++) {
                  const item = vdoNinjaSourcesInScene[i];
                  // Source width/height for calculateTransform should ideally be the item's actual dimensions,
                  // but for browser sources, OBS often uses the canvas dimensions as the base.
                  const transform = calculateTransform('autoGrid', canvasWidth, canvasHeight, canvasWidth, canvasHeight, positions[i]);
                  logMessage(`Applying grid transform to '${item.sourceName}' (Item ID: ${item.sceneItemId}) in '${sceneName}': Pos X:${transform.positionX.toFixed(0)}, Y:${transform.positionY.toFixed(0)}, W:${transform.width.toFixed(0)}, H:${transform.height.toFixed(0)}`);
                  await sendRequest('SetSceneItemTransform', { 
                      sceneName, 
                      sceneItemId: item.sceneItemId, 
                      sceneItemTransform: transform 
                  });
              }
              logMessage(`Successfully rearranged ${vdoNinjaSourcesInScene.length} VDO.Ninja sources in scene '${sceneName}'.`);
          } catch (error) { 
              logMessage(`Error rearranging streams in scene '${sceneName}': ${error.message}`); 
          }
      }

      /**
       * Calculates the transform object for an OBS scene item based on sizing mode.
       * @param {string} sizingMode - The sizing mode (e.g., 'defaultSize', 'bestFit', 'autoGrid').
       * @param {number} sourceWidth - The original width of the source.
       * @param {number} sourceHeight - The original height of the source.
       * @param {number} canvasWidth - The width of the OBS canvas.
       * @param {number} canvasHeight - The height of the OBS canvas.
       * @param {Object} [gridPosition=null] - Position object for 'autoGrid' {x, y, width, height}.
       * @returns {Object} The OBS transform object.
       */
      function calculateTransform(sizingMode, sourceWidth, sourceHeight, canvasWidth, canvasHeight, gridPosition = null) {
          // Default transform: centered, original size
          let transform = { 
              alignment: 5, // Center alignment
              boundsType: "OBS_BOUNDS_NONE", // No bounds by default
              boundsAlignment: 0, // Alignment within bounds (not relevant for NONE)
              boundsWidth: sourceWidth, 
              boundsHeight: sourceHeight, 
              positionX: (canvasWidth - sourceWidth) / 2, // Center X
              positionY: (canvasHeight - sourceHeight) / 2, // Center Y
              scaleX: 1.0, 
              scaleY: 1.0, 
              rotation: 0.0, 
              cropTop: 0, cropBottom: 0, cropLeft: 0, cropRight: 0, 
              sourceWidth: sourceWidth, // Original source dimensions
              sourceHeight: sourceHeight,
              width: sourceWidth, // Actual width on canvas (after scaling, before bounds)
              height: sourceHeight // Actual height on canvas
          };

          switch (sizingMode) {
              case 'stretchToFill': 
                  transform.boundsType = "OBS_BOUNDS_STRETCH"; 
                  transform.boundsWidth = canvasWidth; 
                  transform.boundsHeight = canvasHeight;
                  transform.width = canvasWidth; // Set final width/height to canvas size
                  transform.height = canvasHeight;
                  transform.positionX = 0; // Position at top-left
                  transform.positionY = 0;
                  break;
              case 'bestFit':       
                  transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; // Scale to fit inside bounds, preserving aspect
                  transform.boundsWidth = canvasWidth; 
                  transform.boundsHeight = canvasHeight;
                  transform.width = canvasWidth; 
                  transform.height = canvasHeight;
                  transform.positionX = 0; 
                  transform.positionY = 0;
                  break;
              case 'autoGrid':
                  if (gridPosition) { // If grid position data is provided
                      transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; // Fit within the grid cell, preserving aspect
                      transform.positionX = gridPosition.x; 
                      transform.positionY = gridPosition.y;
                      transform.boundsWidth = gridPosition.width; 
                      transform.boundsHeight = gridPosition.height;
                      transform.width = gridPosition.width; 
                      transform.height = gridPosition.height;
                  } else { // Fallback if no grid position (should ideally not happen if called correctly)
                      logMessage("Warning: autoGrid sizing mode called without gridPosition. Falling back to 'bestFit'.");
                      transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; 
                      transform.boundsWidth = canvasWidth; transform.boundsHeight = canvasHeight;
                      transform.width = canvasWidth; transform.height = canvasHeight;
                      transform.positionX = 0; transform.positionY = 0;
                  }
                  break;
              case 'defaultSize': // Already handled by the initial transform object settings
              default: 
                  // Default is centered, original size. If canvas is different from source, it stays centered.
                  // If source is larger than canvas, it will be clipped unless bounds are set.
                  // For browser sources often set to canvas size, so this effectively means 1:1 at center.
                  break; 
          }
          return transform;
      }

      /**
       * Removes a VDO.Ninja stream's source(s) from OBS scenes.
       * @param {string} streamId - The VDO.Ninja Stream ID to remove.
       */
      async function removeStreamFromObs(streamId) {
          if (!obsConnected || !obs) {
              logMessage(`Cannot remove stream ${streamId} from OBS: Not connected to OBS.`);
              return;
          }
          if (!activeStreams[streamId] && streamId !== screenShareId && streamId !== highlightedStreamId) { // Allow removal even if not in activeStreams IF it's a current screenShare/highlight
              logMessage(`Stream ${streamId} not found in active local streams list. Removal process may be incomplete if it was not a shared resource (screen/highlight).`);
              // Continue, as it might be a leftover source in OBS or a shared resource.
          }

          const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
          const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
          logMessage(`User or auto-triggered removal of stream '${streamId}' from OBS. Base source: '${baseSourceName}', Highlighted: '${highlightedSourceName}'.`);

          const streamInfo = activeStreams[streamId]; // Might be undefined if stream already left VDO.Ninja
          const currentLabel = streamInfo ? streamInfo.label : `Stream ${streamId}`;
          const targetInfo = getTargetSceneForStream(streamId, currentLabel); // Get its mapped/default scene

          // Collect all scenes where this stream's source item(s) might exist
          const scenesToClean = new Set();
          if (targetInfo && targetInfo.scene) { // Mapped or default scene for this stream
              scenesToClean.add(targetInfo.scene);
          }
          const globalMainScene = getTargetScene(); // Current global default scene from dropdown
          if (globalMainScene) {
              scenesToClean.add(globalMainScene);
          }
          // Add scenes selected in "Copy sources to other scenes(reference)"
          document.querySelectorAll('.other-scene-checkbox:checked').forEach(checkbox => {
              if (checkbox.value) scenesToClean.add(checkbox.value);
          });

          let itemRemovedThisRun = false;

          // Attempt to remove the source item (regular or highlighted) from each relevant scene
          for (const sceneName of scenesToClean) {
              if (!sceneName) continue; // Skip if scene name is empty

              // Determine the name to look for (highlighted name takes precedence if this stream was highlighted)
              let nameToRemoveInScene = (highlightedStreamId === streamId) ? highlightedSourceName : baseSourceName;
              
              if (await tryRemoveFromScene(nameToRemoveInScene, sceneName)) {
                  itemRemovedThisRun = true;
              } else {
                  // If removing the expected name failed (e.g. highlighted name),
                  // also try removing the base name, in case our state was out of sync or it was never highlighted in this instance.
                  if (nameToRemoveInScene === highlightedSourceName) {
                      if (await tryRemoveFromScene(baseSourceName, sceneName)) {
                          itemRemovedThisRun = true;
                      }
                  }
              }
          }

          // If this stream was the one globally highlighted, clear our internal highlight state.
          if (highlightedStreamId === streamId) {
              logMessage(`Stream ${streamId} was highlighted. Clearing global highlight state.`);
              highlightedStreamId = null;
          }

          // If this stream was also being screen-shared, initiate its removal.
          if (screenShareId === streamId) {
              logMessage(`Stream ${streamId} was actively screen sharing. Initiating screen share removal.`);
              await removeScreenShareFromObs(streamId); // This function handles its own source removal and updates.
          }

          // Update the local state for this stream if it's still in our active list
          if (activeStreams[streamId]) { 
              activeStreams[streamId].sourceCreated = false; // Mark as no longer in OBS
          }

          if (itemRemovedThisRun) {
              logMessage(`Finished removing source items for stream ${streamId} from specified OBS scenes.`);
          } else {
              logMessage(`No active source items for stream ${streamId} (regular or highlighted) seemed to be present in the specified OBS scenes during this removal pass.`);
          }
          
          // After removal, if auto-grid is enabled, rearrange streams in affected scenes.
          if (sourceSizingSelect.value === 'autoGrid') {
              const uniqueScenesProcessed = new Set(Array.from(scenesToClean).filter(s => s)); // Valid scene names
              for (const sceneName of uniqueScenesProcessed) {
                  logMessage(`Auto-grid: Triggering rearrange for scene '${sceneName}' after stream removal.`);
                  // Delay slightly to allow OBS to fully process removals before rearranging
                  setTimeout(() => rearrangeAllStreamsInScene(sceneName), 250); 
              }
          }
          
          // Update UI list unless screen share removal already did it
          if (screenShareId !== streamId) { // Avoid double update if removeScreenShareFromObs was called
              updateStreamList();
          }
          saveSettings(); // Persist any state changes (e.g., cleared highlightedStreamId)
      }

      /**
       * Removes a screen share source from all OBS scenes and deletes the input.
       * @param {string} streamIdToRemove - The Stream ID whose screen share source should be removed.
       */
      async function removeScreenShareFromObs(streamIdToRemove) {
          if (!obsConnected || !obs) {
              logMessage("Cannot remove screen share: Not connected to OBS.");
              return;
          }
          if (!streamIdToRemove) { // Should not happen if called correctly
              logMessage("Cannot remove screen share: streamIdToRemove is null or undefined.");
              if (screenShareId === streamIdToRemove) { // If current global share was this null ID
                  screenShareId = null;
                  updateStreamList(); 
              }
              return;
          }

          const sourceName = `${getFullReactionPrefix()}_${streamIdToRemove}:s`; // Construct screen share source name
          logMessage(`Attempting to fully remove screen share source '${sourceName}' from OBS (all scenes and input).`);

          let itemRemovedFromAnyScene = false;
          try {
              // Iterate through all scenes in OBS to find and remove the scene item
              const scenesResponse = await sendRequest('GetSceneList');
              if (scenesResponse && scenesResponse.scenes) {
                  for (const scene of scenesResponse.scenes) {
                      if (await tryRemoveFromScene(sourceName, scene.sceneName)) {
                          itemRemovedFromAnyScene = true; // Track if item was found and removed from at least one scene
                      }
                  }
              }

              // After attempting to remove from all scenes, try to remove the input (source) itself
              try {
                  await sendRequest('GetInputSettings', { inputName: sourceName }); // Check if input exists
                  logMessage(`Removing global input '${sourceName}' from OBS.`);
                  await sendRequest('RemoveInput', { inputName: sourceName });
                  logMessage(`Successfully removed input '${sourceName}'.`);
              } catch (e) {
                  if (!e.message.toLowerCase().includes("not found") || !e.message.toLowerCase().includes("does not exist") || !e.message.toLowerCase().includes("no source")) {
                      logMessage(`Input '${sourceName}' did not exist globally for removal (already gone or never created).`);
                  } else if (itemRemovedFromAnyScene) { 
                      // If items were removed from scenes but global input removal failed
                      logMessage(`Removed '${sourceName}' items from scenes, but global input removal failed (may be in use by something else or error): ${e.message}`);
                  } else {
                       logMessage(`Input '${sourceName}' not found for global removal and was not found as an item in any scene.`);
                  }
              }

          } catch (error) {
              logMessage(`Error during screen share removal process for '${sourceName}': ${error.message}`);
          } finally {
              // Ensure the global state is updated if this was the active screen share
              if (screenShareId === streamIdToRemove) {
                  screenShareId = null;
              }
              updateStreamList(); // Refresh UI to reflect the change
              // saveSettings(); // If screenShareId were part of saved settings and needs persisting
          }
      }

      /**
       * Attempts to remove a source item from a specific OBS scene.
       * @param {string} sourceName - The name of the source item to remove.
       * @param {string} sceneName - The name of the scene.
       * @returns {Promise<boolean>} True if removal was successful or item didn't exist, false on error.
       */
      async function tryRemoveFromScene(sourceName, sceneName) {
          if (!sceneName) {
              logMessage(`Cannot remove source '${sourceName}': Scene name not provided.`);
              return false;
          }
          try {
              // Get the ID of the scene item
              const itemInfo = await sendRequest('GetSceneItemId', { sceneName, sourceName });
              if (itemInfo && itemInfo.sceneItemId) {
                  logMessage(`Removing source item '${sourceName}' (ID: ${itemInfo.sceneItemId}) from scene '${sceneName}'.`);
                  await sendRequest('RemoveSceneItem', { sceneName, sceneItemId: itemInfo.sceneItemId });
                  logMessage(`Successfully removed '${sourceName}' from scene '${sceneName}'.`);
                  return true; // Successfully removed
              } else {
                  // This case should be caught by the GetSceneItemId error if item not found.
                  // logMessage(`Source item '${sourceName}' not found in scene '${sceneName}' (itemInfo missing ID).`);
                  return false; // Item ID not found in response, though request was "successful"
              }
          } catch (error) {
              // If error indicates "not found", it's not a critical failure for removal, just means it wasn't there.
              if (error.message.toLowerCase().includes("not found") || 
                  error.message.toLowerCase().includes("no scene items were found") ||
                  error.message.toLowerCase().includes("could not find")) {
                  // logMessage(`Source item '${sourceName}' not found in scene '${sceneName}' for removal.`);
              } else { // Log other, unexpected errors
                  logMessage(`Error trying to remove source item '${sourceName}' from scene '${sceneName}': ${error.message}`);
              }
              return false; // Item not found or error occurred
          }
      }

      /**
       * Loads the jsSHA library for SHA256 hashing if Web Crypto API is not available.
       * @returns {Promise<void>} Resolves when the library is loaded or already available.
       */
      function loadJsShaLibrary() {
          return new Promise((resolve, reject) => {
              if (typeof jsSHA !== 'undefined') { // Check if already loaded
                  resolve(); 
                  return; 
              }
              const script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jsSHA/3.3.0/sha256.js'; // CDN link for jsSHA
              script.onload = () => {
                  logMessage("jsSHA library loaded successfully (fallback for Web Crypto).");
                  resolve();
              };
              script.onerror = () => {
                  logMessage("Error: Failed to load jsSHA library. OBS authentication might fail if Web Crypto is also unavailable.");
                  reject(new Error('Failed to load jsSHA library'));
              };
              document.head.appendChild(script);
          });
      }

      // Ensure these are defined globally if accessed by functions like updateOtherScenesList directly
      const otherScenesContainer = document.getElementById('otherScenesContainer');
      const otherScenesListDiv = document.getElementById('otherScenesList'); 
      const screenShareSceneSelect = document.getElementById('screenShareSceneSelect');


      // Event Listeners for UI elements changing
      obsSceneSelect.addEventListener('change', () => {
          obsSceneNameInput.value = obsSceneSelect.value; // Sync hidden input
          saveSettings();
          updateOtherScenesList(); // Update available "other scenes" based on new main scene selection
          updateStreamList(); // Update target scene display for active streams if it depends on main scene
          // If auto-grid is on, might want to rearrange the new main scene
          if (sourceSizingSelect.value === 'autoGrid' && getTargetScene()) {
              rearrangeAllStreamsInScene(getTargetScene());
          }
      });

      // Add change listeners to all relevant input fields to save settings automatically
      [ obsWsUrlInput, obsWsPasswordInput, 
        vdoNinjaBaseUrlInput, vdoNinjaRoomInput, vdoNinjaPasswordInput, vdoNinjaStreamIdsInput, 
        autoAddSourcesCheckbox, autoRemoveSourcesCheckbox
      ].forEach(el => {
          if (el) el.addEventListener('change', saveSettings);
      });

      sourceSizingSelect.addEventListener('change', () => {
          saveSettings();
          // If auto-grid is selected, rearrange sources in the current target scene and any linked "other" scenes.
          if (sourceSizingSelect.value === 'autoGrid') {
              const mainTargetScene = getTargetScene();
              if (mainTargetScene) {
                  rearrangeAllStreamsInScene(mainTargetScene);
              }
              document.querySelectorAll('.other-scene-checkbox:checked').forEach(checkbox => {
                  if (checkbox.value) rearrangeAllStreamsInScene(checkbox.value);
              });
          }
      });

      loadScenesBtn.addEventListener('click', fetchObsScenes);

      if (screenShareSceneSelect) {
          screenShareSceneSelect.addEventListener('change', saveSettings);
      }
      // Also save settings if screen share dimensions change
      const screenShareWidthInput = document.getElementById('screenShareWidth');
      const screenShareHeightInput = document.getElementById('screenShareHeight');
      if (screenShareWidthInput) screenShareWidthInput.addEventListener('change', saveSettings);
      if (screenShareHeightInput) screenShareHeightInput.addEventListener('change', saveSettings);


      // Initial setup when the DOM is fully loaded
      document.addEventListener('DOMContentLoaded', () => {
          loadSettings(); // Load all saved settings first (includes prefixes, VDO base URL etc.)
          logMessage("VDO.Ninja OBS Control Dock Initialized. Welcome!");
          
          // Initial UI state for VDO.Ninja connection controls
          updateVdoNinjaButtonState(false); // Ensures button is "Connect" and inputs are enabled
          toggleVdoNinjaInputs(false);      // Explicitly enable VDO.Ninja inputs after loading settings

          // Add blur effect to sensitive-ish fields for privacy until focused
          const secureFields = document.querySelectorAll('#vdoNinjaRoom, #vdoNinjaStreamIds');
          secureFields.forEach(field => {
              field.classList.add('blur-field');
              field.addEventListener('focus', () => field.classList.remove('blur-field'));
              field.addEventListener('blur', () => { if (field.value === '') field.classList.add('blur-field'); });
          });
          
          startVdoNinjaConnectionMonitor(); // Start checking for VDO.Ninja iframe activity
          updatePrefixLabels(); // Ensure prefix labels are correct on load
      });
    </script>
  </body>
</html>