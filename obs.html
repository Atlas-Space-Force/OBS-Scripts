<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VDO.Ninja OBS Control Dock</title>
    <style>
      body {
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif; /* Modern font stack */
        margin: 0; /* Remove default margin */
        padding: 15px; /* Add some padding around the whole page */
        background-color: #181a1b; /* Slightly different dark */
        color: #e0e0e0;
        font-size: 14px; /* Base font size */
        line-height: 1.6; /* Improved readability */
      }
      .container {
        margin-bottom: 15px; /* Increased spacing */
        padding: 15px; /* Increased padding */
        background-color: #2c2e33; /* Darker, richer container */
        border-radius: 8px; /* More rounded */
        border: 1px solid #3e4147; /* Softer border */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
      }
      .collapsible {
        cursor: pointer;
        user-select: none;
        padding: 12px 15px;
        position: relative;
        font-weight: 600;
        font-size: 1.1em;
        background: #35383d;
        margin: -15px -15px 10px -15px;
        padding-left: 15px;
        border-bottom: 1px solid #3e4147;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        transition: background-color 0.2s ease;
      }
      .collapsible.collapsed {
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        margin-bottom: 0;
        border-bottom: none;
      }
      .container .collapsible:last-child.collapsed {
        margin-bottom: -15px;
      }
      .collapsible[data-state="expand"]::after {
        content: "▼";
      }
      .collapsible[data-state="collapse"]::after {
        content: "▲";
      }
      .collapsible::after {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 14px;
        color: #a0a0b0;
        transition: transform 0.2s ease;
      }
      .collapsible[data-state="expand"]::before {
        content: "Click to expand";
      }
      .collapsible[data-state="collapse"]::before {
        content: "Click to collapse";
      }
      .collapsible::before {
        position: absolute;
        right: 40px;
        font-size: 10px;
        color: #666;
        font-weight: normal;
      }
      .collapsible:hover {
        background: #404348;
      }
      .collapsible-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out, padding-top 0.3s ease-in-out,
          opacity 0.3s ease-in-out;
        padding-top: 10px;
        opacity: 1;
      }
      .collapsible-content.collapsed {
        max-height: 0;
        padding-top: 0;
        opacity: 0;
        overflow: hidden;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500; /* Slightly bolder labels */
        color: #c0c0c0; /* Lighter labels */
      }
      input[type="text"],
      input[type="password"],
      input[type="number"],
      select {
        width: calc(
          100% - 22px
        ); /* Adjusted width calculation for padding (10px each side + 1px border each side) */
        padding: 10px; /* More padding */
        margin-bottom: 12px; /* More spacing */
        border: 1px solid #4a4d54; /* Softer border */
        border-radius: 6px; /* More rounded */
        background-color: #25272c; /* Darker input background */
        color: #e0e0e0;
        font-size: 1em;
        box-sizing: border-box; /* Ensures padding and border don't increase width */
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      input[type="text"]:focus,
      input[type="password"]:focus,
      input[type="number"]:focus,
      select:focus {
        border-color: #007aff; /* Accent color on focus */
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25); /* Focus ring */
        outline: none;
      }
      select {
        padding-right: 30px; /* Make space for the arrow */
        appearance: none; /* For custom arrow */
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23A0A0B0'%3E%3Cpath d='M8 11L3 6h10L8 11z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 12px;
      }
      button {
        padding: 10px 15px; /* Larger padding */
        background-color: #4a5060; /* Default button color */
        color: white;
        border: none;
        border-radius: 6px; /* More rounded */
        cursor: pointer;
        margin-right: 5px;
        margin-bottom: 5px;
        font-size: 0.95em;
        font-weight: 500;
        transition: background-color 0.2s ease, transform 0.1s ease;
      }
      button:hover {
        background-color: #5a6070; /* Darker hover */
      }
      button:active {
        transform: translateY(1px); /* Click effect */
      }
      button.connected {
        background-color: #007aff; /* Modern blue for connected */
      }
      button.connected:hover {
        background-color: #0056b3;
      }
      button.disconnected {
        background-color: #6c757d; /* Grey for disconnected */
      }
      button.disconnected:hover {
        background-color: #5a6268;
      }
      .blur-field {
        filter: blur(5px);
        transition: filter 0.2s ease;
      }
      .blur-field:focus {
        filter: blur(0);
      }
      #vdoNinjaIframe {
        width: 1px;
        height: 1px;
        position: absolute;
        left: -1000px;
        top: -1000px;
        border: 0;
      }
      .log-area {
        height: 120px; /* Slightly taller */
        background-color: #202225; /* Consistent dark background */
        color: #b0b0b0; /* Softer log text */
        border: 1px solid #4a4d54;
        border-radius: 6px; /* Rounded */
        overflow-y: scroll;
        padding: 10px;
        font-family: "Consolas", "Monaco", "Lucida Console", monospace; /* Monospace for logs */
        font-size: 0.9em;
        margin-top: 10px;
        white-space: pre-wrap;
      }
      .status-indicator {
        display: inline-block;
        width: 10px; /* Slightly larger */
        height: 10px; /* Slightly larger */
        border-radius: 50%;
        margin-left: 8px;
        background-color: #555;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }
      .status-indicator.connected {
        background-color: #007aff; /* Consistent blue */
        box-shadow: 0 0 8px rgba(0, 122, 255, 0.7); /* Glow effect */
      }
      .status-indicator.error {
        background-color: #dc3545; /* Standard error red */
        box-shadow: 0 0 8px rgba(220, 53, 69, 0.7); /* Glow effect */
      }
      .stream-list {
        background-color: #202225;
        border: 1px solid #4a4d54;
        border-radius: 6px;
        padding: 5px; /* Reduced overall padding for stream list */
        margin-top: 5px;
        transition: max-height 0.3s ease;
      }
      .stream-list:empty {
        min-height: 40px; /* Adjusted height */
        display: flex;
        align-items: center;
        justify-content: center;
        color: #888; /* Softer text for empty state */
        padding: 10px; /* Padding for empty state text */
      }
      .stream-item {
        padding: 10px 12px; /* More padding */
        border-bottom: 1px solid #383b40; /* Softer separator */
        font-size: 1em; /* Standardized font size */
        word-break: break-word;
        background-color: #2c2e33; /* Slightly different background for items */
        margin: 0 0 8px 0; /* Space between items, remove side margins */
        border-radius: 4px; /* Rounded items */
      }
      .stream-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
      }
      h1 {
        color: #d0d0d0;
        margin: 0 0 20px 0; /* h1 margin */
        padding-bottom: 15px;
        font-size: 1.8em; /* h1 size */
        font-weight: 600;
        border-bottom: 1px solid #3e4147; /* Separator for main title */
      }
      h2 {
        /* Base h2 styles, .collapsible will add more */
        color: #c8c8c8;
        margin: 5px 0;
        font-size: 1.1em;
      }
      small {
        color: #9090a0; /* Softer small text */
        font-size: 0.88em;
        display: block; /* Make small text take its own line often */
        margin-top: 3px;
        line-height: 1.4;
      }
      /* Specific Button Color Overrides */
      /* Note: These rely on the JS setting specific inline background-color styles. */
      .add-stream-btn {
        /* Default "Add to OBS" */
        background-color: #28a745 !important; /* Green for add */
      }
      .add-stream-btn:hover {
        background-color: #218838 !important;
      }
      /* For "Remove from OBS" when JS changes inline style to red */
      button.add-stream-btn[style*="rgb(244, 67, 54)"],
      button.add-stream-btn[style*="#F44336"] {
        background-color: #dc3545 !important; /* Red for remove */
      }
      button.add-stream-btn[style*="rgb(244, 67, 54)"]:hover,
      button.add-stream-btn[style*="#F44336"]:hover {
        background-color: #c82333 !important;
      }
      .highlight-btn {
        /* Default "Highlight" */
        background-color: #17a2b8 !important; /* Info blue/teal */
      }
      .highlight-btn:hover {
        background-color: #138496 !important;
      }
      /* For "Unhighlight" when JS changes inline style to red */
      button.highlight-btn[style*="rgb(244, 67, 54)"],
      button.highlight-btn[style*="#F44336"] {
        background-color: #ffc107 !important; /* Warning yellow */
        color: #212529 !important; /* Dark text for yellow button */
      }
      button.highlight-btn[style*="rgb(244, 67, 54)"]:hover,
      button.highlight-btn[style*="#F44336"]:hover {
        background-color: #e0a800 !important;
      }
      .screen-share-btn {
        /* Default "Screen Share" */
        background-color: #6f42c1 !important; /* Purple */
      }
      .screen-share-btn:hover {
        background-color: #5a2aa8 !important;
      }
      /* For "Stop Screen Share" when JS changes inline style to red */
      button.screen-share-btn[style*="rgb(244, 67, 54)"],
      button.screen-share-btn[style*="#F44336"] {
        background-color: #fd7e14 !important; /* Orange for stop */
      }
      button.screen-share-btn[style*="rgb(244, 67, 54)"]:hover,
      button.screen-share-btn[style*="#F44336"]:hover {
        background-color: #e66c00 !important;
      }
      .status-line {
        font-size: 1em; /* Consistent font size */
        margin-top: 10px;
        display: flex;
        align-items: center;
      }
      #obsConnectionStatus,
      #vdoNinjaConnectionStatus {
        /* Status text styling */
        margin-left: 8px;
        color: #b0b0b0;
      }
      input[type="checkbox"] {
        accent-color: #007aff; /* Modern blue */
        margin-right: 8px; /* More space */
        width: 15px; /* Custom size */
        height: 15px;
        vertical-align: middle;
        flex-shrink: 0; /* Prevent shrinking in flex layouts */
      }
      .checkbox-label {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        color: #c0c0c0;
        font-size: 0.95em;
      }
      .checkbox-label input {
        /* Target checkbox within our label structure */
        margin-bottom: 0; /* Align with label text */
        margin-right: 8px;
      }
      /* Scrollbar styles - refine with new palette */
      ::-webkit-scrollbar {
        width: 10px; /* Slightly wider */
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: #202225; /* Dark track */
        border-radius: 5px;
      }
      ::-webkit-scrollbar-thumb {
        background: #4a4d54; /* Scrollbar thumb */
        border-radius: 5px;
        border: 2px solid #202225; /* Creates a "padding" effect */
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #007aff; /* Accent on hover */
      }
      * {
        /* Firefox scrollbar styling */
        scrollbar-width: auto; /* Or 'thin' if preferred */
        scrollbar-color: #4a4d54 #202225; /* thumb track */
      }
      .flex-row {
        display: flex;
        gap: 8px; /* Increased gap */
        flex-wrap: wrap;
        align-items: center; /* Default alignment for flex-rows */
      }
      #obsSceneNameInput {
        display: none !important;
      }
      #loadScenesBtn {
        margin-left: 5px;
        vertical-align: top; /* Align with select if they were side-by-side */
      }
      /* Adjusted for new container holding Active Streams - This rule allows it to expand fully. */
      .container:nth-child(6)
        .collapsible-content
        + .collapsible:not(.collapsed) {
        max-height: none !important;
        overflow: visible !important;
      }
      .prefix-input-label {
        margin-bottom: 4px; /* Slightly more margin */
        display: block;
        font-size: 0.9em; /* Smaller for these sub-labels */
        color: #a0a0b0;
      }
      .prefix-group {
        margin-bottom: 10px; /* More space */
      }
      /* Help icon (?) for codec */
      a[href^="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"] {
        display: inline-flex; /* Use flex to center content */
        align-items: center;
        justify-content: center;
        text-decoration: none;
        color: #a0a0b0;
        font-size: 12px; /* Keep size */
        border: 1px solid #a0a0b0;
        border-radius: 50%;
        width: 18px; /* Slightly larger for easier click */
        height: 18px;
        font-weight: bold;
        vertical-align: middle;
        margin-left: 4px; /* More spacing */
        margin-bottom: 0; /* Align better with select */
        transition: background-color 0.2s ease, color 0.2s ease,
          border-color 0.2s ease;
      }
      a[href^="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"]:hover {
        background-color: #007aff;
        color: white;
        border-color: #007aff;
      }
      /* Stream Mapping UI adjustments */
      .stream-mapping {
        background-color: #25272c; /* Slightly different background */
        padding: 12px;
        border: 1px solid #383b40;
        border-radius: 6px;
        margin-bottom: 10px; /* Add margin-bottom for spacing between mapping rules */
      }
      .stream-mapping .flex-row {
        margin-bottom: 8px; /* Space between rows of controls in a single mapping */
      }
      .stream-mapping .flex-row:last-child {
        margin-bottom: 0;
      }
      .stream-mapping input[type="text"],
      .stream-mapping select {
        margin-bottom: 0; /* Remove bottom margin for inputs inside mapping, handled by flex gap/row margin */
        font-size: 0.9em; /* Slightly smaller for compact layout */
        padding: 8px;
      }
      .stream-mapping .remove-mapping-btn {
        padding: 6px 8px; /* Smaller padding for remove button */
        background-color: #c82333 !important; /* Danger red */
        font-size: 0.9em;
        margin-left: auto; /* Push to the right */
      }
      .stream-mapping .remove-mapping-btn:hover {
        background-color: #a01c28 !important;
      }
      .stream-mapping small {
        /* Adjust small text in mappings */
        font-size: 0.8em;
        margin-top: 5px;
      }
      .mapping-stream-id {
        flex-basis: 100px;
        flex-grow: 1;
        min-width: 80px;
      }
      .mapping-label {
        flex-basis: 140px;
        flex-grow: 2;
        min-width: 100px;
      }
      .mapping-match-type {
        flex-basis: 100px;
        flex-grow: 1;
        min-width: 90px;
      }
      .mapping-scene-name {
        flex-basis: 150px;
        flex-grow: 2;
        min-width: 120px;
      }
      .remove-mapping-btn {
        flex-shrink: 0;
      } /* Prevent remove button from shrinking */
      #addStreamMappingBtn {
        /* Make it stand out a bit */
        background-color: #0069d9; /* Bootstrap primary blue */
        border-color: #0062cc;
      }
      #addStreamMappingBtn:hover {
        background-color: #005cbf;
        border-color: #0056b3;
      }
      /* Ensure consistent spacing for checkbox labels within stream mappings */
      .stream-mapping .checkbox-label {
        font-size: 0.9em; /* Smaller to fit */
        margin-bottom: 0; /* Remove bottom margin as it's in a flex row */
      }
      /* Target OBS Target Settings dropdowns for specific width */
      #obsSceneSelect,
      #screenShareSceneSelect,
      #highlightSceneSelect {
        /* width handled by inline style, but can be adjusted if needed */
      }
      /* Make width of select and button in "Target Scene" line up nicely */
      #obsTargetSettingsFlexContainer > div:first-child {
        /* Assuming you wrap obsSceneSelect and loadScenesBtn in this */
        flex-grow: 1;
      }
      #obsTargetSettingsFlexContainer > button {
        flex-shrink: 0;
      }
      .settings-group {
        margin-top: 15px;
        border-top: 1px solid #3e4147;
        padding-top: 15px;
      }
      .settings-group:first-child {
        margin-top: 0;
        border-top: none;
        padding-top: 0;
      }
    </style>
  </head>
  <body>
    <h1>VDO.Ninja OBS Control</h1>
    <div class="container">
      <h2 class="collapsible" data-state="expand">OBS WebSocket Connection</h2>
      <div class="collapsible-content">
        <label for="obsWsUrl">WebSocket URL:</label>
        <input type="text" id="obsWsUrl" value="ws://localhost:4455" />
        <label for="obsWsPassword">Password:</label>
        <input type="password" id="obsWsPassword" value="" />
        <div class="prefix-group">
          <label
            for="cameraPrefix"
            id="cameraSubPrefixLabelText"
            class="prefix-input-label"
            >Camera prefix:</label
          >
          <input type="text" id="cameraPrefix" value="VDO" />
        </div>
        <div class="prefix-group">
          <label
            for="reactionSubPrefix"
            id="reactionSubPrefixLabelText"
            class="prefix-input-label"
            >Reaction prefix: VDO.</label
          >
          <input type="text" id="reactionSubPrefix" value="Screen" />
        </div>
        <div class="prefix-group">
          <label
            for="highlightSubPrefix"
            id="highlightSubPrefixLabelText"
            class="prefix-input-label"
            >Highlight prefix: VDO.</label
          >
          <input type="text" id="highlightSubPrefix" value="Highlight" />
        </div>
        <div class="status-line">
          <button id="obsConnectBtn">Connect</button>
          <span id="obsConnectionStatus">Status: Disconnected</span>
          <span id="obsStatusIndicator" class="status-indicator"></span>
        </div>
      </div>
    </div>
    <div class="container">
      <h2 class="collapsible" data-state="expand">VDO.Ninja Settings</h2>
      <div class="collapsible-content">
        <label for="vdoNinjaBaseUrl">VDO.Ninja Base URL:</label>
        <input
          type="text"
          id="vdoNinjaBaseUrl"
          placeholder="https://vdo.ninja"
          value="https://vdo.ninja"
        />
        <label for="vdoNinjaRoom">Room Name:</label>
        <input
          type="text"
          id="vdoNinjaRoom"
          placeholder="e.g., MyNinjaRoom"
          class="blur-field"
        />
        <label for="vdoNinjaPassword">Password:</label>
        <input
          type="password"
          id="vdoNinjaPassword"
          placeholder="Room or &password"
        />
        <label for="vdoNinjaStreamIds">Stream IDs:</label>
        <input
          type="text"
          id="vdoNinjaStreamIds"
          placeholder="streamId1,streamId2"
          class="blur-field"
        />
        <small>Room Name or Stream ID(s) needed</small>
      </div>
    </div>
    <div class="container">
      <h2 class="collapsible" data-state="collapse">Stream ID Mappings</h2>
      <div class="collapsible-content collapsed">
        <div id="streamMappingContainer">
          <div id="streamMappings"></div>
          <button id="addStreamMappingBtn" style="margin-top: 10px">
            Add New Mapping
          </button>
        </div>
      </div>
    </div>
    <div class="container">
      <h2 class="collapsible" data-state="expand">OBS Target Settings</h2>
      <div class="collapsible-content">
        <div class="settings-group">
          <label for="obsSceneSelect">Target Scene:</label>
          <div
            class="flex-row"
            style="gap: 10px"
            id="obsTargetSettingsFlexContainer"
          >
            <select id="obsSceneSelect" style="width: 300px; flex-grow: 1">
              <option value="">Select a scene...</option>
            </select>
            <button id="loadScenesBtn">Re-Fetch Scenes</button>
          </div>
        </div>
        <div
          id="otherScenesContainer"
          class="settings-group"
          style="display: none"
        >
          <label>Copy sources to other scenes (reference):</label>
          <div id="otherScenesList" style="margin-top: 5px"></div>
        </div>
        <input type="text" id="obsSceneNameInput" style="display: none" />
        <div class="settings-group">
          <label style="font-weight: 600; font-size: 1.05em"
            >Screen Sharing Settings:</label
          >
          <div
            class="flex-row"
            style="gap: 15px; align-items: flex-start"
          >
            <div>
              <label for="screenShareSceneSelect" style="font-size: 0.95em"
                >Target Scene:</label
              >
              <select id="screenShareSceneSelect" style="width: 300px">
                <option value="">Same as main</option>
              </select>
            </div>
            <div class="flex-row" style="gap: 8px">
              <div>
                <label for="screenShareWidth" style="font-size: 0.95em"
                  >Width:</label
                >
                <input
                  type="number"
                  id="screenShareWidth"
                  value="1920"
                  style="width: 100px"
                />
              </div>
              <div>
                <label for="screenShareHeight" style="font-size: 0.95em"
                  >Height:</label
                >
                <input
                  type="number"
                  id="screenShareHeight"
                  value="1080"
                  style="width: 100px"
                />
              </div>
            </div>
          </div>
        </div>
        <div class="settings-group">
          <label for="highlightSceneSelect" style="font-weight: 600; font-size: 1.05em"
            >Highlight Scene:</label
          >
          <select id="highlightSceneSelect" style="width: 300px">
            <option value="">Select a scene for highlights...</option>
          </select>
        </div>
        <div
          id="autoSourceOptions"
          class="settings-group flex-row"
          style="gap: 15px"
        >
          <label class="checkbox-label">
            <input type="checkbox" id="autoAddSources" checked />
            Auto-add new streams as sources
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="autoRemoveSources" checked />
            Auto-remove sources on disconnect
          </label>
        </div>
        <div class="settings-group">
          <div class="flex-row" style="align-items: flex-end; gap: 15px">
            <div>
              <label for="sourceSizing">New Source Sizing:</label>
              <select id="sourceSizing" style="width: 250px">
                <option value="defaultSize">Default (1920x1080 at 0,0)</option>
                <option value="bestFit">Best Fit (Preserve Aspect)</option>
                <option value="stretchToFill">Stretch to Fill Screen</option>
                <option value="autoGrid">Auto Grid Layout</option>
              </select>
            </div>
            <div>
              <label for="sourceCodec">Codec:</label>
              <div class="flex-row" style="gap: 2px">
                <select id="sourceCodec" style="width: 150px">
                  <option value="">none</option>
                  <option value="h264">h264</option>
                  <option value="vp8">vp8</option>
                  <option value="vp9">vp9</option>
                  <option value="av1">av1</option>
                  <option value="h265">h265</option>
                  <option value="webp">webp</option>
                  <option value="hardware">hardware</option>
                </select>
                <a
                  href="https://docs.vdo.ninja/advanced-settings/video-parameters/codec"
                  target="_blank"
                  title="Learn more about codec options"
                  >?</a
                >
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="container">
      <h2 class="collapsible" data-state="expand">Active Streams</h2>
      <div class="collapsible-content">
        <div id="streamList" class="stream-list">
          <div
            class="stream-item"
            style="
              text-align: center;
              background-color: transparent;
              border: none;
              color: #888;
            "
          >
            No active streams
          </div>
        </div>
      </div>
    </div>
    <iframe
      id="vdoNinjaIframe"
      allow="encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;midi *;geolocation;camera *;microphone *;fullscreen;picture-in-picture;display-capture;accelerometer;autoplay;gyroscope;screen-wake-lock;"
    ></iframe>
    <div class="container">
      <h2 class="collapsible" data-state="expand">Log</h2>
      <div class="collapsible-content">
        <div id="logArea" class="log-area"></div>
      </div>
    </div>
    <script>
      // DOM elements
      const obsWsUrlInput = document.getElementById("obsWsUrl");
      const obsWsPasswordInput = document.getElementById("obsWsPassword");
      const obsConnectBtn = document.getElementById("obsConnectBtn");
      const obsConnectionStatus = document.getElementById("obsConnectionStatus");
      const obsStatusIndicator = document.getElementById("obsStatusIndicator");

      const cameraPrefixInput = document.getElementById("cameraPrefix");
      const reactionSubPrefixInput =
        document.getElementById("reactionSubPrefix");
      const highlightSubPrefixInput = document.getElementById(
        "highlightSubPrefix"
      );
      const cameraSubPrefixLabelText = document.getElementById(
        "cameraSubPrefixLabelText"
      ); // For dynamic label updates
      const reactionSubPrefixLabelText = document.getElementById(
        "reactionSubPrefixLabelText"
      ); // For dynamic label updates
      const highlightSubPrefixLabelText = document.getElementById(
        "highlightSubPrefixLabelText"
      ); // For dynamic label updates

      const vdoNinjaBaseUrlInput = document.getElementById("vdoNinjaBaseUrl");
      const vdoNinjaRoomInput = document.getElementById("vdoNinjaRoom");
      const vdoNinjaPasswordInput = document.getElementById("vdoNinjaPassword");
      const vdoNinjaStreamIdsInput =
        document.getElementById("vdoNinjaStreamIds");
      const vdoNinjaIframe = document.getElementById("vdoNinjaIframe");

      const obsSceneNameInput = document.getElementById("obsSceneNameInput"); // Hidden input, mirrors obsSceneSelect
      const obsSceneSelect = document.getElementById("obsSceneSelect");
      const sourceSizingSelect = document.getElementById("sourceSizing");
      const sourceCodecSelect = document.getElementById("sourceCodec");
      const autoAddSourcesCheckbox = document.getElementById("autoAddSources");
      const autoRemoveSourcesCheckbox =
        document.getElementById("autoRemoveSources");
      const streamListContainer = document.getElementById("streamList");
      const logArea = document.getElementById("logArea");
      const loadScenesBtn = document.getElementById("loadScenesBtn");
      const highlightSceneSelect = document.getElementById("highlightSceneSelect");

      // State variables
      let obs = null; // WebSocket connection object for OBS
      let obsConnected = false; // Flag for OBS connection status
      let vdoNinjaConnected = false; // Flag for VDO.Ninja iframe connection status
      let activeStreams = {}; // Stores information about currently active VDO.Ninja streams
      let obsScenes = []; // Array to store fetched OBS scene names
      let requestCallbacks = {}; // Stores callbacks for OBS WebSocket requests

      let vdoNinjaLastActivityTime = 0; // Timestamp of the last message from VDO.Ninja iframe
      let vdoNinjaConnectionCheckTimer = null; // Timer for VDO.Ninja connection timeout

      let screenShareId = null; // Stream ID currently being screen shared
      let highlightedStreamId = null; // Stream ID currently highlighted
      let loadedSelectedOtherScenes = []; // Array to store selected "other scenes" from localStorage

      document.querySelectorAll(".collapsible").forEach((header) => {
        const content = header.nextElementSibling;
        const startsExpanded = header.dataset.state === "expand";

        if (startsExpanded) {
          header.classList.remove("collapsed");
          content.classList.remove("collapsed");
          header.setAttribute("data-state", "collapse");
        } else {
          header.classList.add("collapsed");
          content.classList.add("collapsed");
          header.setAttribute("data-state", "expand");
        }

        header.addEventListener("click", function () {
          const isCollapsed = header.classList.toggle("collapsed");
          content.classList.toggle("collapsed");
          const newState = isCollapsed ? "expand" : "collapse";
          header.setAttribute("data-state", newState);
        });
      });

      // Create and inject VDO.Ninja connection controls dynamically
      const vdoNinjaConnectBtn = document.createElement("button");
      vdoNinjaConnectBtn.id = "vdoNinjaConnectBtn";
      vdoNinjaConnectBtn.textContent = "Connect";
      vdoNinjaConnectBtn.style.marginTop = "5px";

      const vdoNinjaStatusIndicator = document.createElement("span");
      vdoNinjaStatusIndicator.id = "vdoNinjaStatusIndicator";
      vdoNinjaStatusIndicator.className = "status-indicator";

      const vdoNinjaConnectionStatus = document.createElement("span");
      vdoNinjaConnectionStatus.id = "vdoNinjaConnectionStatus";
      vdoNinjaConnectionStatus.textContent = "Status: Disconnected";
      vdoNinjaConnectionStatus.style.marginLeft = "5px";

      const vdoNinjaSettingsContainer = document.querySelector(
        ".container:nth-child(3)"
      ); // VDO.Ninja Settings container
      const buttonsDiv = document.createElement("div"); // Container for the VDO.Ninja connect button and status
      buttonsDiv.style.marginTop = "10px"; // Increased margin
      buttonsDiv.className = "status-line";
      buttonsDiv.appendChild(vdoNinjaConnectBtn);
      buttonsDiv.appendChild(vdoNinjaConnectionStatus);
      buttonsDiv.appendChild(vdoNinjaStatusIndicator);
      // Append to the VDO.Ninja settings collapsible content
      vdoNinjaSettingsContainer
        .querySelector(".collapsible-content")
        .appendChild(buttonsDiv);

      // Event listener for VDO.Ninja connect/disconnect button
      vdoNinjaConnectBtn.addEventListener("click", () => {
        if (vdoNinjaConnected) {
          disconnectFromVdoNinja();
        } else {
          connectToVdoNinja();
        }
      });
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms || DEF_DELAY));
      }

      /**
       * Logs a message to the console and the on-screen log area.
       * @param {string} message - The message to log.
       */
      function logMessage(message) {
        console.log(message); // Also log to browser console for more detailed debugging
        const timestamp = new Date().toLocaleTimeString();
        logArea.innerHTML += `[${timestamp}] ${message}\n`;
        logArea.scrollTop = logArea.scrollHeight; // Auto-scroll to the latest message
      }

      /**
       * Generates a unique request ID for OBS WebSocket messages.
       * @param {string} type - A prefix for the request type (e.g., "GetSceneList").
       * @returns {string} A unique request ID.
       */
      function generateRequestId(type) {
        return `${type}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      }

      /**
       * Gets the base URL for VDO.Ninja, defaulting if not set.
       * @returns {string} The VDO.Ninja base URL.
       */
      function getVdoNinjaBaseUrl() {
        const customUrl = vdoNinjaBaseUrlInput.value.trim();
        return customUrl || "https://vdo.ninja"; // Default VDO.Ninja URL
      }

      /**
       * Gets the full camera prefix from input.
       * @returns {string} The camera prefix.
       */
      function getFullCameraPrefix() {
        return cameraPrefixInput.value.trim();
      }
      /**
       * Gets the full reaction prefix (camera prefix + reaction sub-prefix).
       * @returns {string} The full reaction prefix.
       */
      function getFullReactionPrefix() {
        return `${cameraPrefixInput.value.trim()}.${reactionSubPrefixInput.value.trim()}`;
      }
      /**
       * Gets the full highlight prefix (camera prefix + highlight sub-prefix).
       * @returns {string} The full highlight prefix.
       */
      function getFullHighlightPrefix() {
        return `${cameraPrefixInput.value.trim()}.${highlightSubPrefixInput.value.trim()}`;
      }

      /**
       * Updates the descriptive labels for prefixes next to their input fields.
       */
      function updatePrefixLabels() {
        const cameraPrefixVal = getFullCameraPrefix();
        const reactionSubPrefixVal = reactionSubPrefixInput.value.trim();
        const highlightSubPrefixVal = highlightSubPrefixInput.value.trim();

        // Update the labels to show the current full prefix being used
        // cameraSubPrefixLabelText.textContent = `Camera prefix:`; // Label itself is now static
        reactionSubPrefixLabelText.textContent = `Reaction prefix: ${
          cameraPrefixVal || "(VDO)"
        }${cameraPrefixVal ? "." : ""}${reactionSubPrefixVal || "(Screen)"}`;
        highlightSubPrefixLabelText.textContent = `Highlight prefix: ${
          cameraPrefixVal || "(VDO)"
        }${cameraPrefixVal ? "." : ""}${highlightSubPrefixVal || "(Highlight)"}`;
      }
      // Add event listeners to prefix inputs to update labels and save settings on change
      cameraPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });
      reactionSubPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });
      highlightSubPrefixInput.addEventListener("input", () => {
        updatePrefixLabels();
        saveSettings();
      });

      /**
       * Toggles the disabled state of VDO.Ninja input fields.
       * @param {boolean} disabled - True to disable, false to enable.
       */
      function toggleVdoNinjaInputs(disabled) {
        vdoNinjaBaseUrlInput.disabled = disabled;
        vdoNinjaRoomInput.disabled = disabled;
        vdoNinjaPasswordInput.disabled = disabled;
        vdoNinjaStreamIdsInput.disabled = disabled;
      }

      /**
       * Updates the VDO.Ninja connection button and status display.
       * @param {boolean} isVdoConnected - Current connection state to VDO.Ninja.
       */
      function updateVdoNinjaButtonState(isVdoConnected) {
        vdoNinjaConnected = isVdoConnected; // Update global state
        if (vdoNinjaConnected) {
          vdoNinjaConnectBtn.textContent = "Disconnect";
          vdoNinjaConnectBtn.classList.remove("disconnected");
          vdoNinjaConnectBtn.classList.add("connected");
          vdoNinjaConnectionStatus.textContent = "Status: Connected";
          vdoNinjaStatusIndicator.classList.add("connected");
          vdoNinjaStatusIndicator.classList.remove("error");
        } else {
          vdoNinjaConnectBtn.textContent = "Connect";
          vdoNinjaConnectBtn.classList.remove("connected");
          vdoNinjaConnectBtn.classList.add("disconnected");
          vdoNinjaConnectionStatus.textContent = "Status: Disconnected";
          vdoNinjaStatusIndicator.classList.remove("connected", "error");
        }
        // Toggle input fields based on connection state
        toggleVdoNinjaInputs(vdoNinjaConnected);
        saveSettings(); // Save settings which might include connection state if relevant
      }

      /**
       * Saves current settings to localStorage.
       */
      function saveSettings() {
        const otherSceneCheckboxes = document.querySelectorAll(
          ".other-scene-checkbox:checked"
        );
        const selectedOtherScenes = Array.from(otherSceneCheckboxes).map(
          (cb) => cb.value
        );

        const settings = {
          obsWsUrl: obsWsUrlInput.value,
          obsWsPassword: obsWsPasswordInput.value,
          cameraPrefix: cameraPrefixInput.value,
          reactionSubPrefix: reactionSubPrefixInput.value,
          highlightSubPrefix: highlightSubPrefixInput.value,
          vdoNinjaBaseUrl: vdoNinjaBaseUrlInput.value,
          vdoNinjaRoom: vdoNinjaRoomInput.value,
          vdoNinjaPassword: vdoNinjaPasswordInput.value,
          vdoNinjaStreamIds: vdoNinjaStreamIdsInput.value,
          obsSceneName: obsSceneSelect.value,
          selectedOtherScenes: selectedOtherScenes, // Save the list of additionally selected scenes
          sourceSizing: sourceSizingSelect.value,
          sourceCodec: sourceCodecSelect.value,
          autoAddSources: autoAddSourcesCheckbox.checked,
          autoRemoveSources: autoRemoveSourcesCheckbox.checked,
          screenShareWidth: document.getElementById("screenShareWidth").value,
          screenShareHeight: document.getElementById("screenShareHeight").value,
          screenShareScene:
            document.getElementById("screenShareSceneSelect").value,
          highlightScene: highlightSceneSelect.value,
        };
        localStorage.setItem("obsNinjaSettings", JSON.stringify(settings));

        const mappings = getStreamMappings();
        localStorage.setItem("obsNinjaStreamMappings", JSON.stringify(mappings));
        // logMessage("Settings saved."); // Optional: log settings save
      }

      /**
       * Calculates positions for sources in a grid layout.
       * @param {number} totalSources - The total number of sources to arrange.
       * @param {number} canvasWidth - The width of the OBS canvas.
       * @param {number} canvasHeight - The height of the OBS canvas.
       * @returns {Array<Object>} An array of position objects {x, y, width, height}.
       */
      function calculateGridPositions(totalSources, canvasWidth, canvasHeight) {
        const positions = [];
        if (totalSources === 0) return positions;

        let cols = Math.ceil(Math.sqrt(totalSources));
        let rows = Math.ceil(totalSources / cols);

        // Adjust rows and columns for better aspect ratio if possible, e.g., for 3 sources, prefer 3x1 or 1x3 over 2x2
        if (totalSources === 3) {
          // Example: 3 sources, 2x2 grid leaves one empty.
          cols = 3;
          rows = 1; // More visually appealing often
        }
        // Add more specific layout logic here if needed for other counts

        const cellWidth = canvasWidth / cols;
        const cellHeight = canvasHeight / rows;

        // Calculate offset for the last row if it's not full, to center its items
        const itemsInLastRow = totalSources - (rows - 1) * cols;
        let lastRowHorizontalOffset = 0;
        if (rows > 1 && itemsInLastRow > 0 && itemsInLastRow < cols) {
          lastRowHorizontalOffset = ((cols - itemsInLastRow) * cellWidth) / 2;
        }

        for (let i = 0; i < totalSources; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;

          let x = col * cellWidth;
          if (row === rows - 1) {
            // If it's the last row
            x += lastRowHorizontalOffset;
          }
          const y = row * cellHeight;
          positions.push({ x, y, width: cellWidth, height: cellHeight });
        }
        return positions;
      }

      /**
       * Disconnects from the VDO.Ninja iframe and resets related states.
       */
      function disconnectFromVdoNinja() {
        vdoNinjaIframe.src = "about:blank"; // Clear the iframe
        if (vdoNinjaConnectionCheckTimer) {
          clearTimeout(vdoNinjaConnectionCheckTimer);
          vdoNinjaConnectionCheckTimer = null;
        }
        activeStreams = {}; // Clear active streams
        updateStreamList(); // Update the UI
        updateVdoNinjaButtonState(false); // Set VDO.Ninja to disconnected state
        logMessage("Disconnected from VDO.Ninja.");
      }

      /**
       * Initiates a connection to VDO.Ninja via the iframe.
       */
      function connectToVdoNinja() {
        if (vdoNinjaConnected) {
          // Should not happen if button state is correct
          logMessage("Already connected to VDO.Ninja.");
          return;
        }

        const room = vdoNinjaRoomInput.value.trim();
        const streamIds = vdoNinjaStreamIdsInput.value.trim();

        if (!room && !streamIds) {
          logMessage(
            "VDO.Ninja Error: Room Name or Stream ID(s) must be provided."
          );
          return;
        }

        initializeVdoNinjaIframe(); // Sets up the iframe src
        vdoNinjaConnectionStatus.textContent = "Status: Connecting...";
        vdoNinjaConnectBtn.textContent = "Cancel"; // Allow user to cancel connection attempt

        // Clear any existing timeout
        if (vdoNinjaConnectionCheckTimer) {
          clearTimeout(vdoNinjaConnectionCheckTimer);
        }
        // Set a timeout for the connection attempt
        vdoNinjaConnectionCheckTimer = setTimeout(() => {
          // Check if connection is still not established (vdoNinjaConnected is false)
          // and if there hasn't been any activity (vdoNinjaLastActivityTime is old)
          if (
            !vdoNinjaConnected &&
            Date.now() - vdoNinjaLastActivityTime > 10000
          ) {
            logMessage(
              "VDO.Ninja connection timed out. No activity received from iframe."
            );
            vdoNinjaConnectionStatus.textContent = "Status: Connection Failed";
            vdoNinjaStatusIndicator.classList.add("error");
            // Revert button to "Connect" but don't call disconnectFromVdoNinja as it wasn't fully connected
            vdoNinjaConnectBtn.textContent = "Connect";
            toggleVdoNinjaInputs(false); // Re-enable inputs
          }
        }, 10000); // 10-second timeout

        toggleVdoNinjaInputs(true); // Disable inputs while attempting to connect
        saveSettings(); // Save current settings (like base URL) before attempting connection
      }

      /**
       * Adds a new stream mapping UI element.
       * @param {string} [streamId=''] - The VDO.Ninja Stream ID.
       * @param {string} [label=''] - The VDO.Ninja label.
       * @param {string} [sceneName=''] - The target OBS scene name.
       * @param {string} [matchType='streamId'] - The matching type ('streamId', 'label', 'both', 'either').
       * @param {boolean} [shouldClone=true] - Whether to clone to the main scene.
       * @param {boolean} [shouldSwitch=false] - Whether to switch to the target scene on add.
       */
      function addNewStreamMapping(
        streamId = "",
        label = "",
        sceneName = "",
        matchType = "streamId",
        shouldClone = true,
        shouldSwitch = false
      ) {
        const streamMappingsDiv = document.getElementById("streamMappings");
        const mappingDiv = document.createElement("div");
        mappingDiv.className = "stream-mapping"; // For styling and selection

        // Sanitize input if it's a PointerEvent (e.g. from button click with no params)
        const initialStreamId =
          streamId instanceof PointerEvent ||
          (typeof streamId === "object" && streamId !== null && streamId.target)
            ? ""
            : streamId;

        mappingDiv.innerHTML = `
              <div style="margin-bottom: 5px;">
                  <label style="font-size: 1em; margin-bottom: 6px; display: block; font-weight:500;">Stream Mapping Rule</label>
                  <div class="flex-row" style="align-items: center; margin-bottom: 6px;">
                      <input type="text" placeholder="Stream ID" value="${initialStreamId}" class="mapping-stream-id" title="VDO.Ninja Stream ID">
                      <input type="text" placeholder="Label (optional)" value="${label}" class="mapping-label" title="VDO.Ninja Stream Label">
                      <select class="mapping-match-type" title="How to match stream">
                          <option value="streamId" ${
                            matchType === "streamId" ? "selected" : ""
                          }>ID Only</option>
                          <option value="label" ${
                            matchType === "label" ? "selected" : ""
                          }>Label Only</option>
                          <option value="both" ${
                            matchType === "both" ? "selected" : ""
                          }>Both Required</option>
                          <option value="either" ${
                            matchType === "either" ? "selected" : ""
                          }>Either Match</option>
                      </select>
                      <select class="mapping-scene-name" title="Target OBS Scene">
                          <option value="">Select a scene...</option>
                      </select>
                      <button class="remove-mapping-btn" title="Remove this mapping rule">×</button>
                  </div>
                  <div class="flex-row" style="gap: 15px;">
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-clone-to-main" ${
                            shouldClone ? "checked" : ""
                          }>
                          Clone to main scene
                      </label>
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-switch-to-scene" ${
                            shouldSwitch ? "checked" : ""
                          }>
                          Switch to scene on add
                      </label>
                  </div>
                  <small style="color: #8a8a9a; font-size: 0.85em; display: block; margin-top: 4px;">
                      Define how incoming streams are routed to OBS scenes.
                  </small>
              </div>
          `;

        streamMappingsDiv.appendChild(mappingDiv);
        const sceneDropdown = mappingDiv.querySelector(".mapping-scene-name");

        // Populate the scene dropdown for this new mapping
        populateSceneDropdown(obsScenes, sceneDropdown);
        // Set the selected scene if a valid one was provided
        if (
          sceneName &&
          obsScenes.some((scene) => scene.sceneName === sceneName)
        ) {
          sceneDropdown.value = sceneName;
        }

        // Event listener for the remove button of this mapping
        const removeBtn = mappingDiv.querySelector(".remove-mapping-btn");
        removeBtn.addEventListener("click", () => {
          mappingDiv.remove(); // Remove the mapping's div from DOM
          saveSettings(); // Update saved settings
        });

        // Add change listeners to all inputs/selects within this mapping to save on change
        const inputs = mappingDiv.querySelectorAll("input, select");
        inputs.forEach((input) => {
          input.addEventListener("change", saveSettings);
        });
      }

      /**
       * Sets up the UI for stream mappings, including the "Add New Mapping" button.
       */
      function setupStreamMappingUI() {
        const addStreamMappingBtn = document.getElementById(
          "addStreamMappingBtn"
        );
        addStreamMappingBtn.addEventListener("click", () => {
          addNewStreamMapping(); // Add a new blank mapping rule
        });
        loadStreamMappings(); // Load any saved mappings from localStorage
      }

      /**
       * Loads settings from localStorage and applies them to the UI.
       */
      function loadSettings() {
        const settingsJson = localStorage.getItem("obsNinjaSettings");
        if (settingsJson) {
          try {
            const settings = JSON.parse(settingsJson);
            obsWsUrlInput.value = settings.obsWsUrl || "ws://localhost:4455";
            obsWsPasswordInput.value = settings.obsWsPassword || "";

            cameraPrefixInput.value = settings.cameraPrefix || "VDO";
            reactionSubPrefixInput.value = settings.reactionSubPrefix || "Screen";
            highlightSubPrefixInput.value =
              settings.highlightSubPrefix || "Highlight";

            vdoNinjaBaseUrlInput.value =
              settings.vdoNinjaBaseUrl || "https://vdo.ninja";
            vdoNinjaRoomInput.value = settings.vdoNinjaRoom || "";
            vdoNinjaPasswordInput.value = settings.vdoNinjaPassword || "";
            vdoNinjaStreamIdsInput.value = settings.vdoNinjaStreamIds || "";

            // OBS scene related settings will be validated/set after scenes are fetched
            loadedSelectedOtherScenes = settings.selectedOtherScenes || [];

            sourceSizingSelect.value = settings.sourceSizing || "defaultSize";
            sourceCodecSelect.value = settings.sourceCodec || "";
            autoAddSourcesCheckbox.checked =
              settings.autoAddSources !== false; // Default to true if undefined
            autoRemoveSourcesCheckbox.checked =
              settings.autoRemoveSources !== false; // Default to true if undefined

            const screenShareWidthInput =
              document.getElementById("screenShareWidth");
            const screenShareHeightInput =
              document.getElementById("screenShareHeight");

            if (screenShareWidthInput)
              screenShareWidthInput.value = settings.screenShareWidth || "1920";
            if (screenShareHeightInput)
              screenShareHeightInput.value =
                settings.screenShareHeight || "1080";

            // Actual selection for obsSceneSelect, screenShareSceneSelect, and highlightSceneSelect happens in fetchObsScenes after scenes are loaded

            updatePrefixLabels(); // Update prefix display labels based on loaded values
            logMessage("Settings loaded from localStorage.");
          } catch (e) {
            logMessage(
              `Error loading settings from localStorage: ${e.message}. Using defaults.`
            );
            // Apply defaults if parsing fails to prevent errors
            cameraPrefixInput.value = "VDO";
            reactionSubPrefixInput.value = "Screen";
            highlightSubPrefixInput.value = "Highlight";
            updatePrefixLabels();
            vdoNinjaBaseUrlInput.value = "https://vdo.ninja";
            sourceSizingSelect.value = "defaultSize";
            sourceCodecSelect.value = "";
          }
        } else {
          // Apply defaults if no settings are found in localStorage
          logMessage("No saved settings found. Using default values.");
          cameraPrefixInput.value = "VDO";
          reactionSubPrefixInput.value = "Screen";
          highlightSubPrefixInput.value = "Highlight";
          updatePrefixLabels();
          vdoNinjaBaseUrlInput.value = "https://vdo.ninja";
          sourceSizingSelect.value = "defaultSize";
          sourceCodecSelect.value = "";
        }
        setupStreamMappingUI(); // This also calls loadStreamMappings
      }

      /**
       * Updates the list of "other scenes" checkboxes based on the main selected scene.
       */
      function updateOtherScenesList() {
        const mainSceneName = obsSceneSelect.value;
        const otherScenesListDiv = document.getElementById("otherScenesList");
        const container = document.getElementById("otherScenesContainer");

        otherScenesListDiv.innerHTML = ""; // Clear previous list of checkboxes

        if (mainSceneName && obsScenes && obsScenes.length > 1) {
          container.style.display = "block"; // Show the container
          obsScenes.forEach((scene) => {
            if (scene.sceneName !== mainSceneName) {
              // Don't list the main scene as an "other" scene
              const checkboxId = `otherScene_${scene.sceneName.replace(
                /\s+/g,
                "_"
              )}`; // Create a unique ID
              const listItem = document.createElement("div");
              listItem.className = "checkbox-label"; // Use existing class for styling
              listItem.style.marginBottom = "8px"; // Add some space between checkboxes

              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.id = checkboxId;
              checkbox.value = scene.sceneName;
              checkbox.className = "other-scene-checkbox";

              // Check if this scene was previously selected (from loaded settings)
              if (loadedSelectedOtherScenes.includes(scene.sceneName)) {
                checkbox.checked = true;
              }
              checkbox.addEventListener("change", saveSettings); // Save settings when checkbox state changes

              const label = document.createElement("label");
              label.htmlFor = checkboxId;
              label.textContent = scene.sceneName;
              label.style.marginLeft = "0"; // Ensure label text is close to checkbox

              listItem.appendChild(checkbox);
              listItem.appendChild(label);
              otherScenesListDiv.appendChild(listItem); // Add to the list
            }
          });
          // If, after filtering, no "other" scenes are available, hide the container
          if (otherScenesListDiv.childElementCount === 0) {
            container.style.display = "none";
          }
        } else {
          container.style.display = "none"; // Hide if no main scene or no other scenes
        }
      }

      /**
       * Updates the list of active VDO.Ninja streams in the UI.
       */
      function updateStreamList() {
        if (Object.keys(activeStreams).length === 0) {
          streamListContainer.innerHTML =
            '<div class="stream-item" style="text-align:center; background-color:transparent; border:none; color:#888;">No active streams</div>';
          return;
        }
        streamListContainer.innerHTML = ""; // Clear previous list

        for (const streamId in activeStreams) {
          // Ensure it's a direct property of activeStreams
          if (Object.hasOwnProperty.call(activeStreams, streamId)) {
            const stream = activeStreams[streamId]; // Current stream object
            const streamDiv = document.createElement("div");
            streamDiv.className = "stream-item";

            // Determine target scene information for this stream
            const targetInfo = getTargetSceneForStream(streamId, stream.label);
            const targetSceneName = targetInfo.scene;
            const isDefaultScene = targetSceneName === getTargetScene(); // Is it the main default scene?

            // Check highlight and screen share states
            const isHighlighted = highlightedStreamId === streamId;
            const isCurrentlyScreenSharingThisStream = screenShareId === streamId;

            // Build HTML for the stream item
            let streamItemHTML = `
                      <div style="font-weight: 600; font-size: 1.05em; color: #E0E0E0;">${
                        stream.label || streamId
                      }</div>
                      <small>ID: ${streamId}${
              stream.label ? ` | Label: ${stream.label}` : ""
            }</small>
                      <small style="display: block; color: #A0A0B0;">
                          → Target Scene: ${targetSceneName || "Not Set"}
                          ${
                            isDefaultScene && targetSceneName
                              ? "(default)"
                              : targetSceneName
                              ? "(mapped)"
                              : ""
                          }
                      </small>
                      <div style="margin-top: 2px; font-size: 0.9em;">
                        ${
                          stream.sourceCreated
                            ? '<span style="color:#28A745">✓ Added to OBS</span>'
                            : '<span style="color:#FFC107">✗ Not in OBS</span>'
                        }
                      </div>
                      <div style="margin-top: 8px;" class="flex-row">`; // Use flex-row for button alignment

            // Add/Remove Button
            // JS will set the correct background color for these buttons via inline styles initially, CSS will override with !important
            streamItemHTML += `
                      <button class="add-stream-btn" data-stream-id="${streamId}"
                          style="background-color: ${
                            stream.sourceCreated ? "#F44336" : "#4C80AF"
                          };">
                              ${
                                stream.sourceCreated
                                  ? "Remove from OBS"
                                  : "Add to OBS"
                              }
                      </button>`;

            // Add Highlight button if source is in OBS
            if (stream.sourceCreated) {
              streamItemHTML += `
                          <button class="highlight-btn" data-stream-id="${streamId}"
                              style="background-color: ${
                                isHighlighted ? "#F44336" : "#4CAF50"
                              };">
                                  ${
                                    isHighlighted
                                      ? "Unhighlight"
                                      : "Highlight"
                                  }
                          </button>`;
            }

            // Add Screen Share button if source is in OBS
            if (stream.sourceCreated) {
              // Only show if the main stream source is in OBS
              streamItemHTML += `
                          <button class="screen-share-btn" data-stream-id="${streamId}"
                                  style="background-color: ${
                                    isCurrentlyScreenSharingThisStream
                                      ? "#F44336"
                                      : "#9C27B0"
                                  };">
                              ${
                                isCurrentlyScreenSharingThisStream
                                  ? "Stop Screen Share"
                                  : "Screen Share"
                              }
                          </button>`;
            }
            streamItemHTML += `</div>`; // Close buttons div
            streamDiv.innerHTML = streamItemHTML;
            streamListContainer.appendChild(streamDiv);

            // Add event listeners for buttons in this stream item
            const addRemoveBtn = streamDiv.querySelector(".add-stream-btn");
            if (addRemoveBtn) {
              addRemoveBtn.addEventListener("click", () => {
                if (stream.sourceCreated) {
                  removeStreamFromObs(streamId);
                } else {
                  // targetInfo already calculated for this specific stream
                  addStreamToObs(streamId, stream.label, targetInfo);
                }
              });
            }
            const highlightBtn = streamDiv.querySelector(".highlight-btn");
            if (highlightBtn) {
              highlightBtn.addEventListener("click", async () => {
                await handleHighlightClick(streamId, stream.label, targetInfo);
              });
            }
            const screenShareBtn = streamDiv.querySelector(".screen-share-btn");
            if (screenShareBtn) {
              screenShareBtn.addEventListener("click", async () => {
                await handleScreenShareClick(streamId, stream.label);
              });
            }
          }
        }
      }

      /**
       * Handles the logic when a "Highlight" or "Unhighlight" button is clicked.
       * This is the main entry point for the highlight action.
       * @param {string} clickedStreamId - The ID of the stream to toggle highlight for.
       * @param {string} clickedStreamLabel - The label of the clicked stream.
       * @param {Object} clickedTargetInfo - The target scene information for the clicked stream.
       */
      async function handleHighlightClick(
        clickedStreamId,
        clickedStreamLabel,
        clickedTargetInfo
      ) {
        if (!obsConnected || !obs) {
          logMessage("Cannot highlight: Not connected to OBS.");
          return;
        }

        // If any stream is screen sharing, stop it first.
        if (screenShareId) {
          logMessage(
            `A screen share is active (${screenShareId}). Stopping it before highlighting.`
          );
          await removeScreenShareFromObs(screenShareId);
        }

        // After highlighting, if a stream is now highlighted, switch to the highlight scene.
        const newHighlightScene = highlightSceneSelect.value;

        // Now, proceed with toggling the highlight.
        await toggleHighlight(
          clickedStreamId,
          clickedStreamLabel,
          clickedTargetInfo
        );

        if (highlightedStreamId && newHighlightScene) {
          try {
            const studio = await sendRequest("GetStudioModeEnabled");
            if (studio.studioModeEnabled) {
              logMessage(
                `Studio Mode Enabled - Triggering scene switch to Highlight Scene: '${newHighlightScene}'.`
              );
              await sendRequest("SetCurrentPreviewScene", {
                sceneName: newHighlightScene,
              });
              await sleep(200);
              await sendRequest("TriggerStudioModeTransition");
            } else {
              logMessage(
                `Triggering scene switch to Highlight Scene: '${newHighlightScene}'.`
              );
              await sendRequest("SetCurrentProgramScene", {
                sceneName: newHighlightScene,
              });
            }
          } catch (e) {
            logMessage(
              `Error switching to highlight scene '${newHighlightScene}': ${e.message}`
            );
          }
        }
      }

      /**
       * Handles the logic when a "Screen Share" or "Stop Screen Share" button is clicked.
       * @param {string} streamId - The VDO.Ninja Stream ID to screen share.
       * @param {string} streamLabel - The label of the stream.
       */
      async function handleScreenShareClick(streamId, streamLabel) {
        const clickedStreamIdForScreenShare = streamId;
        const currentActiveScreenShareGlobal = screenShareId;

        if (currentActiveScreenShareGlobal === clickedStreamIdForScreenShare) {
          // If clicking "Stop Screen Share" on the active one
          await removeScreenShareFromObs(clickedStreamIdForScreenShare);
        } else {
          // This is a new screen share request.
          if (!obsConnected || !obs) {
            logMessage("Cannot start screen share: Not connected to OBS.");
            return;
          }

          // If a camera is currently highlighted, unhighlight it first.
          if (highlightedStreamId) {
            logMessage(
              `A camera is highlighted (${highlightedStreamId}). Unhighlighting it before starting screen share.`
            );
            const oldHighlightDetails = activeStreams[highlightedStreamId];
            const oldHighlightLabel = oldHighlightDetails
              ? oldHighlightDetails.label
              : "";
            const oldHighlightTargetInfo = getTargetSceneForStream(
              highlightedStreamId,
              oldHighlightLabel
            );
            await toggleHighlight(
              highlightedStreamId,
              oldHighlightLabel,
              oldHighlightTargetInfo
            ); // This will unhighlight it
          }

          // After successfully starting the share, switch to the scene.
          const screenShareScene =
            document.getElementById("screenShareSceneSelect").value ||
            getTargetScene();

          // Now add the new screen share. This function also handles removing any old one.
          await addScreenShareToObs(clickedStreamIdForScreenShare, streamLabel);

          if (screenShareId && screenShareScene) {
            try {
              const studio = await sendRequest("GetStudioModeEnabled");
              if (studio.studioModeEnabled) {
                logMessage(
                  `Studio Mode Enabled - Triggering scene switch to Screen Share Scene: '${screenShareScene}'.`
                );
                await sendRequest("SetCurrentPreviewScene", {
                  sceneName: screenShareScene,
                });
                await sleep(200);
                await sendRequest("TriggerStudioModeTransition");
              } else {
                logMessage(
                  `Triggering scene switch to Screen Share Scene: '${screenShareScene}'.`
                );
                await sendRequest("SetCurrentProgramScene", {
                  sceneName: screenShareScene,
                });
              }
            } catch (e) {
              logMessage(
                `Error switching to screen share scene '${screenShareScene}': ${e.message}`
              );
            }
          }
        }
      }

      /**
       * Adds or updates a screen share source in OBS for a given stream.
       * If another screen share is active, it's removed first.
       * @param {string} streamId - The VDO.Ninja Stream ID to screen share.
       * @param {string} streamLabel - The label of the stream (for logging).
       */
      async function addScreenShareToObs(streamId, streamLabel) {
        const previousGlobalScreenShareId = screenShareId; // Store current screen share ID

        if (!obsConnected || !obs) {
          logMessage("Cannot add screen share: Not connected to OBS.");
          updateStreamList(); // Revert UI if screenShareId was tentatively set
          return;
        }

        const room = vdoNinjaRoomInput.value.trim();
        if (!room) {
          logMessage(
            "Cannot add screen share: VDO.Ninja Room name is required for screen sharing URLs."
          );
          updateStreamList();
          return;
        }

        // Set the new active screen share ID (globally)
        screenShareId = streamId;

        const width =
          parseInt(document.getElementById("screenShareWidth").value) || 1920;
        const height =
          parseInt(document.getElementById("screenShareHeight").value) || 1080;
        const screenShareSceneSelect = document.getElementById(
          "screenShareSceneSelect"
        );
        let targetSceneName =
          screenShareSceneSelect.value || getTargetScene(); // Use main scene if specific not set

        if (!targetSceneName) {
          logMessage(
            "Cannot add screen share: Target OBS scene is required."
          );
          screenShareId = previousGlobalScreenShareId; // Revert global state
          updateStreamList();
          return;
        }

        const sourceName = `${getFullReactionPrefix()}_${streamId}:s`; // ":s" for screen share typically in VDO.Ninja
        const baseUrl = getVdoNinjaBaseUrl();
        const selectedCodec = sourceCodecSelect.value;

        let screenShareUrl = `${baseUrl}/?view=${encodeURIComponent(
          streamId
        )}:s&solo&room=${encodeURIComponent(room)}`;
        if (selectedCodec && selectedCodec !== "") {
          screenShareUrl += `&codec=${encodeURIComponent(selectedCodec)}`;
        } else {
          screenShareUrl += `&codec=vp9`; // Default for screen share
        }

        if (vdoNinjaPasswordInput.value) {
          screenShareUrl += `&password=${encodeURIComponent(
            vdoNinjaPasswordInput.value
          )}`;
        }
        // Add other common parameters for clean output
        screenShareUrl += "&cleanoutput&transparent&proaudio";

        const inputSettings = {
          url: screenShareUrl,
          width: width,
          height: height,
          fps: 30,
          reroute_audio: true, // Important for capturing audio from the share
          restart_when_active: false,
          shutdown: false, // Don't shut down when not visible
        };

        logMessage(
          `Adding/Updating screen share source '${sourceName}' (URL: ${screenShareUrl}) to scene '${targetSceneName}'`
        );

        try {
          const sourcesResponse = await sendRequest("GetInputList", {}, { suppressNotFound: true }); // Suppress for this specific check if needed, though GetInputList usually doesn't fail for "not found"
          const existingSourceWithSamePrefix = sourcesResponse.inputs.find(
            (input) =>
              input.inputName.startsWith(getFullReactionPrefix() + "_") && // Belongs to this tool's screen shares
              input.inputName.endsWith(":s") &&
              input.inputName !== sourceName && // Not the one we are trying to create/update now
              input.inputKind === "browser_source"
          );

          // If an old screen share source from this tool exists (different streamId), reconfigure and rename it.
          if (existingSourceWithSamePrefix) {
            logMessage(
              `Reconfiguring existing screen share source '${existingSourceWithSamePrefix.inputName}' to be '${sourceName}'.`
            );
            await sendRequest("SetInputSettings", {
              inputName: existingSourceWithSamePrefix.inputName,
              inputSettings: inputSettings, // Update URL, dimensions, etc.
            });
            if (existingSourceWithSamePrefix.inputName !== sourceName) {
              await sendRequest("SetInputName", {
                inputName: existingSourceWithSamePrefix.inputName,
                newInputName: sourceName,
              });
            }
            logMessage(
              `Reconfigured and renamed existing screen share source to '${sourceName}'.`
            );
          } else {
            // Check if the exact source 'sourceName' already exists
            const exactSourceExists = sourcesResponse.inputs.find(
              (input) =>
                input.inputName === sourceName &&
                input.inputKind === "browser_source"
            );
            if (exactSourceExists) {
              logMessage(
                `Screen share source '${sourceName}' already exists. Updating its settings.`
              );
              await sendRequest("SetInputSettings", {
                inputName: sourceName,
                inputSettings: inputSettings,
              });
            } else {
              logMessage(`Creating new screen share source '${sourceName}'.`);
              await sendRequest("CreateInput", {
                sceneName: targetSceneName, // Add to scene directly
                inputName: sourceName,
                inputKind: "browser_source",
                inputSettings,
                sceneItemEnabled: true, // Make it visible by default
              });
            }
          }

          // Ensure the source is a scene item in the target scene and get its ID
          let sceneItemId;
          try {
            const itemInfo = await sendRequest(
              "GetSceneItemId",
              { sceneName: targetSceneName, sourceName: sourceName },
              { suppressNotFound: true }
            );
            sceneItemId = itemInfo.sceneItemId;
            logMessage(
              `Source '${sourceName}' found in scene '${targetSceneName}', item ID: ${sceneItemId}. Ensuring it's enabled.`
            );
            // Ensure it's visible
            await sendRequest("SetSceneItemEnabled", {
              sceneName: targetSceneName,
              sceneItemId: sceneItemId,
              sceneItemEnabled: true,
            });
          } catch (e) {
            if (
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("600")
            ) {
              // Check for code 600 as well
              logMessage(
                `Source '${sourceName}' not found as an item in scene '${targetSceneName}'. Creating scene item.`
              );
              const createItemResponse = await sendRequest("CreateSceneItem", {
                sceneName: targetSceneName,
                sourceName: sourceName,
              });
              sceneItemId = createItemResponse.sceneItemId;
              logMessage(
                `Created scene item for '${sourceName}' in '${targetSceneName}', item ID: ${sceneItemId}.`
              );
            } else {
              throw e; // Re-throw other errors
            }
          }

          // Apply transform if we have a scene item ID
          if (sceneItemId) {
            // Using 'defaultSize' for screen share, but could be configurable
            const transform = calculateTransform(
              "defaultSize",
              width,
              height,
              width,
              height
            );
            await sendRequest("SetSceneItemTransform", {
              sceneName: targetSceneName,
              sceneItemId: sceneItemId,
              sceneItemTransform: transform,
            });
            logMessage(
              `Applied transform to screen share source '${sourceName}' in '${targetSceneName}'.`
            );
          }
          logMessage(
            `Successfully configured screen share for stream ${streamId} (${streamLabel}).`
          );
        } catch (error) {
          logMessage(
            `Error adding/updating screen share source '${sourceName}': ${error.message}.`
          );
          screenShareId = previousGlobalScreenShareId; // Revert global state on error
        } finally {
          updateStreamList(); // Update UI based on final screenShareId state
        }
      }

      /**
       * Toggles the highlighted state of a stream in OBS.
       * Only one stream can be highlighted at a time. Highlighting involves renaming the OBS source.
       * @param {string} clickedStreamId - The ID of the stream to toggle highlight for.
       * @param {string} clickedStreamLabel - The label of the clicked stream.
       * @param {Object} clickedTargetInfo - The target scene information for the clicked stream.
       */
      async function toggleHighlight(
        clickedStreamId,
        clickedStreamLabel,
        clickedTargetInfo
      ) {
        if (!obsConnected || !obs) {
          logMessage("Cannot toggle highlight: Not connected to OBS.");
          return;
        }

        const previouslyGlobalHighlightedStreamId = highlightedStreamId; // ID of stream highlighted *before* this call
        const camPrefix = getFullCameraPrefix(); // Base prefix for camera sources
        const hlPrefix = getFullHighlightPrefix(); // Prefix for highlighted sources

        // --- Phase 1: Unhighlight the *previously* highlighted stream IF it's different from the clicked one ---
        if (
          previouslyGlobalHighlightedStreamId &&
          previouslyGlobalHighlightedStreamId !== clickedStreamId
        ) {
          logMessage(
            `Switching highlight: Unhighlighting previous stream ${previouslyGlobalHighlightedStreamId}.`
          );
          const oldStreamDetails =
            activeStreams[previouslyGlobalHighlightedStreamId]; // Get details of the old stream
          const oldStreamLabel = oldStreamDetails ? oldStreamDetails.label : "";
          // Fetch target info for the stream being unhighlighted (it might differ from the clicked one's target)
          const oldTargetInfo = getTargetSceneForStream(
            previouslyGlobalHighlightedStreamId,
            oldStreamLabel
          );

          const oldHighlightedSourceName = `${hlPrefix}_${previouslyGlobalHighlightedStreamId}`;
          const oldOriginalSourceName = `${camPrefix}_${previouslyGlobalHighlightedStreamId}`;

          try {
            // Check if the source to unhighlight actually exists in its highlighted form
            await sendRequest(
              "GetInputSettings",
              { inputName: oldHighlightedSourceName },
              { suppressNotFound: true }
            );
            // If it exists, rename it back to its original (non-highlighted) name
            await sendRequest("SetInputName", {
              inputName: oldHighlightedSourceName,
              newInputName: oldOriginalSourceName,
            });
            logMessage(
              `Stream ${previouslyGlobalHighlightedStreamId} unhighlighted (renamed from ${oldHighlightedSourceName} to ${oldOriginalSourceName}).`
            );

            // If using autoGrid, rearrange the scene where the old stream was
            if (sourceSizingSelect.value === "autoGrid") {
              if (oldTargetInfo.scene)
                await rearrangeAllStreamsInScene(oldTargetInfo.scene);
              // Also handle cloneToMain if the old stream was cloned to the default scene
              if (
                oldTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== oldTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            // If GetInputSettings failed (e.g. source not found, which is OK if it was already unhighlighted or removed)
            // only log if it's an unexpected error.
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error unhighlighting previous stream ${previouslyGlobalHighlightedStreamId} (from ${oldHighlightedSourceName}): ${e.message}`
              );
            } else {
              // logMessage(`Source ${oldHighlightedSourceName} for previous highlight ${previouslyGlobalHighlightedStreamId} not found during unhighlight. Assuming it was already ${oldOriginalSourceName} or removed.`);
            }
          }
        }

        // --- Phase 2: Process the *clicked* stream ---
        const clickedOriginalSourceName = `${camPrefix}_${clickedStreamId}`;
        const clickedNewHighlightedSourceName = `${hlPrefix}_${clickedStreamId}`;

        if (previouslyGlobalHighlightedStreamId === clickedStreamId) {
          // Intent: Unhighlight the clicked stream (it was the one globally highlighted)
          logMessage(`Unhighlighting clicked stream ${clickedStreamId}.`);
          try {
            // Check if it's in highlighted form before trying to rename
            await sendRequest(
              "GetInputSettings",
              { inputName: clickedNewHighlightedSourceName },
              { suppressNotFound: true }
            );
            await sendRequest("SetInputName", {
              inputName: clickedNewHighlightedSourceName,
              newInputName: clickedOriginalSourceName,
            });
            highlightedStreamId = null; // Update global state: no stream is highlighted now
            logMessage(
              `Stream ${clickedStreamId} successfully unhighlighted (renamed to ${clickedOriginalSourceName}).`
            );

            if (sourceSizingSelect.value === "autoGrid") {
              if (clickedTargetInfo.scene)
                await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
              if (
                clickedTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== clickedTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error unhighlighting ${clickedStreamId} (from ${clickedNewHighlightedSourceName}): ${e.message}`
              );
            } else {
              // logMessage(`Cannot unhighlight ${clickedStreamId}: Source ${clickedNewHighlightedSourceName} not found. Assuming it's already ${clickedOriginalSourceName}.`);
            }
            highlightedStreamId = null; // Ensure state is cleared on error too
          }
        } else {
          // Intent: Highlight the clicked stream
          logMessage(`Highlighting clicked stream ${clickedStreamId}.`);
          try {
            // Check if it's in its original form before trying to rename
            await sendRequest(
              "GetInputSettings",
              { inputName: clickedOriginalSourceName },
              { suppressNotFound: true }
            );
            await sendRequest("SetInputName", {
              inputName: clickedOriginalSourceName,
              newInputName: clickedNewHighlightedSourceName,
            });
            highlightedStreamId = clickedStreamId; // Update global state
            logMessage(
              `Stream ${clickedStreamId} successfully highlighted (renamed to ${clickedNewHighlightedSourceName}).`
            );

            if (sourceSizingSelect.value === "autoGrid") {
              if (clickedTargetInfo.scene)
                await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
              if (
                clickedTargetInfo.mapping?.cloneToMain &&
                getTargetScene() &&
                getTargetScene() !== clickedTargetInfo.scene
              ) {
                await rearrangeAllStreamsInScene(getTargetScene());
              }
            }
          } catch (e) {
            const isNotFoundOrDoesNotExist =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFoundOrDoesNotExist) {
              logMessage(
                `Error highlighting ${clickedStreamId} (from ${clickedOriginalSourceName}): ${e.message}`
              );
            } else {
              // logMessage(`Cannot highlight ${clickedStreamId}: Original source ${clickedOriginalSourceName} not found. Checking if already highlighted.`);
              try {
                // It might be that original is gone, but highlighted one exists due to prior issue.
                await sendRequest(
                  "GetInputSettings",
                  { inputName: clickedNewHighlightedSourceName },
                  { suppressNotFound: true }
                );
                // logMessage(`Stream ${clickedStreamId} appears to be already named ${clickedNewHighlightedSourceName}. Setting as highlighted.`);
                highlightedStreamId = clickedStreamId; // Correct internal state
              } catch (e2) {
                // logMessage(`Failed to highlight ${clickedStreamId}: Neither ${clickedOriginalSourceName} nor ${clickedNewHighlightedSourceName} found. Source may be missing.`);
                if (highlightedStreamId === clickedStreamId)
                  highlightedStreamId = null; // Clear if it was this one
              }
            }
            if (
              highlightedStreamId === clickedStreamId &&
              isNotFoundOrDoesNotExist
            ) {
              /* No-op if already handled by inner try-catch */
            } else if (highlightedStreamId === clickedStreamId) {
              highlightedStreamId = null;
            }
          }
        }
        updateStreamList(); // Refresh UI to reflect new highlight state
        saveSettings(); // Save changes (like highlightedStreamId if it were part of settings)
      }

      // Event listener for OBS connect/disconnect button
      obsConnectBtn.addEventListener("click", () => {
        if (obsConnected && obs) {
          logMessage("Disconnecting from OBS WebSocket...");
          if (obs) {
            obs.onclose = null; // Prevent onObsDisconnected from firing again if already closing
            obs.close();
            obs = null;
          }
          // Manually trigger disconnected state if obs.close() doesn't fire onclose immediately or reliably
          onObsDisconnected();
        } else {
          connectToOBS();
        }
      });

      /**
       * Determines the target OBS scene for a given stream based on mappings or default.
       * @param {string} streamId - The VDO.Ninja Stream ID.
       * @param {string} [streamLabel=''] - The label of the stream.
       * @returns {Object} An object { scene: string, mapping: Object|null }
       */
      function getTargetSceneForStream(streamId, streamLabel = "") {
        const mappings = getStreamMappings(); // Get current mapping rules
        const defaultTargetScene = getTargetScene(); // The scene selected in the main "Target Scene" dropdown

        for (const mapping of mappings) {
          let isMatch = false;
          switch (mapping.matchType) {
            case "streamId":
              isMatch = mapping.streamId && streamId === mapping.streamId;
              break;
            case "label":
              isMatch =
                mapping.label && streamLabel && streamLabel === mapping.label;
              break;
            case "both":
              isMatch =
                mapping.streamId &&
                mapping.label &&
                streamId === mapping.streamId &&
                streamLabel === mapping.label;
              break;
            case "either":
              isMatch =
                (mapping.streamId && streamId === mapping.streamId) ||
                (mapping.label &&
                  streamLabel &&
                  streamLabel === mapping.label);
              break;
          }
          // If a match is found and the mapping specifies a scene name
          if (isMatch && mapping.sceneName) {
            return { scene: mapping.sceneName, mapping: mapping }; // Return scene name and the mapping rule
          }
        }
        // If no mapping rule matches, or matched rule has no scene, use the default target scene
        return { scene: defaultTargetScene, mapping: null };
      }

      /**
       * Updates all scene selection dropdowns with the current list of OBS scenes.
       * Preserves existing selections if they are still valid.
       */
      function updateSceneDropdowns() {
        // Store current values before clearing and repopulating dropdowns
        const currentMainSceneValue = obsSceneSelect.value;
        const currentScreenShareSceneValue = document.getElementById(
          "screenShareSceneSelect"
        ).value;
        const currentHighlightSceneValue = highlightSceneSelect.value;
        const mappingSceneSelects =
          document.querySelectorAll(".mapping-scene-name");
        const currentMappingSceneValues = Array.from(mappingSceneSelects).map(
          (select) => select.value
        );

        // Populate the main target scene dropdown
        populateSceneDropdown(obsScenes, obsSceneSelect);
        // Populate the screen share target scene dropdown
        populateSceneDropdown(
          obsScenes,
          document.getElementById("screenShareSceneSelect")
        );
        // Populate the new highlight scene dropdown
        populateSceneDropdown(
          obsScenes,
          highlightSceneSelect,
          "Select a scene for highlights..."
        );

        // Restore main scene selection if it's still a valid scene
        if (
          currentMainSceneValue &&
          obsScenes.some((scene) => scene.sceneName === currentMainSceneValue)
        ) {
          obsSceneSelect.value = currentMainSceneValue;
        }
        // Restore screen share scene selection (empty value for "Same as main" is also valid)
        if (
          currentScreenShareSceneValue === "" ||
          (currentScreenShareSceneValue &&
            obsScenes.some(
              (scene) => scene.sceneName === currentScreenShareSceneValue
            ))
        ) {
          document.getElementById("screenShareSceneSelect").value =
            currentScreenShareSceneValue;
        }
        // Restore highlight scene selection
        if (
          currentHighlightSceneValue &&
          obsScenes.some(
            (scene) => scene.sceneName === currentHighlightSceneValue
          )
        ) {
          highlightSceneSelect.value = currentHighlightSceneValue;
        }

        // Populate and restore selections for scene dropdowns in stream mappings
        mappingSceneSelects.forEach((select, index) => {
          populateSceneDropdown(obsScenes, select);
          if (
            currentMappingSceneValues[index] &&
            obsScenes.some(
              (scene) => scene.sceneName === currentMappingSceneValues[index]
            )
          ) {
            select.value = currentMappingSceneValues[index];
          }
        });
        // After updating all dropdowns, update the "other scenes" list as it depends on the main scene selection
        updateOtherScenesList();
      }

      /**
       * Loads stream mapping rules from localStorage.
       */
      function loadStreamMappings() {
        const mappingsJson = localStorage.getItem("obsNinjaStreamMappings");
        if (mappingsJson) {
          try {
            const mappings = JSON.parse(mappingsJson);
            mappings.forEach((mapping) => {
              addNewStreamMapping(
                mapping.streamId,
                mapping.label,
                mapping.sceneName,
                mapping.matchType,
                mapping.cloneToMain !== undefined ? mapping.cloneToMain : true, // Default to true
                mapping.switchToScene !== undefined
                  ? mapping.switchToScene
                  : false // Default to false
              );
            });
            // If scenes are already loaded, update the dropdowns within the newly added mappings
            if (obsScenes && obsScenes.length > 0) {
              updateSceneDropdowns(); // This will repopulate and try to restore selections
            }
            logMessage(`Loaded ${mappings.length} stream mappings.`);
          } catch (e) {
            logMessage(
              `Error loading stream mappings from localStorage: ${e.message}`
            );
          }
        }
      }
      /**
       * Retrieves current stream mapping rules from the UI.
       * @returns {Array<Object>} An array of mapping rule objects.
       */
      function getStreamMappings() {
        const mappings = [];
        document.querySelectorAll(".stream-mapping").forEach((div) => {
          const streamIdInput = div.querySelector(".mapping-stream-id");
          const labelInput = div.querySelector(".mapping-label");
          const matchTypeSelect = div.querySelector(".mapping-match-type");
          const sceneNameSelect = div.querySelector(".mapping-scene-name");
          const cloneToMainCheckbox = div.querySelector(
            ".mapping-clone-to-main"
          );
          const switchToSceneCheckbox = div.querySelector(
            ".mapping-switch-to-scene"
          );

          // Ensure all elements are found before trying to access their values
          if (
            streamIdInput &&
            labelInput &&
            matchTypeSelect &&
            sceneNameSelect &&
            cloneToMainCheckbox &&
            switchToSceneCheckbox
          ) {
            const streamId = streamIdInput.value.trim();
            const label = labelInput.value.trim();
            const matchType = matchTypeSelect.value;
            const sceneName = sceneNameSelect.value.trim();
            const cloneToMain = cloneToMainCheckbox.checked;
            const switchToScene = switchToSceneCheckbox.checked;

            // A mapping rule is valid if it has a target scene and at least one identifier (ID or label)
            if (sceneName && (streamId || label)) {
              mappings.push({
                streamId,
                label,
                matchType,
                sceneName,
                cloneToMain,
                switchToScene,
              });
            }
          } else {
            logMessage(
              "Warning: Could not find all expected elements in a stream mapping UI div."
            );
          }
        });
        return mappings;
      }

      /**
       * Connects to the OBS WebSocket server.
       */
      async function connectToOBS() {
        // Validate essential prefix inputs
        if (
          cameraPrefixInput.value.trim() === "" ||
          reactionSubPrefixInput.value.trim() === "" ||
          highlightSubPrefixInput.value.trim() === ""
        ) {
          logMessage(
            "Error: Camera, Reaction, and Highlight prefixes are required for OBS connection."
          );
          obsStatusIndicator.classList.add("error");
          obsConnectionStatus.textContent = "Status: Error - Prefixes missing";
          return;
        }

        let url = obsWsUrlInput.value.trim();
        const password = obsWsPasswordInput.value; // Password can be empty

        if (!url) {
          logMessage("Error: OBS WebSocket URL is required.");
          obsStatusIndicator.classList.add("error");
          obsConnectionStatus.textContent = "Status: Error - URL missing";
          return;
        }
        // Prepend ws:// if no protocol is specified
        if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
          url = "ws://" + url;
          obsWsUrlInput.value = url; // Update the input field
        }

        obsConnectionStatus.textContent = "Status: Connecting...";
        obsStatusIndicator.classList.remove("connected", "error");
        logMessage(`Attempting to connect to OBS WebSocket at ${url}...`);

        // Timeout for the connection attempt
        const connectionTimeoutId = setTimeout(() => {
          if (
            obs &&
            obs.readyState !== WebSocket.OPEN &&
            obs.readyState !== WebSocket.CONNECTING
          ) {
            logMessage("OBS WebSocket connection attempt timed out.");
            if (obs) {
              try {
                obs.close();
              } catch (e) {}
              obs = null;
            } // Clean up
            obsConnectionStatus.textContent =
              "Status: Error - Connection timed out";
            obsStatusIndicator.classList.add("error");
            obsConnectBtn.textContent = "Connect"; // Reset button
            obsConnectBtn.classList.remove("connected");
            obsConnectBtn.classList.add("disconnected");
          }
        }, 10000); // 10 seconds

        try {
          obs = new WebSocket(url); // Create the WebSocket connection

          obs.onopen = () => {
            logMessage(
              "OBS WebSocket connection opened. Waiting for Server Hello..."
            );
            // Server will send OpCode 0 (Hello)
          };

          obs.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);
              // logMessage(`OBS RX (${message.op}): ${JSON.stringify(message.d || message)}`); // Verbose logging

              if (message.op === 0) {
                // OpCode 0: Hello from server
                logMessage("Received Hello from OBS. Sending Identify...");
                const identifyPayload = {
                  op: 1, // OpCode 1: Identify
                  d: {
                    rpcVersion: 1,
                    eventSubscriptions:
                      (1 << 0) |
                      (1 << 1) |
                      (1 << 2) |
                      (1 << 3) |
                      (1 << 6) |
                      (1 << 7) |
                      (1 << 8) |
                      (1 << 9), // Common subscriptions
                  },
                };
                if (message.d && message.d.authentication) {
                  const { challenge, salt } = message.d.authentication;
                  if (password) {
                    identifyPayload.d.authentication =
                      await generateAuthResponse(password, salt, challenge);
                    logMessage(
                      "Authentication data prepared for Identify message."
                    );
                  } else {
                    logMessage(
                      "Warning: OBS server requires authentication, but no password provided."
                    );
                  }
                }
                obs.send(JSON.stringify(identifyPayload));
              } else if (message.op === 2) {
                // OpCode 2: Identified
                clearTimeout(connectionTimeoutId);
                logMessage(
                  "OBS WebSocket Authentication successful! Connection established."
                );
                obsConnected = true;
                obsConnectBtn.textContent = "Disconnect";
                obsConnectBtn.classList.add("connected");
                obsConnectBtn.classList.remove("disconnected");
                obsConnectionStatus.textContent = "Status: Connected";
                obsStatusIndicator.classList.add("connected");
                obsStatusIndicator.classList.remove("error");
                onObsConnected();
              } else if (message.op === 7) {
                // OpCode 7: RequestResponse
                const entry =
                  message.d && message.d.requestId
                    ? requestCallbacks[message.d.requestId]
                    : null;

                if (entry) {
                  const responseData = message.d;
                  const requestStatus = responseData.requestStatus;
                  // Use requestType from entry if not in responseData (some OBS responses might omit it)
                  const requestType =
                    responseData.requestType || entry.requestType;

                  if (requestStatus && requestStatus.code === 100) {
                    // Success
                    entry.resolve(responseData.responseData || {});
                  } else {
                    // Failure or error
                    const errorMessage = requestStatus
                      ? requestStatus.comment
                      : "Unknown error";
                    const errorCode = requestStatus ? requestStatus.code : "N/A";

                    const suppressLog =
                      entry.suppressNotFound && errorCode === 600;

                    if (!suppressLog) {
                      logMessage(
                        `OBS Request Error (Type: ${requestType}, ID: ${responseData.requestId}): ${errorMessage} (Code: ${errorCode})`
                      );
                    }
                    entry.reject(
                      new Error(
                        `Request ${requestType} failed: ${errorMessage} (Code: ${errorCode})`
                      )
                    );
                  }
                  delete requestCallbacks[responseData.requestId];
                } else if (message.d && message.d.requestId) {
                  // logMessage(`Received response for unknown or timed-out request ID: ${message.d.requestId}`);
                }
              } else if (message.op === 5) {
                // OpCode 5: Event
                if (message.d && message.d.eventType === "SceneListChanged") {
                  logMessage(
                    "OBS Event: Scene list changed. Re-fetching scenes."
                  );
                  fetchObsScenes();
                }
              }
            } catch (error) {
              logMessage(
                `Error processing OBS WebSocket message: ${error.message}. Data: ${event.data}`
              );
            }
          };

          obs.onerror = (errorEvent) => {
            clearTimeout(connectionTimeoutId);
            let errorMsg = "Unknown WebSocket error";
            if (errorEvent && errorEvent.message) {
              errorMsg = errorEvent.message;
            } else if (typeof errorEvent === "string") {
              errorMsg = errorEvent;
            }
            logMessage(`OBS WebSocket Error: ${errorMsg}`);
            obsStatusIndicator.classList.add("error");
            obsConnectionStatus.textContent = "Status: Error";
            obsConnectBtn.textContent = "Connect";
            obsConnectBtn.classList.remove("connected");
            obsConnectBtn.classList.add("disconnected");
            obsConnected = false;
          };

          obs.onclose = (event) => {
            clearTimeout(connectionTimeoutId);
            let reason = "";
            if (event.code === 4009) {
              reason =
                "Authentication Failed - incorrect password or auth required and not provided.";
            } else if (event.reason) {
              reason = event.reason;
            } else {
              reason = `Code: ${event.code || "Unknown"}${
                event.wasClean ? "" : " (Unclean disconnection)"
              }`;
            }
            logMessage(`OBS WebSocket Connection Closed. Reason: ${reason}`);
            onObsDisconnected();
          };
        } catch (error) {
          clearTimeout(connectionTimeoutId);
          logMessage(
            `Error creating OBS WebSocket connection: ${error.message}`
          );
          obsConnectionStatus.textContent = "Status: Error";
          obsStatusIndicator.classList.add("error");
          obsConnectBtn.textContent = "Connect";
          obsConnectBtn.classList.remove("connected");
          obsConnectBtn.classList.add("disconnected");
          obsConnected = false;
        }
      }

      /**
       * Generates the authentication string for OBS WebSocket v5.
       * @param {string} password - The OBS WebSocket password.
       * @param {string} salt - The salt provided by the server.
       * @param {string} challenge - The challenge provided by the server.
       * @returns {Promise<string>} The base64 encoded authentication string.
       */
      async function generateAuthResponse(password, salt, challenge) {
        const encoder = new TextEncoder();
        try {
          const secretString = password + salt;
          const secretData = encoder.encode(secretString);
          let secretHash;

          if (window.crypto && window.crypto.subtle) {
            const hashBuffer = await window.crypto.subtle.digest(
              "SHA-256",
              secretData
            );
            secretHash = new Uint8Array(hashBuffer);
          } else {
            await loadJsShaLibrary();
            const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
            shaObj.update(secretString);
            const hashHex = shaObj.getHash("HEX");
            secretHash = new Uint8Array(
              hashHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
            );
          }

          const secretBase64 = btoa(String.fromCharCode.apply(null, secretHash));
          const authString = secretBase64 + challenge;
          const authData = encoder.encode(authString);
          let authHash;

          if (window.crypto && window.crypto.subtle) {
            const hashBuffer = await window.crypto.subtle.digest(
              "SHA-256",
              authData
            );
            authHash = new Uint8Array(hashBuffer);
          } else {
            const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
            shaObj.update(authString);
            const hashHex = shaObj.getHash("HEX");
            authHash = new Uint8Array(
              hashHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
            );
          }
          return btoa(String.fromCharCode.apply(null, authHash));
        } catch (error) {
          logMessage(`OBS Authentication generation error: ${error.message}`);
          throw error;
        }
      }

      /**
       * Sends a request to the OBS WebSocket server.
       * @param {string} requestType - The type of request (e.g., "GetSceneList").
       * @param {Object} [requestData={}] - The data for the request.
       * @param {Object} [options={}] - Optional settings for this request.
       * @param {boolean} [options.suppressNotFound=false] - If true, suppresses logging for "source not found" errors (code 600).
       * @returns {Promise<Object>} A promise that resolves with the response data.
       */
      function sendRequest(requestType, requestData = {}, options = {}) {
        return new Promise((resolve, reject) => {
          if (!obsConnected || !obs) {
            logMessage(
              `Cannot send request '${requestType}': Not connected to OBS.`
            );
            reject(new Error("Not connected to OBS"));
            return;
          }
          const requestId = generateRequestId(requestType);

          requestCallbacks[requestId] = {
            resolve,
            reject,
            requestType, // Store requestType for potential use in logging or error handling
            suppressNotFound: !!options.suppressNotFound,
          };

          const requestPayload = {
            op: 6, // OpCode 6: Request
            d: {
              requestType,
              requestId,
              requestData,
            },
          };
          // logMessage(`OBS TX (${requestPayload.op}): ${requestType} - ${JSON.stringify(requestData)}`);

          try {
            obs.send(JSON.stringify(requestPayload));
          } catch (error) {
            logMessage(
              `Error sending OBS request '${requestType}': ${error.message}`
            );
            if (requestCallbacks[requestId]) {
              // Check if entry exists before trying to use its properties
              const failedEntry = requestCallbacks[requestId];
              delete requestCallbacks[requestId];
              failedEntry.reject(error); // Reject with the send error
            } else {
              reject(error); // Fallback if entry somehow already deleted
            }
          }

          setTimeout(() => {
            if (requestCallbacks[requestId]) {
              const entry = requestCallbacks[requestId];
              delete requestCallbacks[requestId];
              logMessage(
                `OBS Request '${entry.requestType}' (ID: ${requestId}) timed out.`
              );
              entry.reject(new Error(`Request timeout for ${entry.requestType}`));
            }
          }, 5000); // 5-second timeout
        });
      }

      /**
       * Called when the OBS WebSocket connection is successfully established and identified.
       */
      function onObsConnected() {
        logMessage(
          "OBS Connection fully established. Fetching initial data..."
        );
        fetchObsScenes()
          .then(() => {
            if (sourceSizingSelect.value === "autoGrid" && getTargetScene()) {
              logMessage(
                "Initial rearrange for auto-grid on main target scene after OBS connection."
              );
              setTimeout(
                () => rearrangeAllStreamsInScene(getTargetScene()),
                1000
              );
            }
          })
          .catch((error) => {
            logMessage(
              `Error during post-OBS connection setup (fetching scenes): ${error.message}`
            );
          });
      }

      /**
       * Called when the OBS WebSocket connection is closed or fails.
       */
      function onObsDisconnected() {
        logMessage("OBS Connection has been closed or lost.");
        obsConnected = false;
        obsConnectBtn.textContent = "Connect";
        obsConnectBtn.classList.remove("connected");
        obsConnectBtn.classList.add("disconnected");
        obsConnectionStatus.textContent = "Status: Disconnected";
        obsStatusIndicator.classList.remove("connected", "error");

        Object.values(activeStreams).forEach(
          (stream) => (stream.sourceCreated = false)
        );
        updateStreamList();

        obsScenes = [];
        updateSceneDropdowns();
        updateOtherScenesList();
      }

      /**
       * Fetches the list of scenes from OBS and updates relevant UI elements.
       */
      async function fetchObsScenes() {
        if (!obsConnected || !obs) {
          logMessage("Cannot fetch OBS scenes: Not connected to OBS.");
          return;
        }
        logMessage("Fetching OBS scenes...");
        try {
          const response = await sendRequest("GetSceneList");
          const settingsJson = localStorage.getItem("obsNinjaSettings");
          const settings = settingsJson ? JSON.parse(settingsJson) : {};

          if (response && response.scenes) {
            obsScenes = response.scenes;
            logMessage(`Workspaceed ${obsScenes.length} scenes from OBS.`);

            updateSceneDropdowns(); // Populate all dropdowns first

            // Now, restore saved settings
            if (
              settings.obsSceneName &&
              obsScenes.some((s) => s.sceneName === settings.obsSceneName)
            ) {
              obsSceneSelect.value = settings.obsSceneName;
            } else if (settings.obsSceneName) {
              logMessage(
                `Previously selected main scene "${settings.obsSceneName}" no longer found. Please reselect.`
              );
            }

            if (
              settings.screenShareScene === "" ||
              (settings.screenShareScene &&
                obsScenes.some((s) => s.sceneName === settings.screenShareScene))
            ) {
              document.getElementById("screenShareSceneSelect").value =
                settings.screenShareScene;
            } else if (settings.screenShareScene) {
              logMessage(
                `Previously selected screen share scene "${settings.screenShareScene}" no longer found. Defaulting to "Same as main".`
              );
            }

            if (
              settings.highlightScene &&
              obsScenes.some((s) => s.sceneName === settings.highlightScene)
            ) {
              highlightSceneSelect.value = settings.highlightScene;
            } else if (settings.highlightScene) {
              logMessage(
                `Previously selected highlight scene "${settings.highlightScene}" no longer found. Please reselect.`
              );
            }

            updateOtherScenesList(); // This depends on main scene selection, so call after setting it.

            const savedMappingsJson =
              localStorage.getItem("obsNinjaStreamMappings");
            if (savedMappingsJson) {
              try {
                const mappings = JSON.parse(savedMappingsJson);
                document
                  .querySelectorAll(".mapping-scene-name")
                  .forEach((select, index) => {
                    if (mappings[index] && mappings[index].sceneName) {
                      if (
                        obsScenes.some(
                          (scene) =>
                            scene.sceneName === mappings[index].sceneName
                        )
                      ) {
                        select.value = mappings[index].sceneName;
                      } else {
                        // logMessage(`Saved scene "${mappings[index].sceneName}" for mapping rule ${index + 1} not found.`);
                      }
                    }
                  });
              } catch (e) {
                logMessage(
                  `Error applying saved scene selections to stream mappings: ${e.message}`
                );
              }
            }
            obsSceneNameInput.value = obsSceneSelect.value;
          } else {
            logMessage("Failed to fetch OBS scenes or no scenes returned.");
            obsScenes = [];
            updateSceneDropdowns();
            updateOtherScenesList();
          }
        } catch (error) {
          logMessage(`Error fetching OBS scenes: ${error.message}`);
          obsScenes = [];
          updateSceneDropdowns();
          updateOtherScenesList();
        }
      }

      /**
       * Populates a given select element with OBS scene names.
       * @param {Array<Object>} scenesData - Array of scene objects from OBS.
       * @param {HTMLSelectElement} selectElement - The select element to populate.
       * @param {string} [placeholderText='Select a scene...'] - Placeholder text for the first option.
       */
      function populateSceneDropdown(
        scenesData,
        selectElement,
        placeholderText = "Select a scene..."
      ) {
        const currentValue = selectElement.value;

        if (selectElement.id === "screenShareSceneSelect") {
          selectElement.innerHTML = '<option value="">Same as main</option>';
        } else {
          selectElement.innerHTML = `<option value="">${placeholderText}</option>`;
        }

        if (!scenesData || scenesData.length === 0) {
          return;
        }

        scenesData.forEach((scene) => {
          const option = document.createElement("option");
          option.value = scene.sceneName;
          option.textContent = scene.sceneName;
          selectElement.appendChild(option);
        });

        if (
          currentValue &&
          Array.from(selectElement.options).some(
            (opt) => opt.value === currentValue
          )
        ) {
          selectElement.value = currentValue;
        }
      }

      /**
       * Gets the currently selected main target scene from the UI.
       * @returns {string} The name of the selected OBS scene, or empty string if none.
       */
      function getTargetScene() {
        return obsSceneSelect.value || "";
      }

      /**
       * Constructs the VDO.Ninja view URL for a given stream ID.
       * @param {string} streamId - The VDO.Ninja Stream ID.
       * @param {boolean} [includeCommonParams=true] - Whether to include common viewing parameters.
       * @returns {string} The constructed VDO.Ninja URL.
       */
      function getVdoNinjaViewUrl(streamId, includeCommonParams = true) {
        const room = vdoNinjaRoomInput.value.trim();
        const ninjaPassword = vdoNinjaPasswordInput.value;
        const baseUrl = getVdoNinjaBaseUrl();
        const selectedCodec = sourceCodecSelect.value;

        let url = `${baseUrl}/?`;

        if (room) {
          url += `view=${encodeURIComponent(
            streamId
          )}&solo&room=${encodeURIComponent(room)}`;
        } else {
          url += `view=${encodeURIComponent(streamId)}`;
        }

        if (ninjaPassword) {
          url += `&password=${encodeURIComponent(ninjaPassword)}`;
        }
        if (selectedCodec && selectedCodec !== "") {
          url += `&codec=${encodeURIComponent(selectedCodec)}`;
        }
        if (includeCommonParams) {
          url +=
            "&cleanoutput&proaudio&ab=160&transparent&autoplay&noheader&webcursor";
        }
        return url;
      }

      /**
       * Initializes and loads the VDO.Ninja iframe with the appropriate URL.
       */
      function initializeVdoNinjaIframe() {
        const room = vdoNinjaRoomInput.value.trim();
        const streamIdsInput = vdoNinjaStreamIdsInput.value.trim();

        if (!room && !streamIdsInput) {
          logMessage(
            "VDO.Ninja: Room Name or specific Stream ID(s) must be provided to connect."
          );
          updateVdoNinjaButtonState(false);
          return;
        }

        const baseUrl = getVdoNinjaBaseUrl();
        let vdoNinjaUrl = `${baseUrl}/?`;

        if (room) {
          vdoNinjaUrl += `room=${encodeURIComponent(room)}`;
          if (streamIdsInput) {
            const viewStreamIds = streamIdsInput
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s)
              .join(",");
            if (viewStreamIds)
              vdoNinjaUrl += `&view=${encodeURIComponent(viewStreamIds)}&solo`;
          }
        } else if (streamIdsInput) {
          const viewStreamIds = streamIdsInput
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s)
            .join(",");
          if (viewStreamIds) {
            vdoNinjaUrl += `view=${encodeURIComponent(viewStreamIds)}`;
          } else {
            logMessage(
              "VDO.Ninja: Stream IDs provided but were empty after trimming."
            );
            updateVdoNinjaButtonState(false);
            return;
          }
        }

        if (vdoNinjaPasswordInput.value) {
          vdoNinjaUrl += `&password=${encodeURIComponent(
            vdoNinjaPasswordInput.value
          )}`;
        }

        vdoNinjaUrl +=
          "&cleanoutput&dataonly&nocursor&nopush&debug&noaudio&novideo&cors=" +
          encodeURIComponent(window.location.origin);

        logMessage(`Initializing VDO.Ninja iframe with URL: ${vdoNinjaUrl}`);
        vdoNinjaIframe.src = "about:blank";
        vdoNinjaIframe.setAttribute("crossorigin", "anonymous");

        setTimeout(() => {
          vdoNinjaIframe.src = vdoNinjaUrl;
          vdoNinjaLastActivityTime = Date.now();
        }, 100);
      }

      window.addEventListener(
        "message",
        (event) => {
          const expectedOriginBase = getVdoNinjaBaseUrl();
          let parsedExpectedOrigin;
          try {
            parsedExpectedOrigin = new URL(expectedOriginBase);
          } catch (e) {
            logMessage(
              `Invalid VDO.Ninja base URL in settings: ${expectedOriginBase}`
            );
            return;
          }

          if (
            event.origin !== parsedExpectedOrigin.origin ||
            event.source !== vdoNinjaIframe.contentWindow
          ) {
            return;
          }

          const data = event.data;
          vdoNinjaLastActivityTime = Date.now();

          if (!vdoNinjaConnected) {
            vdoNinjaConnected = true;
            updateVdoNinjaButtonState(true);
            if (vdoNinjaConnectionCheckTimer) {
              clearTimeout(vdoNinjaConnectionCheckTimer);
              vdoNinjaConnectionCheckTimer = null;
            }
            logMessage("VDO.Ninja iframe connection established and active.");
          }

          if (data && data.streamID) {
            const streamId = data.streamID;
            const label = data.label || `Stream ${streamId}`;

            if (
              (data.action === "view-connection" && data.value === true) ||
              data.action === "guest-connected" ||
              (data.action === "push-connection" && data.value === true)
            ) {
              logMessage(
                `VDO.Ninja stream connected/active: "${label}" (ID: ${streamId})`
              );
              activeStreams[streamId] = {
                label,
                sourceCreated: false,
                streamId,
                uuid: data.UUID || null,
                connected: true,
              };
              updateStreamList();

              if (autoAddSourcesCheckbox.checked) {
                logMessage(`Auto-adding stream ${streamId} to OBS.`);
                const targetInfo = getTargetSceneForStream(streamId, label);
                addStreamToObs(streamId, label, targetInfo);
              }
            } else if (
              (data.action === "view-connection" && data.value === false) ||
              (data.action === "push-connection" && data.value === false)
            ) {
              if (activeStreams[streamId]) {
                logMessage(
                  `VDO.Ninja stream disconnected/inactive: "${label}" (ID: ${streamId})`
                );
                if (
                  autoRemoveSourcesCheckbox &&
                  autoRemoveSourcesCheckbox.checked
                ) {
                  logMessage(`Auto-removing stream ${streamId} from OBS.`);
                  removeStreamFromObs(streamId);
                }
                delete activeStreams[streamId];
                updateStreamList();
              }
            } else if (
              data.action === "view-connection-info" &&
              data.value &&
              data.value.label
            ) {
              if (activeStreams[streamId]) {
                if (activeStreams[streamId].label !== data.value.label) {
                  logMessage(
                    `VDO.Ninja stream label updated for ID ${streamId}: "${data.value.label}" (was "${activeStreams[streamId].label}")`
                  );
                  activeStreams[streamId].label = data.value.label;
                  updateStreamList();
                }
              }
            }
          }
        },
        false
      );

      function startVdoNinjaConnectionMonitor() {
        setInterval(() => {
          if (
            vdoNinjaConnected &&
            Date.now() - vdoNinjaLastActivityTime > 45000
          ) {
            logMessage(
              "VDO.Ninja connection lost (no activity from iframe). Attempting to reset."
            );
            vdoNinjaConnectionStatus.textContent = "Status: Connection Lost";
            vdoNinjaStatusIndicator.classList.add("error");
            vdoNinjaStatusIndicator.classList.remove("connected");
            disconnectFromVdoNinja();
          }
        }, 30000);
      }

      async function addStreamToObs(
        streamId,
        streamLabel,
        targetInfo = null
      ) {
        if (!obsConnected || !obs) {
          logMessage(
            `Cannot add stream "${streamLabel}" (${streamId}) to OBS: Not connected to OBS.`
          );
          return;
        }

        const resolvedTargetInfo =
          targetInfo || getTargetSceneForStream(streamId, streamLabel);
        const targetSceneName = resolvedTargetInfo.scene;
        const mappingRule = resolvedTargetInfo.mapping;

        if (!targetSceneName) {
          logMessage(
            `Cannot add stream "${streamLabel}" (${streamId}): Target OBS scene name is required but not set (no default and no mapping).`
          );
          return;
        }

        const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
        const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
        let effectiveSourceName = baseSourceName;
        let sourceReallyExistsGlobally = false;

        // --- MODIFIED EXISTENCE CHECK ---
        try {
          await sendRequest(
            "GetInputSettings",
            { inputName: highlightedSourceName },
            { suppressNotFound: true }
          );
          logMessage(
            `Highlighted version '${highlightedSourceName}' found for stream ${streamId}. This will be managed.`
          );
          effectiveSourceName = highlightedSourceName;
          sourceReallyExistsGlobally = true;
          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = true;
          highlightedStreamId = streamId;
        } catch (e) {
          // e.message is "Request GetInputSettings failed: No source was found..."
          // Corrected IF condition from previous response (using && or !(A || B || C))
          if (
            !(
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"))
            )
          ) {
            logMessage(
              `Error checking for highlighted source '${highlightedSourceName}': ${e.message}. Will check for base source.`
            );
          }
          // Now check for base version
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: baseSourceName },
              { suppressNotFound: true }
            );
            logMessage(
              `Base version '${baseSourceName}' found for stream ${streamId}. This will be managed.`
            );
            effectiveSourceName = baseSourceName;
            sourceReallyExistsGlobally = true;
            if (activeStreams[streamId])
              activeStreams[streamId].sourceCreated = true;
          } catch (e2) {
            // The original condition for e2 was already better:
            // (!e2.message.toLowerCase().includes("not found") && !e2.message.toLowerCase().includes("does not exist")) || !e2.message.toLowerCase().includes("no source")
            // This evaluates to false for "not found" or "no source" messages.
            // Let's ensure it also handles "code 600" for consistency.
            const isNotFoundE2 =
              e2.message.toLowerCase().includes("not found") ||
              e2.message.toLowerCase().includes("does not exist") ||
              e2.message.toLowerCase().includes("no source") ||
              (e2.message.toLowerCase().includes("code") &&
                e2.message.toLowerCase().includes("600"));
            if (!isNotFoundE2) {
              logMessage(
                `Error checking for base source '${baseSourceName}': ${e2.message}. Will attempt to create.`
              );
            }
            effectiveSourceName = baseSourceName;
            sourceReallyExistsGlobally = false;
          }
        }
        // --- END MODIFIED EXISTENCE CHECK ---

        const mainDefaultScene = getTargetScene();
        let shouldCloneThisStreamToMain = false;
        if (
          mappingRule &&
          mappingRule.sceneName !== mainDefaultScene &&
          mappingRule.cloneToMain
        ) {
          shouldCloneThisStreamToMain = true;
        }
        let shouldSwitchToThisScene = false;
        if (mappingRule && mappingRule.switchToScene) {
          shouldSwitchToThisScene = true;
        }

        const vdoNinjaStreamUrl = getVdoNinjaViewUrl(streamId);
        let canvasWidth = 1920,
          canvasHeight = 1080;
        try {
          const videoSettings = await sendRequest("GetVideoSettings");
          if (
            videoSettings &&
            videoSettings.baseWidth &&
            videoSettings.baseHeight
          ) {
            canvasWidth = videoSettings.baseWidth;
            canvasHeight = videoSettings.baseHeight;
          }
        } catch (error) {
          logMessage(
            `Error getting OBS canvas size: ${error.message}. Using default ${canvasWidth}x${canvasHeight}.`
          );
        }

        const inputSettings = {
          url: vdoNinjaStreamUrl,
          width: canvasWidth,
          height: canvasHeight,
          fps: 30,
          reroute_audio: true,
          restart_when_active: false,
          shutdown: false,
        };

        logMessage(
          `Managing source '${effectiveSourceName}' (exists: ${sourceReallyExistsGlobally}) for stream "${streamLabel}" in OBS scene '${targetSceneName}'. URL: ${vdoNinjaStreamUrl}`
        );
        if (shouldCloneThisStreamToMain)
          logMessage(
            ` - Will also clone to main scene '${mainDefaultScene}'.`
          );
        if (shouldSwitchToThisScene)
          logMessage(
            ` - Will also switch OBS to scene '${targetSceneName}'.`
          );

        try {
          let initialSceneItemId = null;
          let clonedSceneItemId = null;

          if (!sourceReallyExistsGlobally) {
            logMessage(
              `Source '${baseSourceName}' does not exist globally. Creating it in scene '${targetSceneName}'.`
            );
            await sendRequest("CreateInput", {
              sceneName: targetSceneName,
              inputName: baseSourceName,
              inputKind: "browser_source",
              inputSettings,
              sceneItemEnabled: true,
            });
            effectiveSourceName = baseSourceName; // Ensure effectiveSourceName is the one created
            logMessage(
              `Source '${effectiveSourceName}' created and added to scene '${targetSceneName}'.`
            );
            try {
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: targetSceneName,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              initialSceneItemId = itemInfo.sceneItemId;
            } catch (e) {
              // logMessage(`Warning: Couldn't get scene item ID for new source '${effectiveSourceName}' in '${targetSceneName}': ${e.message}`);
            }
          } else {
            logMessage(
              `Source '${effectiveSourceName}' already exists globally. Updating its settings.`
            );
            await sendRequest("SetInputSettings", {
              inputName: effectiveSourceName,
              inputSettings,
            });
            try {
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: targetSceneName,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              initialSceneItemId = itemInfo.sceneItemId;
              logMessage(
                `Source '${effectiveSourceName}' found as item in scene '${targetSceneName}'.`
              );
            } catch (e) {
              if (
                e.message.toLowerCase().includes("not found") ||
                (e.message.toLowerCase().includes("code") &&
                  e.message.toLowerCase().includes("600"))
              ) {
                logMessage(
                  `Source '${effectiveSourceName}' exists globally but not in scene '${targetSceneName}'. Adding it.`
                );
                const createItemResponse = await sendRequest(
                  "CreateSceneItem",
                  {
                    sceneName: targetSceneName,
                    sourceName: effectiveSourceName,
                  }
                );
                initialSceneItemId = createItemResponse.sceneItemId;
              } else {
                throw e;
              }
            }
          }

          if (
            shouldCloneThisStreamToMain &&
            mainDefaultScene &&
            mainDefaultScene !== targetSceneName
          ) {
            logMessage(
              `Attempting to clone source '${effectiveSourceName}' to main scene '${mainDefaultScene}'.`
            );
            try {
              const itemInfo = await sendRequest(
                "GetSceneItemId",
                {
                  sceneName: mainDefaultScene,
                  sourceName: effectiveSourceName,
                },
                { suppressNotFound: true }
              );
              clonedSceneItemId = itemInfo.sceneItemId;
              logMessage(
                `Source '${effectiveSourceName}' already exists as an item in main scene '${mainDefaultScene}'.`
              );
            } catch (e) {
              if (
                e.message.toLowerCase().includes("not found") ||
                (e.message.toLowerCase().includes("code") &&
                  e.message.toLowerCase().includes("600"))
              ) {
                logMessage(
                  `Cloning source '${effectiveSourceName}' to main scene '${mainDefaultScene}'.`
                );
                const createCloneResponse = await sendRequest(
                  "CreateSceneItem",
                  {
                    sceneName: mainDefaultScene,
                    sourceName: effectiveSourceName,
                  }
                );
                clonedSceneItemId = createCloneResponse.sceneItemId;
              } else {
                logMessage(
                  `Error checking for '${effectiveSourceName}' in main scene '${mainDefaultScene}' before cloning: ${e.message}`
                );
              }
            }
          }

          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = true;

          if (initialSceneItemId) {
            await applyTransformAndGrid(
              targetSceneName,
              effectiveSourceName,
              canvasWidth,
              canvasHeight,
              initialSceneItemId
            );
          }
          if (clonedSceneItemId) {
            await applyTransformAndGrid(
              mainDefaultScene,
              effectiveSourceName,
              canvasWidth,
              canvasHeight,
              clonedSceneItemId
            );
          }

          const otherSceneCheckboxes = document.querySelectorAll(
            ".other-scene-checkbox:checked"
          );
          for (const checkbox of otherSceneCheckboxes) {
            const otherSceneName = checkbox.value;
            if (
              otherSceneName &&
              otherSceneName !== targetSceneName &&
              (!shouldCloneThisStreamToMain ||
                otherSceneName !== mainDefaultScene)
            ) {
              try {
                let otherSceneItemId = null;
                try {
                  const itemInfo = await sendRequest(
                    "GetSceneItemId",
                    {
                      sceneName: otherSceneName,
                      sourceName: effectiveSourceName,
                    },
                    { suppressNotFound: true }
                  );
                  otherSceneItemId = itemInfo.sceneItemId;
                  // logMessage(`Source '${effectiveSourceName}' already an item in other scene '${otherSceneName}'.`);
                } catch (e) {
                  /* OK if not found */
                }

                if (!otherSceneItemId) {
                  logMessage(
                    `Adding source '${effectiveSourceName}' as item to other scene '${otherSceneName}'.`
                  );
                  const createItemResponse = await sendRequest(
                    "CreateSceneItem",
                    {
                      sceneName: otherSceneName,
                      sourceName: effectiveSourceName,
                    }
                  );
                  otherSceneItemId = createItemResponse.sceneItemId;
                  if (otherSceneItemId) {
                    await applyTransformAndGrid(
                      otherSceneName,
                      effectiveSourceName,
                      canvasWidth,
                      canvasHeight,
                      otherSceneItemId
                    );
                  }
                }
              } catch (e) {
                logMessage(
                  `Error adding/cloning source '${effectiveSourceName}' to other scene '${otherSceneName}': ${e.message}`
                );
              }
            }
          }

          if (shouldSwitchToThisScene) {
            logMessage(
              `Switching OBS current program scene to '${targetSceneName}'.`
            );
            const studio = await sendRequest("GetStudioModeEnabled");
            if (studio.studioModeEnabled) {
              await sendRequest("SetCurrentPreviewScene", {
                sceneName: targetSceneName,
              });
              await sleep(200);
              await sendRequest("TriggerStudioModeTransition");
            } else {
              await sendRequest("SetCurrentProgramScene", {
                sceneName: targetSceneName,
              });
            }
          }
          logMessage(
            `Successfully processed stream "${streamLabel}" (${streamId}), effective OBS source: '${effectiveSourceName}'.`
          );

          const screenShareSourceNameToCheck = `${getFullReactionPrefix()}_${streamId}:s`;
          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: screenShareSourceNameToCheck },
              { suppressNotFound: true }
            );
            logMessage(
              `Existing screen share source '${screenShareSourceNameToCheck}' found for stream ${streamId}. Associating it.`
            );
            screenShareId = streamId;
          } catch (e) {
            // Only log if it's an unexpected error
            const isNotFound =
              e.message.toLowerCase().includes("not found") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error checking for existing screen share source '${screenShareSourceNameToCheck}': ${e.message}`
              );
            }
          }
        } catch (error) {
          logMessage(
            `Error managing stream '${effectiveSourceName}' ("${streamLabel}") in OBS: ${error.message}`
          );
          if (activeStreams[streamId])
            activeStreams[streamId].sourceCreated = false;
        } finally {
          updateStreamList();
        }
      }

      async function applyTransformAndGrid(
        sceneName,
        sourceName,
        canvasWidth,
        canvasHeight,
        sceneItemId = null
      ) {
        if (!sceneName) {
          logMessage(
            `Cannot apply transform for source '${sourceName}': Scene name not provided.`
          );
          return;
        }
        let itemIdToTransform = sceneItemId;

        if (!itemIdToTransform) {
          try {
            // logMessage(`Workspaceing scene item ID for '${sourceName}' in '${sceneName}' to apply transform.`);
            const itemInfo = await sendRequest(
              "GetSceneItemId",
              { sceneName, sourceName },
              { suppressNotFound: true }
            ); // Suppress if checking optional item
            if (itemInfo && itemInfo.sceneItemId) {
              itemIdToTransform = itemInfo.sceneItemId;
            } else {
              // logMessage(`Could not find scene item ID for '${sourceName}' in '${sceneName}'. Cannot apply transform.`);
              return;
            }
          } catch (error) {
            const isNotFound =
              error.message.toLowerCase().includes("not found") ||
              (error.message.toLowerCase().includes("code") &&
                error.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error fetching scene item ID for transform of '${sourceName}' in '${sceneName}': ${error.message}. Cannot apply transform.`
              );
            }
            return;
          }
        }

        if (!itemIdToTransform) {
          return;
        }

        if (sourceSizingSelect.value === "autoGrid") {
          logMessage(
            `Auto-grid enabled for scene '${sceneName}'. Triggering rearrange.`
          );
          await rearrangeAllStreamsInScene(sceneName);
        } else {
          try {
            const transform = calculateTransform(
              sourceSizingSelect.value,
              canvasWidth,
              canvasHeight,
              canvasWidth,
              canvasHeight
            );
            // logMessage(`Applying non-grid transform ('${sourceSizingSelect.value}') to '${sourceName}' (Item ID: ${itemIdToTransform}) in '${sceneName}'.`);
            await sendRequest("SetSceneItemTransform", {
              sceneName,
              sceneItemId: itemIdToTransform,
              sceneItemTransform: transform,
            });
          } catch (error) {
            logMessage(
              `Error applying non-grid transform to '${sourceName}' (Item ID: ${itemIdToTransform}) in '${sceneName}': ${error.message}`
            );
          }
        }
      }

      async function rearrangeAllStreamsInScene(sceneName) {
        if (
          !obsConnected ||
          !obs ||
          !sceneName ||
          sourceSizingSelect.value !== "autoGrid"
        ) {
          if (sourceSizingSelect.value !== "autoGrid") return;
          logMessage(
            `Cannot rearrange streams in scene '${sceneName}': OBS not connected, scene name missing, or auto-grid not selected.`
          );
          return;
        }
        logMessage(
          `Rearranging VDO.Ninja streams in scene '${sceneName}' using autoGrid layout.`
        );

        try {
          let canvasWidth = 1920,
            canvasHeight = 1080;
          try {
            const videoSettings = await sendRequest("GetVideoSettings");
            if (
              videoSettings &&
              videoSettings.baseWidth &&
              videoSettings.baseHeight
            ) {
              canvasWidth = videoSettings.baseWidth;
              canvasHeight = videoSettings.baseHeight;
            }
          } catch (error) {
            logMessage(
              `Canvas size error during rearrange for scene '${sceneName}': ${error.message}. Using default ${canvasWidth}x${canvasHeight}.`
            );
          }

          const sceneItemsResponse = await sendRequest("GetSceneItemList", {
            sceneName,
          });
          const camPrefixWithUnderscore = getFullCameraPrefix() + "_";
          const hlPrefixWithUnderscore = getFullHighlightPrefix() + "_";

          const vdoNinjaSourcesInScene = sceneItemsResponse.sceneItems.filter(
            (item) => {
              const isRegularCameraSource = item.sourceName.startsWith(
                camPrefixWithUnderscore
              );
              const isHighlightedCameraSource = item.sourceName.startsWith(
                hlPrefixWithUnderscore
              );

              let streamIdFromSourceName = null;
              if (isRegularCameraSource) {
                streamIdFromSourceName = item.sourceName.substring(
                  camPrefixWithUnderscore.length
                );
              } else if (isHighlightedCameraSource) {
                streamIdFromSourceName = item.sourceName.substring(
                  hlPrefixWithUnderscore.length
                );
              }

              return (
                (isRegularCameraSource || isHighlightedCameraSource) &&
                streamIdFromSourceName &&
                activeStreams[streamIdFromSourceName] &&
                activeStreams[streamIdFromSourceName].connected &&
                activeStreams[streamIdFromSourceName].sourceCreated
              );
            }
          );

          if (vdoNinjaSourcesInScene.length === 0) {
            // logMessage(`No active VDO.Ninja sources found in scene '${sceneName}' to rearrange for auto-grid.`);
            return;
          }

          const positions = calculateGridPositions(
            vdoNinjaSourcesInScene.length,
            canvasWidth,
            canvasHeight
          );

          // logMessage(`Calculated ${positions.length} grid positions for ${vdoNinjaSourcesInScene.length} sources in '${sceneName}'.`);

          for (let i = 0; i < vdoNinjaSourcesInScene.length; i++) {
            const item = vdoNinjaSourcesInScene[i];
            const transform = calculateTransform(
              "autoGrid",
              canvasWidth,
              canvasHeight,
              canvasWidth,
              canvasHeight,
              positions[i]
            );
            // logMessage(`Applying grid transform to '${item.sourceName}' (Item ID: ${item.sceneItemId}) in '${sceneName}': Pos X:${transform.positionX.toFixed(0)}, Y:${transform.positionY.toFixed(0)}, W:${transform.width.toFixed(0)}, H:${transform.height.toFixed(0)}`);
            await sendRequest("SetSceneItemTransform", {
              sceneName,
              sceneItemId: item.sceneItemId,
              sceneItemTransform: transform,
            });
          }
          logMessage(
            `Successfully rearranged ${vdoNinjaSourcesInScene.length} VDO.Ninja sources in scene '${sceneName}'.`
          );
        } catch (error) {
          logMessage(
            `Error rearranging streams in scene '${sceneName}': ${error.message}`
          );
        }
      }

      function calculateTransform(
        sizingMode,
        sourceWidth,
        sourceHeight,
        canvasWidth,
        canvasHeight,
        gridPosition = null
      ) {
        let transform = {
          alignment: 5,
          boundsType: "OBS_BOUNDS_NONE",
          boundsAlignment: 0,
          boundsWidth: sourceWidth,
          boundsHeight: sourceHeight,
          positionX: (canvasWidth - sourceWidth) / 2,
          positionY: (canvasHeight - sourceHeight) / 2,
          scaleX: 1.0,
          scaleY: 1.0,
          rotation: 0.0,
          cropTop: 0,
          cropBottom: 0,
          cropLeft: 0,
          cropRight: 0,
          sourceWidth: sourceWidth,
          sourceHeight: sourceHeight,
          width: sourceWidth,
          height: sourceHeight,
        };

        switch (sizingMode) {
          case "stretchToFill":
            transform.boundsType = "OBS_BOUNDS_STRETCH";
            transform.boundsWidth = canvasWidth;
            transform.boundsHeight = canvasHeight;
            transform.width = canvasWidth;
            transform.height = canvasHeight;
            transform.positionX = 0;
            transform.positionY = 0;
            break;
          case "bestFit":
            transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
            transform.boundsWidth = canvasWidth;
            transform.boundsHeight = canvasHeight;
            transform.width = canvasWidth;
            transform.height = canvasHeight;
            transform.positionX = 0;
            transform.positionY = 0;
            break;
          case "autoGrid":
            if (gridPosition) {
              transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
              transform.positionX = gridPosition.x;
              transform.positionY = gridPosition.y;
              transform.boundsWidth = gridPosition.width;
              transform.boundsHeight = gridPosition.height;
              transform.width = gridPosition.width;
              transform.height = gridPosition.height;
            } else {
              logMessage(
                "Warning: autoGrid sizing mode called without gridPosition. Falling back to 'bestFit'."
              );
              transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
              transform.boundsWidth = canvasWidth;
              transform.boundsHeight = canvasHeight;
              transform.width = canvasWidth;
              transform.height = canvasHeight;
              transform.positionX = 0;
              transform.positionY = 0;
            }
            break;
          case "defaultSize":
          default:
            // Centered default size
            transform.positionX = (canvasWidth - sourceWidth) / 2;
            transform.positionY = (canvasHeight - sourceHeight) / 2;
            // Ensure it doesn't go off screen if source is larger than canvas for default
            if (sourceWidth > canvasWidth) {
              transform.width = canvasWidth;
              transform.positionX = 0;
              transform.boundsType = "OBS_BOUNDS_SCALE_TO_WIDTH"; // Or SCALE_INNER to maintain aspect
              transform.boundsWidth = canvasWidth;
            }
            if (sourceHeight > canvasHeight) {
              transform.height = canvasHeight;
              transform.positionY = 0;
              transform.boundsType = "OBS_BOUNDS_SCALE_TO_HEIGHT"; // Or SCALE_INNER
              transform.boundsHeight = canvasHeight;
            }
            if (sourceWidth > canvasWidth && sourceHeight > canvasHeight) {
              transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
              transform.boundsWidth = canvasWidth;
              transform.boundsHeight = canvasHeight;
              transform.width = canvasWidth;
              transform.height = canvasHeight;
              transform.positionX = 0;
              transform.positionY = 0;
            }
            break;
        }
        return transform;
      }

      async function removeStreamFromObs(streamId) {
        if (!obsConnected || !obs) {
          logMessage(
            `Cannot remove stream ${streamId} from OBS: Not connected to OBS.`
          );
          return;
        }
        if (
          !activeStreams[streamId] &&
          streamId !== screenShareId &&
          streamId !== highlightedStreamId
        ) {
          // logMessage(`Stream ${streamId} not found in active local streams list. Removal process may be incomplete if it was not a shared resource (screen/highlight).`);
        }

        const baseSourceName = `${getFullCameraPrefix()}_${streamId}`;
        const highlightedSourceName = `${getFullHighlightPrefix()}_${streamId}`;
        logMessage(
          `User or auto-triggered removal of stream '${streamId}' from OBS. Base source: '${baseSourceName}', Highlighted: '${highlightedSourceName}'.`
        );

        const streamInfo = activeStreams[streamId];
        const currentLabel = streamInfo
          ? streamInfo.label
          : `Stream ${streamId}`;
        const targetInfo = getTargetSceneForStream(streamId, currentLabel);

        if (highlightedStreamId === streamId) {
          logMessage(
            `Stream ${streamId} is currently highlighted. Unhighlighting before removal.`
          );
          await toggleHighlight(streamId, currentLabel, targetInfo); // toggleHighlight now uses suppressNotFound for GetInputSettings
        }

        const scenesToClean = new Set();
        if (targetInfo && targetInfo.scene) {
          scenesToClean.add(targetInfo.scene);
        }
        const globalMainScene = getTargetScene();
        if (globalMainScene) {
          scenesToClean.add(globalMainScene);
        }
        document
          .querySelectorAll(".other-scene-checkbox:checked")
          .forEach((checkbox) => {
            if (checkbox.value) scenesToClean.add(checkbox.value);
          });

        let itemRemovedThisRun = false;

        for (const sceneName of scenesToClean) {
          if (!sceneName) continue;

          if (await tryRemoveFromScene(baseSourceName, sceneName)) {
            // tryRemoveFromScene uses suppressNotFound for GetSceneItemId
            itemRemovedThisRun = true;
          }
        }

        if (screenShareId === streamId) {
          logMessage(
            `Stream ${streamId} was actively screen sharing. Initiating screen share removal.`
          );
          await removeScreenShareFromObs(streamId); // removeScreenShareFromObs also needs suppressNotFound for GetInputSettings
        }

        if (activeStreams[streamId]) {
          activeStreams[streamId].sourceCreated = false;
        }

        if (itemRemovedThisRun) {
          logMessage(
            `Finished removing source items for stream ${streamId} from specified OBS scenes.`
          );
        } else {
          // logMessage(`No active source items for stream ${streamId} were present in the specified OBS scenes during this removal pass.`);
        }

        if (sourceSizingSelect.value === "autoGrid") {
          const uniqueScenesProcessed = new Set(
            Array.from(scenesToClean).filter((s) => s)
          );
          for (const sceneName of uniqueScenesProcessed) {
            logMessage(
              `Auto-grid: Triggering rearrange for scene '${sceneName}' after stream removal.`
            );
            setTimeout(() => rearrangeAllStreamsInScene(sceneName), 250);
          }
        }

        if (screenShareId !== streamId) {
          updateStreamList();
        }
        saveSettings();
      }

      async function removeScreenShareFromObs(streamIdToRemove) {
        if (!obsConnected || !obs) {
          logMessage("Cannot remove screen share: Not connected to OBS.");
          return;
        }
        if (!streamIdToRemove) {
          if (screenShareId === streamIdToRemove) {
            screenShareId = null;
            updateStreamList();
          }
          return;
        }

        const sourceName = `${getFullReactionPrefix()}_${streamIdToRemove}:s`;
        logMessage(
          `Attempting to fully remove screen share source '${sourceName}' from OBS (all scenes and input).`
        );

        let itemRemovedFromAnyScene = false;
        try {
          const scenesResponse = await sendRequest("GetSceneList");
          if (scenesResponse && scenesResponse.scenes) {
            for (const scene of scenesResponse.scenes) {
              if (await tryRemoveFromScene(sourceName, scene.sceneName)) {
                // tryRemoveFromScene uses suppressNotFound
                itemRemovedFromAnyScene = true;
              }
            }
          }

          try {
            await sendRequest(
              "GetInputSettings",
              { inputName: sourceName },
              { suppressNotFound: true }
            ); // Check if input exists, suppress log if not
            logMessage(`Removing global input '${sourceName}' from OBS.`);
            await sendRequest("RemoveInput", { inputName: sourceName });
            logMessage(`Successfully removed input '${sourceName}'.`);
          } catch (e) {
            const isNotFound =
              e.message.toLowerCase().includes("not found") ||
              e.message.toLowerCase().includes("does not exist") ||
              e.message.toLowerCase().includes("no source") ||
              (e.message.toLowerCase().includes("code") &&
                e.message.toLowerCase().includes("600"));

            if (!isNotFound) {
              logMessage(
                `Global input removal for '${sourceName}' failed (may be in use or other error): ${e.message}`
              );
            } else if (!itemRemovedFromAnyScene) {
              // logMessage(`Input '${sourceName}' not found for global removal and was not found as an item in any scene.`);
            }
          }
        } catch (error) {
          logMessage(
            `Error during screen share removal process for '${sourceName}': ${error.message}`
          );
        } finally {
          if (screenShareId === streamIdToRemove) {
            screenShareId = null;
          }
          updateStreamList();
        }
      }

      async function tryRemoveFromScene(sourceName, sceneName) {
        if (!sceneName) {
          // logMessage(`Cannot remove source '${sourceName}': Scene name not provided.`);
          return false;
        }
        try {
          const itemInfo = await sendRequest(
            "GetSceneItemId",
            { sceneName, sourceName },
            { suppressNotFound: true }
          ); // Suppress if item not found
          if (itemInfo && itemInfo.sceneItemId) {
            logMessage(
              `Removing source item '${sourceName}' (ID: ${itemInfo.sceneItemId}) from scene '${sceneName}'.`
            );
            await sendRequest("RemoveSceneItem", {
              sceneName,
              sceneItemId: itemInfo.sceneItemId,
            });
            // logMessage(`Successfully removed '${sourceName}' from scene '${sceneName}'.`);
            return true;
          }
          return false;
        } catch (error) {
          const isNotFound =
            error.message.toLowerCase().includes("not found") ||
            error.message.toLowerCase().includes("no scene items were found") ||
            error.message.toLowerCase().includes("could not find") ||
            (error.message.toLowerCase().includes("code") &&
              error.message.toLowerCase().includes("600"));
          if (!isNotFound) {
            logMessage(
              `Error trying to remove source item '${sourceName}' from scene '${sceneName}': ${error.message}`
            );
          }
          return false;
        }
      }

      function loadJsShaLibrary() {
        return new Promise((resolve, reject) => {
          if (typeof jsSHA !== "undefined") {
            resolve();
            return;
          }
          const script = document.createElement("script");
          script.src =
            "https://cdnjs.cloudflare.com/ajax/libs/jsSHA/3.3.0/sha256.js"; // Ensure this is a valid and trusted CDN
          script.onload = () => {
            logMessage(
              "jsSHA library loaded successfully (fallback for Web Crypto)."
            );
            resolve();
          };
          script.onerror = () => {
            logMessage(
              "Error: Failed to load jsSHA library. OBS authentication might fail if Web Crypto is also unavailable."
            );
            reject(new Error("Failed to load jsSHA library"));
          };
          document.head.appendChild(script);
        });
      }

      const otherScenesContainer = document.getElementById(
        "otherScenesContainer"
      );
      const otherScenesListDiv = document.getElementById("otherScenesList");
      const screenShareSceneSelect = document.getElementById(
        "screenShareSceneSelect"
      );

      obsSceneSelect.addEventListener("change", () => {
        obsSceneNameInput.value = obsSceneSelect.value;
        saveSettings();
        updateOtherScenesList();
        updateStreamList();
        if (sourceSizingSelect.value === "autoGrid" && getTargetScene()) {
          rearrangeAllStreamsInScene(getTargetScene());
        }
      });

      [
        obsWsUrlInput,
        obsWsPasswordInput,
        vdoNinjaBaseUrlInput,
        vdoNinjaRoomInput,
        vdoNinjaPasswordInput,
        vdoNinjaStreamIdsInput,
        autoAddSourcesCheckbox,
        autoRemoveSourcesCheckbox,
        highlightSceneSelect,
        screenShareSceneSelect,
      ].forEach((el) => {
        if (el) el.addEventListener("change", saveSettings);
      });

      sourceSizingSelect.addEventListener("change", () => {
        saveSettings();
        if (sourceSizingSelect.value === "autoGrid") {
          const mainTargetScene = getTargetScene();
          if (mainTargetScene) {
            rearrangeAllStreamsInScene(mainTargetScene);
          }
          document
            .querySelectorAll(".other-scene-checkbox:checked")
            .forEach((checkbox) => {
              if (checkbox.value) rearrangeAllStreamsInScene(checkbox.value);
            });
        } else {
          // If not autoGrid, apply standard transform to all managed sources in relevant scenes
          const scenesToUpdate = new Set();
          if (getTargetScene()) scenesToUpdate.add(getTargetScene());
          document
            .querySelectorAll(".other-scene-checkbox:checked")
            .forEach((cb) => scenesToUpdate.add(cb.value));
          getStreamMappings().forEach((m) => scenesToUpdate.add(m.sceneName));

          scenesToUpdate.forEach((sceneName) => {
            if (sceneName)
              applyStandardTransformToAllManagedStreamsInScene(sceneName);
          });
        }
      });

      async function applyStandardTransformToAllManagedStreamsInScene(
        sceneName
      ) {
        if (!obsConnected || !sceneName || sourceSizingSelect.value === "autoGrid")
          return;
        logMessage(
          `Applying standard transform ('${sourceSizingSelect.value}') to VDO.Ninja sources in scene '${sceneName}'.`
        );

        try {
          let canvasWidth = 1920,
            canvasHeight = 1080;
          const videoSettings = await sendRequest("GetVideoSettings");
          if (
            videoSettings &&
            videoSettings.baseWidth &&
            videoSettings.baseHeight
          ) {
            canvasWidth = videoSettings.baseWidth;
            canvasHeight = videoSettings.baseHeight;
          }

          const sceneItemsResponse = await sendRequest("GetSceneItemList", {
            sceneName,
          });
          const camPrefixWithUnderscore = getFullCameraPrefix() + "_";
          const hlPrefixWithUnderscore = getFullHighlightPrefix() + "_";

          for (const item of sceneItemsResponse.sceneItems) {
            const isManagedSource =
              (item.sourceName.startsWith(camPrefixWithUnderscore) ||
                item.sourceName.startsWith(hlPrefixWithUnderscore)) &&
              item.inputKind === "browser_source"; // Assuming VDO.Ninja sources are browser_source

            if (isManagedSource) {
              const streamIdGuess = item.sourceName
                .replace(camPrefixWithUnderscore, "")
                .replace(hlPrefixWithUnderscore, "");
              if (
                activeStreams[streamIdGuess] &&
                activeStreams[streamIdGuess].sourceCreated
              ) {
                // Check if it's one we are actively managing
                const transform = calculateTransform(
                  sourceSizingSelect.value,
                  canvasWidth,
                  canvasHeight,
                  canvasWidth,
                  canvasHeight
                );
                await sendRequest("SetSceneItemTransform", {
                  sceneName,
                  sceneItemId: item.sceneItemId,
                  sceneItemTransform: transform,
                });
              }
            }
          }
        } catch (error) {
          logMessage(
            `Error applying standard transform in scene '${sceneName}': ${error.message}`
          );
        }
      }

      sourceCodecSelect.addEventListener("change", async () => {
        saveSettings();
        const newCodec = sourceCodecSelect.value;
        logMessage(
          `Codec changed to: ${newCodec || "none"}. Updating OBS sources...`
        );

        if (!obsConnected) {
          logMessage(
            "OBS is not connected. Sources will not be updated with the new codec until reconnection and a new action."
          );
          return;
        }

        for (const streamId in activeStreams) {
          if (
            Object.hasOwnProperty.call(activeStreams, streamId) &&
            activeStreams[streamId].sourceCreated
          ) {
            let effectiveSourceName = `${getFullCameraPrefix()}_${streamId}`;
            if (highlightedStreamId === streamId) {
              effectiveSourceName = `${getFullHighlightPrefix()}_${streamId}`;
            }

            try {
              const currentSettingsResponse = await sendRequest(
                "GetInputSettings",
                { inputName: effectiveSourceName },
                { suppressNotFound: true }
              );
              if (
                currentSettingsResponse &&
                currentSettingsResponse.inputSettings
              ) {
                const newViewUrl = getVdoNinjaViewUrl(streamId);
                const updatedSettings = {
                  ...currentSettingsResponse.inputSettings,
                  url: newViewUrl,
                };

                await sendRequest("SetInputSettings", {
                  inputName: effectiveSourceName,
                  inputSettings: updatedSettings,
                });
                logMessage(
                  `Source '${effectiveSourceName}' updated with URL: ${newViewUrl}`
                );
              }
            } catch (error) {
              const isNotFound =
                error.message.toLowerCase().includes("not found") ||
                (error.message.toLowerCase().includes("code") &&
                  error.message.toLowerCase().includes("600"));
              if (!isNotFound) {
                logMessage(
                  `Error updating codec for source '${effectiveSourceName}': ${error.message}`
                );
              }
            }
          }
        }

        if (screenShareId) {
          const screenShareSourceName = `${getFullReactionPrefix()}_${screenShareId}:s`;
          try {
            const currentScreenShareSettingsResponse = await sendRequest(
              "GetInputSettings",
              { inputName: screenShareSourceName },
              { suppressNotFound: true }
            );
            if (
              currentScreenShareSettingsResponse &&
              currentScreenShareSettingsResponse.inputSettings
            ) {
              const room = vdoNinjaRoomInput.value.trim();
              const baseUrl = getVdoNinjaBaseUrl();
              let newScreenShareUrl = `${baseUrl}/?view=${encodeURIComponent(
                screenShareId
              )}:s&solo&room=${encodeURIComponent(room)}`;

              if (newCodec && newCodec !== "") {
                newScreenShareUrl += `&codec=${encodeURIComponent(newCodec)}`;
              } else {
                newScreenShareUrl += `&codec=vp9`;
              }
              if (vdoNinjaPasswordInput.value) {
                newScreenShareUrl += `&password=${encodeURIComponent(
                  vdoNinjaPasswordInput.value
                )}`;
              }
              newScreenShareUrl += "&cleanoutput&transparent&proaudio";

              const updatedScreenShareSettings = {
                ...currentScreenShareSettingsResponse.inputSettings,
                url: newScreenShareUrl,
              };

              await sendRequest("SetInputSettings", {
                inputName: screenShareSourceName,
                inputSettings: updatedScreenShareSettings,
              });
              logMessage(
                `Screen share source '${screenShareSourceName}' updated with URL: ${newScreenShareUrl}`
              );
            }
          } catch (error) {
            const isNotFound =
              error.message.toLowerCase().includes("not found") ||
              (error.message.toLowerCase().includes("code") &&
                error.message.toLowerCase().includes("600"));
            if (!isNotFound) {
              logMessage(
                `Error updating codec for screen share source '${screenShareSourceName}': ${error.message}`
              );
            }
          }
        }
        logMessage("Codec update for OBS sources complete.");
      });

      loadScenesBtn.addEventListener("click", fetchObsScenes);

      if (screenShareSceneSelect) {
        screenShareSceneSelect.addEventListener("change", saveSettings);
      }
      const screenShareWidthInput =
        document.getElementById("screenShareWidth");
      const screenShareHeightInput =
        document.getElementById("screenShareHeight");
      if (screenShareWidthInput)
        screenShareWidthInput.addEventListener("change", saveSettings);
      if (screenShareHeightInput)
        screenShareHeightInput.addEventListener("change", saveSettings);

      document.addEventListener("DOMContentLoaded", () => {
        loadSettings();
        logMessage("VDO.Ninja OBS Control Dock Initialized. Welcome!");

        updateVdoNinjaButtonState(false);
        toggleVdoNinjaInputs(false);

        const secureFields = document.querySelectorAll(
          "#vdoNinjaRoom, #vdoNinjaStreamIds"
        );
        secureFields.forEach((field) => {
          field.classList.add("blur-field");
          field.addEventListener("focus", () =>
            field.classList.remove("blur-field")
          );
          field.addEventListener("blur", () => {
            if (field.value === "") field.classList.add("blur-field");
          });
        });

        startVdoNinjaConnectionMonitor();
        updatePrefixLabels(); // Initial call to set prefix labels correctly
        updateStreamList(); // Ensure "No active streams" shows correctly styled initially
      });
    </script>
  </body>
</html>