<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VDO.Ninja OBS Control Dock</title>
    <style>
      body {
          font-family: sans-serif;
          margin: 5px;
          background-color: #13141A;
          color: #e0e0e0;
          font-size: 13px;
      }
      .container {
          margin-bottom: 10px;
          padding: 8px;
          background-color: #272A33;
          border-radius: 5px;
          border: 1px solid #3a3a48;
      }
      .collapsible {
          cursor: pointer;
          user-select: none;
          padding: 8px 0;
          position: relative;
          font-weight: bold;
          background: rgba(255,255,255,0.03);
          margin: -8px -8px 8px -8px;
          padding-left: 12px;
          border-bottom: 1px solid #3a3a48;
      }
      .collapsible::after {
          content: '▼';
          position: absolute;
          right: 12px;
          font-size: 12px;
          color: #8a8a9a;
          transition: transform 0.2s ease;
      }
      .collapsible.collapsed::after {
          content: '►';
          transform: none;
      }
      .collapsible:hover {
          background: rgba(255,255,255,0.08);
      }
      .collapsible::before {
          content: 'Click to ' attr(data-state);
          position: absolute;
          right: 30px;
          font-size: 10px;
          color: #666;
          font-weight: normal;
      }
      .collapsible[data-state="expand"]::before {
          content: 'Click to expand';
      }
      .collapsible[data-state="collapse"]::before {
          content: 'Click to collapse';
      }
      .collapsible-content {
          max-height: 1000px;
          overflow: hidden;
          transition: max-height 0.2s ease-out;
          padding-top: 5px;
      }
      .collapsible-content.collapsed {
          max-height: 0;
          padding-top: 0;
      }
      label {
          display: block;
          margin-bottom: 5px;
      }
      input[type="text"], input[type="password"], input[type="number"], select {
          width: calc(100% - 16px);
          padding: 5px;
          margin-bottom: 8px;
          border: 1px solid #424254;
          border-radius: 3px;
          background-color: #3C404D;
          color: #e0e0e0;
      }
      select {
          padding: 6px 5px;
          height: auto;
      }
      button {
          padding: 6px 10px;
          background-color: #3C404D;
          color: white;
          border: none;
          border-radius: 3px;
          cursor: pointer;
          margin-right: 3px;
          margin-bottom: 3px;
          font-size: 12px;
      }
      button.connected {
          background-color: #4C80AF;
      }
      button.disconnected {
          background-color: #484860;
      }
      button:hover {
          background-color: #5a5a7a;
      }
      .blur-field {
          filter: blur(5px);
          transition: filter 0.2s ease;
      }
      .blur-field:focus {
          filter: blur(0);
      }
      #vdoNinjaIframe {
          width: 1px;
          height: 1px;
          position: absolute;
          left: -1000px;
          top: -1000px;
          border: 0;
      }
      .log-area {
          height: 100px;
          background-color: #1a1a24;
          color: #ccc;
          border: 1px solid #424254;
          overflow-y: scroll;
          padding: 5px;
          font-family: monospace;
          font-size: 0.9em;
          margin-top: 5px;
          white-space: pre-wrap;
      }
      .status-indicator {
          display: inline-block;
          width: 8px;
          height: 8px;
          border-radius: 50%;
          margin-left: 5px;
          background-color: #555;
      }
      .status-indicator.connected {
          background-color: #4C80AF;
      }
      .status-indicator.error {
          background-color: #f44336;
      }
      .stream-list {
          background-color: #1a1a24;
          border: 1px solid #424254;
          border-radius: 3px;
          padding: 5px;
          margin-top: 3px;
          transition: max-height 0.3s ease;
      }
      .stream-list:empty {
          min-height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
      }
      .stream-item {
          padding: 4px;
          border-bottom: 1px solid #3c3c4a;
          font-size: 12px;
          word-break: break-word;
      }
      .stream-item:last-child {
          border-bottom: none;
      }
      h1, h2 {
          color: #c8c8c8;
          margin: 5px 0;
          font-size: 1.1em;
      }
      h1 {
          font-size: 1.2em;
      }
      small {
          color: #8a8a9a;
          font-size: 0.85em;
      }
      .add-stream-btn {
          background-color: #4C80AF;
          color: white;
          padding: 2px 4px;
          font-size: 11px;
      }
      .highlight-btn {
          padding: 2px 4px;
          color: white;
          cursor: pointer;
          font-size: 11px;
          transition: background-color 0.2s;
      }
      .screen-share-btn {
          background-color: #9C27B0;
          color: white;
          padding: 2px 4px;
          font-size: 11px;
      }
      .status-line {
          font-size: 12px;
          margin-top: 5px;
          display: flex;
          align-items: center;
      }
      input[type="checkbox"] {
          accent-color: #4C80AF;
          margin-right: 5px;
      }
      .checkbox-label {
          display: flex;
          align-items: center;
          margin-bottom: 3px;
      }
      .checkbox-label input {
          margin-right: 4px;
      }
      ::-webkit-scrollbar {
          width: 6px;
          height: 6px;
      }
      ::-webkit-scrollbar-track {
          background: #1a1a24;
          border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb {
          background: #3C404D;
          border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
          background: #4C80AF;
      }
      * {
          scrollbar-width: thin;
          scrollbar-color: #3C404D #1a1a24;
      }
      .flex-row {
          display: flex;
          gap: 4px;
          flex-wrap: wrap;
      }
      #obsSceneNameInput {
          display: none !important;
      }
      #loadScenesBtn {
          display: inline-block;
          margin-left: 5px;
          vertical-align: top;
      }
      .container:nth-child(6) .collapsible-content { /* Adjusted for new container */
          max-height: none !important;
          overflow: visible !important;
      }
      .prefix-input-label {
        margin-bottom: 2px;
        display: block;
      }
      .prefix-group {
        margin-bottom: 8px;
      }
    </style>
  </head>
  <body>
    <h1>VDO.Ninja OBS Control</h1>

    <div class="container">
      <h2 class="collapsible" data-state="collapse">
        OBS WebSocket Connection
      </h2>
      <div class="collapsible-content">
        <label for="obsWsUrl">WebSocket URL:</label>
        <input type="text" id="obsWsUrl" value="ws://localhost:4455" />

        <label for="obsWsPassword">Password:</label>
        <input type="password" id="obsWsPassword" value="" />

        <div class="prefix-group" style="margin-top:10px;">
            <label for="cameraPrefix" id="cameraSubPrefixLabelText" class="prefix-input-label">Camera prefix:</label>
            <input type="text" id="cameraPrefix" value="VDO">
        </div>
        <div class="prefix-group">
            <label for="reactionSubPrefix" id="reactionSubPrefixLabelText" class="prefix-input-label">Reaction prefix: VDO.</label>
            <input type="text" id="reactionSubPrefix" value="Screen">
        </div>
        <div class="prefix-group">
            <label for="highlightSubPrefix" id="highlightSubPrefixLabelText" class="prefix-input-label">Highlight prefix: VDO.</label>
            <input type="text" id="highlightSubPrefix" value="Highlight">
        </div>

        <div class="status-line">
          <button id="obsConnectBtn">Connect to OBS</button>
          <span id="obsConnectionStatus">Status: Disconnected</span>
          <span id="obsStatusIndicator" class="status-indicator"></span>
        </div>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="collapse">VDO.Ninja Settings</h2>
      <div class="collapsible-content">
        <label for="vdoNinjaBaseUrl">VDO.Ninja Base URL:</label>
        <input
          type="text"
          id="vdoNinjaBaseUrl"
          placeholder="https://vdo.ninja"
          value="https://vdo.ninja"
        />

        <label for="vdoNinjaRoom">Room Name:</label>
        <input
          type="text"
          id="vdoNinjaRoom"
          placeholder="e.g., MyNinjaRoom"
          class="blur-field"
        />

        <label for="vdoNinjaPassword">Password:</label>
        <input
          type="password"
          id="vdoNinjaPassword"
          placeholder="Room or &password"
        />

        <label for="vdoNinjaStreamIds">Stream IDs:</label>
        <input
          type="text"
          id="vdoNinjaStreamIds"
          placeholder="streamId1,streamId2"
          class="blur-field"
        />
        <small>Room Name or Stream ID(s) needed</small>
      </div>
    </div>
    
    <div class="container">
      <h2 class="collapsible" data-state="expand">Stream ID Mappings</h2>
      <div class="collapsible-content collapsed">
        <div id="streamMappingContainer">
          <div id="streamMappings"></div>
          <button id="addStreamMappingBtn">Add New Mapping</button>
        </div>
      </div>
    </div>

    <div class="container">
      <h2 class="collapsible" data-state="expand">OBS Target Settings</h2>
      <div class="collapsible-content collapsed">
        <label for="obsSceneSelect">Target Scene:</label>
        <div style="display: flex; align-items: center; gap: 5px;">
          <select id="obsSceneSelect" style="flex: 1;">
            <option value="">Select a scene...</option>
          </select>
          <button id="loadScenesBtn">Re-Fetch Scenes</button>
        </div>
        <div
          id="otherScenesContainer"
          style="margin-top: 10px; border-top: 1px solid #3a3a48; padding-top: 10px; display: none;"
        >
          <label>Copy sources to other scenes(reference):</label>
          <div id="otherScenesList"></div>
        </div>
        <input type="text" id="obsSceneNameInput" style="display:none;" />

        <div
          style="margin-top: 10px; border-top: 1px solid #3a3a48; padding-top: 10px;"
        >
          <label>Screen Sharing Settings:</label>
          <div style="display: flex; gap: 10px; margin-bottom: 8px;">
            <div>
              <label style="font-size: 11px;">Width:</label>
              <input
                type="number"
                id="screenShareWidth"
                value="1920"
                style="width: 80px;"
              />
            </div>
            <div>
              <label style="font-size: 11px;">Height:</label>
              <input
                type="number"
                id="screenShareHeight"
                value="1080"
                style="width: 80px;"
              />
            </div>
            <div>
              <label style="font-size: 11px;">Target Scene:</label>
              <select id="screenShareSceneSelect" style="width: 150px;">
                <option value="">Same as main</option>
              </select>
            </div>
          </div>
        </div>

        <label for="sourceSizing">New Source Sizing:</label>

        <select id="sourceSizing">
          <option value="defaultSize">Default (1920x1080 at 0,0)</option>
          <option value="bestFit">Best Fit (Preserve Aspect)</option>
          <option value="stretchToFill">Stretch to Fill Screen</option>
          <option value="autoGrid">Auto Grid Layout</option>
        </select>

        <div id="autoSourceOptions">
          <label class="checkbox-label">
            <input type="checkbox" id="autoAddSources" checked />
            Auto-add new streams as sources
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="autoRemoveSources" checked />
            Auto-remove sources on disconnect
          </label>
        </div>
      </div>
    </div>
    <div class="container">
      <h2 class="collapsible" data-state="expand">Active Streams</h2>
      <div class="collapsible-content collapsed">
        <div id="streamList" class="stream-list">
          <div class="stream-item">No active streams</div>
        </div>
      </div>
    </div>

    <iframe
      id="vdoNinjaIframe"
      allow="encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;midi *;geolocation;camera *;microphone *;fullscreen;picture-in-picture;display-capture;accelerometer;autoplay;gyroscope;screen-wake-lock;"
    ></iframe>

    <div class="container">
      <h2 class="collapsible" data-state="expand">Log</h2>
      <div class="collapsible-content collapsed">
        <div id="logArea" class="log-area"></div>
      </div>
    </div>

    <script>
      // DOM elements
      const obsWsUrlInput = document.getElementById('obsWsUrl');
      const obsWsPasswordInput = document.getElementById('obsWsPassword');
      const obsConnectBtn = document.getElementById('obsConnectBtn');
      const obsConnectionStatus = document.getElementById('obsConnectionStatus');
      const obsStatusIndicator = document.getElementById('obsStatusIndicator');

      const cameraPrefixInput = document.getElementById('cameraPrefix');
      const reactionSubPrefixInput = document.getElementById('reactionSubPrefix');
      const highlightSubPrefixInput = document.getElementById('highlightSubPrefix');
      const cameraSubPrefixLabelText = document.getElementById('cameraSubPrefixLabelText');
      const reactionSubPrefixLabelText = document.getElementById('reactionSubPrefixLabelText');
      const highlightSubPrefixLabelText = document.getElementById('highlightSubPrefixLabelText');

      const vdoNinjaBaseUrlInput = document.getElementById('vdoNinjaBaseUrl');
      const vdoNinjaRoomInput = document.getElementById('vdoNinjaRoom');
      const vdoNinjaPasswordInput = document.getElementById('vdoNinjaPassword');
      const vdoNinjaStreamIdsInput = document.getElementById('vdoNinjaStreamIds');
      const vdoNinjaIframe = document.getElementById('vdoNinjaIframe');

      const obsSceneNameInput = document.getElementById('obsSceneNameInput');
      const obsSceneSelect = document.getElementById('obsSceneSelect');
      const sourceSizingSelect = document.getElementById('sourceSizing');
      const autoAddSourcesCheckbox = document.getElementById('autoAddSources');
      const autoRemoveSourcesCheckbox = document.getElementById('autoRemoveSources');
      const streamListContainer = document.getElementById('streamList');
      const logArea = document.getElementById('logArea');
      const loadScenesBtn = document.getElementById('loadScenesBtn');
      let vdoNinjaConnected = false;

      // Set up collapsible sections
      document.querySelectorAll('.collapsible').forEach(header => {
          header.addEventListener('click', function() {
              this.classList.toggle('collapsed');
              const content = this.nextElementSibling;
              if (content.classList.contains('collapsible-content')) {
                  content.classList.toggle('collapsed');
                  if (content.classList.contains('collapsed')) {
                      this.setAttribute('data-state', 'expand');
                  } else {
                      this.setAttribute('data-state', 'collapse');
                  }
              }
          });
      });

      const vdoNinjaConnectBtn = document.createElement('button');
      vdoNinjaConnectBtn.id = 'vdoNinjaConnectBtn';
      vdoNinjaConnectBtn.textContent = 'Connect to VDO.Ninja';
      vdoNinjaConnectBtn.style.marginTop = '5px';

      const vdoNinjaStatusIndicator = document.createElement('span');
      vdoNinjaStatusIndicator.id = 'vdoNinjaStatusIndicator';
      vdoNinjaStatusIndicator.className = 'status-indicator';

      const vdoNinjaConnectionStatus = document.createElement('span');
      vdoNinjaConnectionStatus.id = 'vdoNinjaConnectionStatus';
      vdoNinjaConnectionStatus.textContent = 'Status: Disconnected';
      vdoNinjaConnectionStatus.style.marginLeft = '5px';

      const vdoNinjaSettingsContainer = document.querySelector('.container:nth-child(2)'); // VDO.Ninja Settings container
      const buttonsDiv = document.createElement('div');
      buttonsDiv.style.marginTop = '5px';
      buttonsDiv.className = 'status-line';
      buttonsDiv.appendChild(vdoNinjaConnectBtn);
      buttonsDiv.appendChild(vdoNinjaConnectionStatus);
      buttonsDiv.appendChild(vdoNinjaStatusIndicator);
      vdoNinjaSettingsContainer.querySelector('.collapsible-content').appendChild(buttonsDiv);


      vdoNinjaConnectBtn.addEventListener('click', () => {
          if (vdoNinjaConnected) {
              disconnectFromVdoNinja();
          } else {
              connectToVdoNinja();
          }
      });

      // State variables
      let obs = null;
      let obsConnected = false;
      let activeStreams = {};
      let obsScenes = [];
      let requestCallbacks = {};

      let vdoNinjaLastActivityTime = 0;
      let vdoNinjaConnectionCheckTimer = null;

      let screenShareId = null;
      let highlightedStreamId = null;
      let loadedSelectedOtherScenes = [];


      // Helper functions
      function logMessage(message) {
      	console.log(message);
      	const timestamp = new Date().toLocaleTimeString();
      	logArea.innerHTML += `[${timestamp}] ${message}\n`;
      	logArea.scrollTop = logArea.scrollHeight;
      }

      function generateRequestId(type) {
      	return `${type}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      }

      function getVdoNinjaBaseUrl() {
          const customUrl = vdoNinjaBaseUrlInput.value.trim();
          return customUrl || "https://vdo.ninja";
      }

      function getFullCameraPrefix() { return cameraPrefixInput.value.trim(); }
      function getFullReactionPrefix() { return `${cameraPrefixInput.value.trim()}.${reactionSubPrefixInput.value.trim()}`; }
      function getFullHighlightPrefix() { return `${cameraPrefixInput.value.trim()}.${highlightSubPrefixInput.value.trim()}`; }


      function updatePrefixLabels() {
          const cameraPrefix = getFullCameraPrefix();
          const reactionPrefix = getFullReactionPrefix();
          const highlightPrefix = getFullHighlightPrefix();
          cameraSubPrefixLabelText.textContent = `Camera prefix: ${cameraPrefix}`;
          reactionSubPrefixLabelText.textContent = `Reaction prefix: ${reactionPrefix}`;
          highlightSubPrefixLabelText.textContent = `Highlight prefix: ${highlightPrefix}`;
      }
      cameraPrefixInput.addEventListener('input', () => {
          updatePrefixLabels();
          saveSettings();
      });
      reactionSubPrefixInput.addEventListener('input', saveSettings);
      highlightSubPrefixInput.addEventListener('input', saveSettings);


      function toggleVdoNinjaInputs(disabled) {
          vdoNinjaBaseUrlInput.disabled = disabled;
          vdoNinjaRoomInput.disabled = disabled;
          vdoNinjaPasswordInput.disabled = disabled;
          vdoNinjaStreamIdsInput.disabled = disabled;
      }
      function updateVdoNinjaButtonState(vdoNinjaConnected) {
          if (vdoNinjaConnected) {
              vdoNinjaConnectBtn.textContent = 'Disconnect from VDO.Ninja';
              vdoNinjaConnectBtn.classList.remove('disconnected');
              vdoNinjaConnectBtn.classList.add('connected');
              vdoNinjaConnectionStatus.textContent = 'Status: Connected';
              vdoNinjaStatusIndicator.classList.add('connected');
          } else {
              vdoNinjaConnectBtn.textContent = 'Connect to VDO.Ninja';
              vdoNinjaConnectBtn.classList.remove('connected');
              vdoNinjaConnectBtn.classList.add('disconnected');
              vdoNinjaConnectionStatus.textContent = 'Status: Disconnected';
              vdoNinjaStatusIndicator.classList.remove('connected');
          }
          toggleVdoNinjaInputs(vdoNinjaConnected);
          saveSettings();
      }

      function saveSettings() {
          const otherSceneCheckboxes = document.querySelectorAll('.other-scene-checkbox:checked');
          const selectedOtherScenes = Array.from(otherSceneCheckboxes).map(cb => cb.value);

          const settings = {
              obsWsUrl: obsWsUrlInput.value,
              obsWsPassword: obsWsPasswordInput.value,
              cameraPrefix: cameraPrefixInput.value,
              reactionSubPrefix: reactionSubPrefixInput.value,
              highlightSubPrefix: highlightSubPrefixInput.value,
              vdoNinjaBaseUrl: vdoNinjaBaseUrlInput.value,
              vdoNinjaRoom: vdoNinjaRoomInput.value,
              vdoNinjaPassword: vdoNinjaPasswordInput.value,
              vdoNinjaStreamIds: vdoNinjaStreamIdsInput.value,
              obsSceneName: obsSceneSelect.value,
              selectedOtherScenes: selectedOtherScenes,
              sourceSizing: sourceSizingSelect.value,
              autoAddSources: autoAddSourcesCheckbox.checked,
              autoRemoveSources: autoRemoveSourcesCheckbox.checked,
              vdoNinjaConnected: vdoNinjaConnected, // Consider if this should be saved or always start disconnected
              screenShareWidth: document.getElementById('screenShareWidth').value,
              screenShareHeight: document.getElementById('screenShareHeight').value,
              screenShareScene: document.getElementById('screenShareSceneSelect').value
          };
          localStorage.setItem('obsNinjaSettings', JSON.stringify(settings));

          const mappings = getStreamMappings();
          localStorage.setItem('obsNinjaStreamMappings', JSON.stringify(mappings));
      }

      function calculateGridPositions(totalSources, canvasWidth, canvasHeight) {
          const positions = [];
          let cols = Math.ceil(Math.sqrt(totalSources));
          let rows = Math.ceil(totalSources / cols);
          const cellWidth = canvasWidth / cols;
          const cellHeight = canvasHeight / rows;
          const lastRowItems = totalSources - ((rows - 1) * cols);
          const lastRowOffset = (cols - lastRowItems) * (cellWidth / 2);

          for (let row = 0; row < rows; row++) {
              for (let col = 0; col < cols; col++) {
                  const index = row * cols + col;
                  if (index < totalSources) {
                      let xPos = col * cellWidth;
                      if (row === rows - 1 && lastRowItems < cols) {
                          xPos += lastRowOffset;
                      }
                      positions.push({
                          x: xPos,
                          y: row * cellHeight,
                          width: cellWidth,
                          height: cellHeight
                      });
                  }
              }
          }
          return positions;
      }
      function disconnectFromVdoNinja() {
          vdoNinjaConnected = false;
          vdoNinjaIframe.src = 'about:blank';
          if (vdoNinjaConnectionCheckTimer) {
              clearTimeout(vdoNinjaConnectionCheckTimer);
              vdoNinjaConnectionCheckTimer = null;
          }
          activeStreams = {};
          updateStreamList();
          updateVdoNinjaButtonState(vdoNinjaConnected);
      }

      function connectToVdoNinja() {
          if (!vdoNinjaConnected) {
              const room = vdoNinjaRoomInput.value.trim();
              const streamIds = vdoNinjaStreamIdsInput.value.trim();

              if (!room && !streamIds) {
                  logMessage("VDO.Ninja Error: Room Name or Stream ID(s) must be provided.");
                  return;
              }
    
              initializeVdoNinjaIframe();
              vdoNinjaConnectionStatus.textContent = 'Status: Connecting...';
              vdoNinjaConnectBtn.textContent = 'Cancel';

              if (vdoNinjaConnectionCheckTimer) {
                  clearTimeout(vdoNinjaConnectionCheckTimer);
              }
              vdoNinjaConnectionCheckTimer = setTimeout(() => {
                  if (Date.now() - vdoNinjaLastActivityTime > 10000) { // 10 seconds
                      logMessage("VDO.Ninja connection timed out. No activity received.");
                      vdoNinjaConnectionStatus.textContent = 'Status: Connection Failed';
                      vdoNinjaConnectBtn.textContent = 'Connect to VDO.Ninja';
                      // No auto-disconnect here, user might retry
                  }
              }, 10000); // 10-second timeout
              toggleVdoNinjaInputs(true); // Disable inputs while attempting to connect
              saveSettings(); // Save settings like base URL before connecting
          }
      }

      function addNewStreamMapping(streamId = '', label = '', sceneName = '', matchType = 'streamId', shouldClone = true, shouldSwitch = false) {
          const streamMappings = document.getElementById('streamMappings');
          const mappingDiv = document.createElement('div');
          mappingDiv.className = 'stream-mapping';
          mappingDiv.style.margin = '5px 0';

          mappingDiv.innerHTML = `
              <div style="margin-bottom: 5px;">
                  <label style="font-size: 11px; margin-bottom: 2px; display: block;">Stream Mapping</label>
                  <div class="flex-row" style="align-items: center; flex-wrap: nowrap; margin-bottom: 2px;">
                      <input type="text" placeholder="Stream ID" value="${streamId instanceof PointerEvent ? '' : streamId}" class="mapping-stream-id" style="width:80px; margin-right: 4px;">
                      <input type="text" placeholder="Label (optional)" value="${label}" class="mapping-label" style="width:120px; margin-right: 4px;">
                      <select class="mapping-match-type" style="width:90px; margin-right: 4px;">
                          <option value="streamId" ${matchType === 'streamId' ? 'selected' : ''}>ID Only</option>
                          <option value="label" ${matchType === 'label' ? 'selected' : ''}>Label Only</option>
                          <option value="both" ${matchType === 'both' ? 'selected' : ''}>Both Required</option>
                          <option value="either" ${matchType === 'either' ? 'selected' : ''}>Either Match</option>
                      </select>
                      <select class="mapping-scene-name" style="width:130px;">
                          <option value="">Select a scene...</option>
                      </select>
                      <button class="remove-mapping-btn" style="width:auto; padding:3px 5px; margin-left: 4px;">×</button>
                  </div>
                  <div class="flex-row" style="margin-top: 3px; gap: 8px;">
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-clone-to-main" ${shouldClone ? 'checked' : ''}>
                          Clone to main scene
                      </label>
                      <label class="checkbox-label" style="margin-bottom: 0;">
                          <input type="checkbox" class="mapping-switch-to-scene" ${shouldSwitch ? 'checked' : ''}>
                          Switch to scene on add
                      </label>
                  </div>
                  <small style="color: #8a8a9a; font-size: 10px; display: block; margin-top: 2px;">
                      ID Only: Match by Stream ID only | Label Only: Match by label only |
                      Both Required: Must match both | Either Match: Match if either matches
                  </small>
              </div>
          `;

          streamMappings.appendChild(mappingDiv);
          const sceneDropdown = mappingDiv.querySelector('.mapping-scene-name');
          populateSceneDropdown(obsScenes, sceneDropdown);
          if (sceneName && obsScenes.some(scene => scene.sceneName === sceneName)) {
              sceneDropdown.value = sceneName;
          }

          const removeBtn = mappingDiv.querySelector('.remove-mapping-btn');
          removeBtn.addEventListener('click', () => {
              mappingDiv.remove();
              saveSettings();
          });
          const inputs = mappingDiv.querySelectorAll('input, select');
          inputs.forEach(input => {
              input.addEventListener('change', saveSettings);
          });
      }


      function setupStreamMappingUI() {
          const addStreamMappingBtn = document.getElementById('addStreamMappingBtn');
          addStreamMappingBtn.addEventListener('click', () => {
              addNewStreamMapping(); 
          });
          loadStreamMappings();
      }

      function loadSettings() {
          const settingsJson = localStorage.getItem('obsNinjaSettings');
          if (settingsJson) {
              try {
                  const settings = JSON.parse(settingsJson);
                  obsWsUrlInput.value = settings.obsWsUrl || 'ws://localhost:4455';
                  obsWsPasswordInput.value = settings.obsWsPassword || '';
                  
                  cameraPrefixInput.value = settings.cameraPrefix || 'VDO';
                  reactionSubPrefixInput.value = settings.reactionSubPrefix || 'Screen';
                  highlightSubPrefixInput.value = settings.highlightSubPrefix || 'Highlight';
                  updatePrefixLabels(); // Update labels based on loaded prefixes

                  vdoNinjaBaseUrlInput.value = settings.vdoNinjaBaseUrl || 'https://vdo.ninja';
                  vdoNinjaRoomInput.value = settings.vdoNinjaRoom || '';
                  vdoNinjaPasswordInput.value = settings.vdoNinjaPassword || '';
                  vdoNinjaStreamIdsInput.value = settings.vdoNinjaStreamIds || '';
                  
                  obsSceneSelect.value = settings.obsSceneName || ''; // Will be validated against fetched scenes later
                  loadedSelectedOtherScenes = settings.selectedOtherScenes || [];


                  sourceSizingSelect.value = settings.sourceSizing || 'defaultSize';
                  autoAddSourcesCheckbox.checked = settings.autoAddSources !== false;
                  autoRemoveSourcesCheckbox.checked = settings.autoRemoveSources !== false;

                  const screenShareWidthInput = document.getElementById('screenShareWidth');
                  const screenShareHeightInput = document.getElementById('screenShareHeight');
                  const screenShareSelect = document.getElementById('screenShareSceneSelect');

                  if (screenShareWidthInput) screenShareWidthInput.value = settings.screenShareWidth || '1920';
                  if (screenShareHeightInput) screenShareHeightInput.value = settings.screenShareHeight || '1080';
                  if (screenShareSelect) screenShareSelect.value = settings.screenShareScene || ''; // Validated later

                  // vdoNinjaConnected state is not restored from settings, always start as disconnected
                  // updateVdoNinjaButtonState(false); // Ensure UI reflects disconnected state initially

              } catch (e) {
                  logMessage(`Error loading settings from localStorage: ${e.message}`);
                  // Set defaults if parsing fails for critical fields
                  cameraPrefixInput.value = 'VDO';
                  reactionSubPrefixInput.value = 'Screen';
                  highlightSubPrefixInput.value = 'Highlight';
                  updatePrefixLabels();
                  vdoNinjaBaseUrlInput.value = 'https://vdo.ninja';
                  sourceSizingSelect.value = 'defaultSize';

              }
          } else {
              // Default values if no settings are found
              cameraPrefixInput.value = 'VDO';
              reactionSubPrefixInput.value = 'Screen';
              highlightSubPrefixInput.value = 'Highlight';
              updatePrefixLabels();
              vdoNinjaBaseUrlInput.value = 'https://vdo.ninja';
              sourceSizingSelect.value = 'defaultSize';
              logMessage("No saved settings found, using defaults for some fields.");
          }
          setupStreamMappingUI(); // This will also call loadStreamMappings
      }


      function updateOtherScenesList() {
          const mainSceneName = obsSceneSelect.value;
          const otherScenesListDiv = document.getElementById('otherScenesList'); // Define it here or ensure it's global
          const container = document.getElementById('otherScenesContainer');

          otherScenesListDiv.innerHTML = ''; // Clear previous list

          if (mainSceneName && obsScenes && obsScenes.length > 1) {
              container.style.display = 'block';
              obsScenes.forEach(scene => {
                  if (scene.sceneName !== mainSceneName) {
                      const checkboxId = `otherScene_${scene.sceneName.replace(/\s+/g, '_')}`;
                      const listItem = document.createElement('div');
                      listItem.className = 'checkbox-label';

                      const checkbox = document.createElement('input');
                      checkbox.type = 'checkbox';
                      checkbox.id = checkboxId;
                      checkbox.value = scene.sceneName;
                      checkbox.className = 'other-scene-checkbox';
                      // Check against loaded settings
                      if (loadedSelectedOtherScenes.includes(scene.sceneName)) {
                          checkbox.checked = true;
                      }
                      checkbox.addEventListener('change', saveSettings); // Save when checkbox state changes


                      const label = document.createElement('label');
                      label.htmlFor = checkboxId;
                      label.textContent = scene.sceneName;

                      listItem.appendChild(checkbox);
                      listItem.appendChild(label);
                      otherScenesListDiv.appendChild(listItem); // Append to the specific div
                  }
              });
          } else {
              container.style.display = 'none';
          }
      }


      function updateStreamList() {
          const container = document.querySelector('.container:nth-child(5)'); // Active Streams container index
          if (!Object.keys(activeStreams).length) {
              streamListContainer.innerHTML = '<div class="stream-item">No active streams</div>';
              return;
          }
          streamListContainer.innerHTML = '';

          for (const streamId in activeStreams) {
              if (Object.hasOwnProperty.call(activeStreams, streamId)) {
                  const stream = activeStreams[streamId];
                  const streamDiv = document.createElement('div');
                  streamDiv.className = 'stream-item';
                  const targetInfo = getTargetSceneForStream(streamId, stream.label);
                  const targetSceneName = targetInfo.scene;
                  const isDefaultScene = targetSceneName === getTargetScene();
                  const isHighlighted = highlightedStreamId === streamId;
                  const isCurrentlyScreenSharingThisStream = screenShareId === streamId;

                  let streamItemHTML = `
                      <div style="font-weight: bold;">${stream.label || streamId}</div>
                      <small>ID: ${streamId}${stream.label ? ` | Label: ${stream.label}` : ''}</small>
                      <small style="display: block; color: #8a8a9a;">
                          → Target Scene: ${targetSceneName || 'Not Set'} ${isDefaultScene && targetSceneName ? '(default)' : targetSceneName ? '(mapped)' : ''}
                      </small>
                      ${stream.sourceCreated ? '<span style="color:#4CAF50"> ✓ Added to OBS</span>' : ''}
                      <div style="margin-top: 5px;">
                          <button class="add-stream-btn" data-stream-id="${streamId}"
                              style="background-color: ${stream.sourceCreated ? '#F44336' : '#4C80AF'}; margin-right: 5px;">
                                  ${stream.sourceCreated ? 'Remove from Obs' : 'Add to OBS'}
                          </button>`;
                  if (stream.sourceCreated) {
                      streamItemHTML += `
                          <button class="highlight-btn" data-stream-id="${streamId}"
                              style="background-color: ${isHighlighted ? '#F44336' : '#4CAF50'};">
                                  ${isHighlighted ? 'Unhighlight' : 'Highlight'}
                          </button>`;
                  }
                  if (stream.sourceCreated) {
                       streamItemHTML += `
                          <button class="screen-share-btn" data-stream-id="${streamId}"
                                  style="background-color: ${isCurrentlyScreenSharingThisStream ? '#F44336' : '#9C27B0'}; margin-left: 5px;">
                              ${isCurrentlyScreenSharingThisStream ? 'Stop stream' : 'Stream'}
                          </button>`;
                  }
                  streamItemHTML += `</div>`;
                  streamDiv.innerHTML = streamItemHTML;
                  streamListContainer.appendChild(streamDiv);

                  const addRemoveBtn = streamDiv.querySelector('.add-stream-btn');
                  if (addRemoveBtn) {
                      addRemoveBtn.addEventListener('click', () => {
                          if (stream.sourceCreated) removeStreamFromObs(streamId);
                          else addStreamToObs(streamId, stream.label, targetInfo);
                      });
                  }
                  const highlightBtn = streamDiv.querySelector('.highlight-btn');
                  if (highlightBtn) {
                      highlightBtn.addEventListener('click', () => toggleHighlight(streamId, stream.label, targetInfo));
                  }
                  const screenShareBtn = streamDiv.querySelector('.screen-share-btn');
                  if (screenShareBtn) {
                      screenShareBtn.addEventListener('click', async () => {
                          const clickedStreamIdForScreenShare = streamId;
                          const currentActiveScreenShareGlobal = screenShareId;
                          if (currentActiveScreenShareGlobal === clickedStreamIdForScreenShare) {
                              await removeScreenShareFromObs(clickedStreamIdForScreenShare);
                          } else {
                              await addScreenShareToObs(clickedStreamIdForScreenShare, stream.label);
                          }
                      });
                  }
              }
          }
      }

      async function addScreenShareToObs(streamId, streamLabel) {
          const previousGlobalScreenShareId = screenShareId;
          screenShareId = streamId;

          if (!obsConnected || !obs) {
              logMessage("Cannot add screen share: Not connected to OBS.");
              screenShareId = previousGlobalScreenShareId; updateStreamList(); return;
          }
          const room = vdoNinjaRoomInput.value.trim();
          if (!room) {
              logMessage("Cannot add screen share: Room name is required.");
              screenShareId = previousGlobalScreenShareId; updateStreamList(); return;
          }

          const width = parseInt(document.getElementById('screenShareWidth').value) || 1280;
          const height = parseInt(document.getElementById('screenShareHeight').value) || 720;
          const screenShareSceneSelect = document.getElementById('screenShareSceneSelect');
          let targetSceneName = screenShareSceneSelect.value || getTargetScene();

          if (!targetSceneName) {
              logMessage("Cannot add screen share: Target scene is required.");
              screenShareId = previousGlobalScreenShareId; updateStreamList(); return;
          }

          const sourceName = `${getFullReactionPrefix()}_${streamId}:s`;
          const baseUrl = getVdoNinjaBaseUrl();
          let screenShareUrl = `${baseUrl}/?view=${encodeURIComponent(streamId)}:s&solo&room=${encodeURIComponent(room)}&codec=h264`;
          if (vdoNinjaPasswordInput.value) screenShareUrl += `&password=${encodeURIComponent(vdoNinjaPasswordInput.value)}`;

          const inputSettings = { url: screenShareUrl, width: width, height: height, fps: 30, reroute_audio: true, restart_when_active: false, shutdown: false };
          logMessage(`Adding/Updating screen share source '${sourceName}' to scene '${targetSceneName}'`);

          try {
              const sources = await sendRequest('GetInputList');
              const existingScreenSource = sources.inputs.find(input =>
                  input.inputName.startsWith(getFullReactionPrefix() + '_') && input.inputName.endsWith(':s') &&
                  input.inputName !== sourceName &&
                  input.inputKind === 'browser_source'
              );

              if (existingScreenSource) {
                  logMessage(`Found existing screen share source: '${existingScreenSource.inputName}'. Reconfiguring and renaming.`);
                  await sendRequest('SetInputSettings', { inputName: existingScreenSource.inputName, inputSettings });
                  if (existingScreenSource.inputName !== sourceName) {
                      await sendRequest('SetInputName', { inputName: existingScreenSource.inputName, newInputName: sourceName });
                  }
              } else {
                  const exactSourceExists = sources.inputs.find(input => input.inputName === sourceName && input.inputKind === 'browser_source');
                  if (exactSourceExists) {
                       await sendRequest('SetInputSettings', { inputName: sourceName, inputSettings });
                  } else {
                      await sendRequest('CreateInput', { sceneName: targetSceneName, inputName: sourceName, inputKind: 'browser_source', inputSettings, sceneItemEnabled: true });
                  }
              }

              let sceneItemId;
              try {
                  const itemInfo = await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName });
                  sceneItemId = itemInfo.sceneItemId;
                  await sendRequest('SetSceneItemEnabled', { sceneName: targetSceneName, sceneItemId: sceneItemId, sceneItemEnabled: true });
              } catch (e) {
                  if (e.message.toLowerCase().includes("not found")) {
                      const createItemResponse = await sendRequest('CreateSceneItem', { sceneName: targetSceneName, sourceName: sourceName });
                      sceneItemId = createItemResponse.sceneItemId;
                  } else { throw e; }
              }

              if (sceneItemId) {
                  const transform = calculateTransform('defaultSize', width, height, width, height);
                  await sendRequest('SetSceneItemTransform', { sceneName: targetSceneName, sceneItemId: sceneItemId, sceneItemTransform: transform });
              }
              logMessage(`Successfully configured screen share for ${streamId}.`);
          } catch (error) {
              logMessage(`Error adding/updating screen share source '${sourceName}': ${error.message}.`);
              screenShareId = previousGlobalScreenShareId;
          } finally {
              updateStreamList();
          }
      }

      async function toggleHighlight(clickedStreamId, clickedStreamLabel, clickedTargetInfo) {
          if (!obsConnected || !obs) { logMessage("Cannot toggle highlight: Not connected to OBS."); return; }

          const previouslyGlobalHighlightedStreamId = highlightedStreamId;
          const camPrefix = getFullCameraPrefix();
          const hlPrefix = getFullHighlightPrefix();

          if (previouslyGlobalHighlightedStreamId && previouslyGlobalHighlightedStreamId !== clickedStreamId) {
              const oldStreamDetails = Object.values(activeStreams).find(s => s.streamId === previouslyGlobalHighlightedStreamId);
              const oldStreamLabel = oldStreamDetails ? oldStreamDetails.label : '';
              const oldTargetInfo = getTargetSceneForStream(previouslyGlobalHighlightedStreamId, oldStreamLabel);
              const oldHighlightedSourceName = `${hlPrefix}_${previouslyGlobalHighlightedStreamId}`;
              const oldOriginalSourceName = `${camPrefix}_${previouslyGlobalHighlightedStreamId}`;
              try {
                  await sendRequest('GetInputSettings', { inputName: oldHighlightedSourceName });
                  await sendRequest('SetInputName', { inputName: oldHighlightedSourceName, newInputName: oldOriginalSourceName });
                  if (sourceSizingSelect.value === 'autoGrid') {
                      await rearrangeAllStreamsInScene(oldTargetInfo.scene);
                      if (oldTargetInfo.mapping?.cloneToMain && getTargetScene() !== oldTargetInfo.scene) {
                          await rearrangeAllStreamsInScene(getTargetScene());
                      }
                  }
              } catch (error) { /* Silent or log if not "not found" */ }
          }

          const clickedOriginalSourceName = `${camPrefix}_${clickedStreamId}`;
          const clickedNewHighlightedSourceName = `${hlPrefix}_${clickedStreamId}`;

          if (previouslyGlobalHighlightedStreamId === clickedStreamId) { // Unhighlight
              try {
                  await sendRequest('GetInputSettings', { inputName: clickedNewHighlightedSourceName });
                  await sendRequest('SetInputName', { inputName: clickedNewHighlightedSourceName, newInputName: clickedOriginalSourceName });
                  highlightedStreamId = null;
                  if (sourceSizingSelect.value === 'autoGrid') {
                      await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
                      if (clickedTargetInfo.mapping?.cloneToMain && getTargetScene() !== clickedTargetInfo.scene) {
                          await rearrangeAllStreamsInScene(getTargetScene());
                      }
                  }
              } catch (error) { highlightedStreamId = null; }
          } else { // Highlight
              try {
                  await sendRequest('GetInputSettings', { inputName: clickedOriginalSourceName });
                  await sendRequest('SetInputName', { inputName: clickedOriginalSourceName, newInputName: clickedNewHighlightedSourceName });
                  highlightedStreamId = clickedStreamId;
                   if (sourceSizingSelect.value === 'autoGrid') {
                       await rearrangeAllStreamsInScene(clickedTargetInfo.scene);
                       if (clickedTargetInfo.mapping?.cloneToMain && getTargetScene() !== clickedTargetInfo.scene) {
                          await rearrangeAllStreamsInScene(getTargetScene());
                       }
                   }
              } catch (error) {
                  try { // Check if already highlighted
                      await sendRequest('GetInputSettings', { inputName: clickedNewHighlightedSourceName });
                      highlightedStreamId = clickedStreamId;
                  } catch (e2) { if (highlightedStreamId === clickedStreamId) highlightedStreamId = null;}
              }
          }
          updateStreamList();
      }


      obsConnectBtn.addEventListener('click', () => {
          if (obsConnected && obs) {
              logMessage("Disconnecting from OBS WebSocket...");
              if (obs) { obs.close(); obs = null; }
          } else {
              connectToOBS();
          }
      });

      function getTargetSceneForStream(streamId, streamLabel = '') {
          const mappings = getStreamMappings();
          const defaultTargetScene = getTargetScene();
          for (const mapping of mappings) {
              let isMatch = false;
              switch (mapping.matchType) {
                  case 'streamId': isMatch = mapping.streamId && streamId === mapping.streamId; break;
                  case 'label':    isMatch = mapping.label && streamLabel && streamLabel === mapping.label; break;
                  case 'both':     isMatch = mapping.streamId && mapping.label && streamId === mapping.streamId && streamLabel === mapping.label; break;
                  case 'either':   isMatch = (mapping.streamId && streamId === mapping.streamId) || (mapping.label && streamLabel && streamLabel === mapping.label); break;
              }
              if (isMatch && mapping.sceneName) {
                  return { scene: mapping.sceneName, mapping: mapping };
              }
          }
          return { scene: defaultTargetScene, mapping: null };
      }

      function updateSceneDropdowns() {
          const currentMainValue = obsSceneSelect.value;
          const currentScreenShareValue = document.getElementById('screenShareSceneSelect').value;
          const mappingSelects = document.querySelectorAll('.mapping-scene-name');
          const currentMappingValues = Array.from(mappingSelects).map(select => select.value);

          populateSceneDropdown(obsScenes, obsSceneSelect);
          populateSceneDropdown(obsScenes, document.getElementById('screenShareSceneSelect'));
          
          if (currentMainValue && obsScenes.some(scene => scene.sceneName === currentMainValue)) {
              obsSceneSelect.value = currentMainValue;
          }
          if (currentScreenShareValue && (currentScreenShareValue === "" || obsScenes.some(scene => scene.sceneName === currentScreenShareValue))) {
              document.getElementById('screenShareSceneSelect').value = currentScreenShareValue;
          }


          mappingSelects.forEach((select, index) => {
              populateSceneDropdown(obsScenes, select);
              if (currentMappingValues[index] && obsScenes.some(scene => scene.sceneName === currentMappingValues[index])) {
                  select.value = currentMappingValues[index];
              }
          });
      }

      function loadStreamMappings() {
          const settingsJson = localStorage.getItem('obsNinjaStreamMappings');
          if (settingsJson) {
              try {
                  const mappings = JSON.parse(settingsJson);
                  mappings.forEach(mapping => {
                      addNewStreamMapping(
                          mapping.streamId, mapping.label, mapping.sceneName, mapping.matchType,
                          mapping.cloneToMain !== undefined ? mapping.cloneToMain : true,
                          mapping.switchToScene !== undefined ? mapping.switchToScene : false
                      );
                  });
                  if (obsScenes && obsScenes.length > 0) updateSceneDropdowns(); // Refresh dropdowns if scenes already loaded
              } catch (e) { logMessage(`Error loading stream mappings: ${e.message}`); }
          }
      }

      function getStreamMappings() {
          const mappings = [];
          document.querySelectorAll('.stream-mapping').forEach(div => {
              const streamId = div.querySelector('.mapping-stream-id').value.trim();
              const label = div.querySelector('.mapping-label').value.trim();
              const matchType = div.querySelector('.mapping-match-type').value;
              const sceneName = div.querySelector('.mapping-scene-name').value.trim();
              const cloneToMain = div.querySelector('.mapping-clone-to-main').checked;
              const switchToScene = div.querySelector('.mapping-switch-to-scene').checked;
              if (sceneName && (streamId || label)) {
                  mappings.push({ streamId, label, matchType, sceneName, cloneToMain, switchToScene });
              }
          });
          return mappings;
      }

      async function connectToOBS() {
          if (cameraPrefixInput.value.trim() === '' || reactionSubPrefixInput.value.trim() === '' || highlightSubPrefixInput.value.trim() === '') {
              logMessage("Error: Camera, Reaction, and Highlight prefixes are required.");
              obsStatusIndicator.classList.add('error');
              obsConnectionStatus.textContent = 'Status: Error - Prefixes missing';
              return;
          }

          let url = obsWsUrlInput.value.trim();
          const password = obsWsPasswordInput.value;
          if (!url) { logMessage("Error: OBS WebSocket URL is required."); return; }
          if (!url.startsWith('ws://') && !url.startsWith('wss://')) { url = 'ws://' + url; obsWsUrlInput.value = url; }
          
          obsConnectionStatus.textContent = 'Status: Connecting...';
          obsStatusIndicator.classList.remove('connected', 'error');
          logMessage(`Attempting to connect to OBS at ${url}...`);

          const connectionTimeoutId = setTimeout(() => {
              if (obs && obs.readyState !== WebSocket.OPEN) {
                  logMessage("Connection attempt timed out");
                  if (obs) { try { obs.close(); } catch (e) {} obs = null; }
                  obsConnectionStatus.textContent = 'Status: Error - Connection timed out';
                  obsStatusIndicator.classList.add('error');
              }
          }, 10000);

          try {
              obs = new WebSocket(url);
              obs.onopen = () => logMessage("WebSocket connection opened. Waiting for Hello...");
              obs.onmessage = async (event) => {
                  try {
                      const message = JSON.parse(event.data);
                      if (message.op === 0) { // Hello
                          logMessage("Received Hello from OBS");
                          const identifyPayload = { op: 1, d: { rpcVersion: 1, eventSubscriptions: (1 << 0) | (1 << 1) } };
                          if (message.d && message.d.authentication) {
                              const { challenge, salt } = message.d.authentication;
                              if (password) identifyPayload.d.authentication = await generateAuthResponse(password, salt, challenge);
                              else logMessage("Warning: Server requires auth, no password provided");
                          }
                          obs.send(JSON.stringify(identifyPayload));
                      } else if (message.op === 2) { // Identified
                          clearTimeout(connectionTimeoutId);
                          logMessage("OBS Authentication successful!");
                          obsConnected = true;
                          obsConnectBtn.textContent = 'Disconnect';
                          obsConnectBtn.classList.add('connected'); obsConnectBtn.classList.remove('disconnected');
                          obsConnectionStatus.textContent = 'Status: Connected';
                          obsStatusIndicator.classList.add('connected');
                          onObsConnected();
                      } else if (message.op === 7) { // RequestResponse
                          if (message.d && message.d.requestId && requestCallbacks[message.d.requestId]) {
                              requestCallbacks[message.d.requestId](message.d);
                              delete requestCallbacks[message.d.requestId];
                          }
                          if (message.d && message.d.requestStatus && message.d.requestStatus.code !== 100) {
                              logMessage(`OBS Request Error (${message.d.requestType || 'Unknown'}): ${message.d.requestStatus.comment || 'Unknown error'}`);
                          }
                      } else if (message.op === 5) { /* Event, log if needed */ }
                  } catch (error) { logMessage(`Error processing WebSocket message: ${error.message}`); }
              };
              obs.onerror = (error) => {
                  clearTimeout(connectionTimeoutId);
                  logMessage(`OBS WebSocket Error: ${error.message || 'Unknown'}`);
                  obsStatusIndicator.classList.add('error');
                  obsConnectionStatus.textContent = 'Status: Error';
              };
              obs.onclose = (event) => {
                  clearTimeout(connectionTimeoutId);
                  let reason = event.code === 4009 ? 'Authentication Failed' : `Code: ${event.code || 'Unknown'}`;
                  logMessage(`OBS WebSocket Connection Closed. ${reason}`);
                  obsConnected = false;
                  obsConnectBtn.textContent = 'Connect to OBS';
                  obsConnectBtn.classList.remove('connected'); obsConnectBtn.classList.add('disconnected');
                  obsConnectionStatus.textContent = 'Status: Disconnected';
                  obsStatusIndicator.classList.remove('connected', 'error');
                  onObsDisconnected();
              };
          } catch (error) {
              clearTimeout(connectionTimeoutId);
              logMessage(`Error creating WebSocket: ${error.message}`);
              obsConnectionStatus.textContent = 'Status: Error';
              obsStatusIndicator.classList.add('error');
          }
      }

      async function generateAuthResponse(password, salt, challenge) {
          const encoder = new TextEncoder();
          const secretString = password + salt;
          const secretData = encoder.encode(secretString);
          let secretHash;
          if (window.crypto && window.crypto.subtle) {
              secretHash = new Uint8Array(await window.crypto.subtle.digest('SHA-256', secretData));
          } else {
              await loadJsShaLibrary();
              const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
              shaObj.update(secretString);
              secretHash = new Uint8Array(shaObj.getHash("HEX").match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
          }
          const secretBase64 = btoa(String.fromCharCode.apply(null, secretHash));
          const authString = secretBase64 + challenge;
          const authData = encoder.encode(authString);
          let authHash;
          if (window.crypto && window.crypto.subtle) {
              authHash = new Uint8Array(await window.crypto.subtle.digest('SHA-256', authData));
          } else {
              const shaObj = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
              shaObj.update(authString);
              authHash = new Uint8Array(shaObj.getHash("HEX").match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
          }
          return btoa(String.fromCharCode.apply(null, authHash));
      }

      function sendRequest(requestType, requestData = {}) {
      	return new Promise((resolve, reject) => {
      		if (!obsConnected || !obs) { reject(new Error("Not connected to OBS")); return; }
      		const requestId = generateRequestId(requestType);
      		requestCallbacks[requestId] = (response) => {
      			if (response.requestStatus.code === 100) resolve(response.responseData || {});
      			else reject(new Error(`Request ${requestType} failed: ${response.requestStatus.comment}`));
      		};
      		try { obs.send(JSON.stringify({ op: 6, d: { requestType, requestId, requestData } })); }
            catch (error) { delete requestCallbacks[requestId]; reject(error); }
      		setTimeout(() => {
      			if (requestCallbacks[requestId]) {
      				delete requestCallbacks[requestId];
      				reject(new Error(`Request timeout for ${requestType}`));
      			}
      		}, 5000);
      	});
      }

      function onObsConnected() {
          logMessage("OBS Connected. Fetching scenes...");
          fetchObsScenes().then(() => {
              const settingsJson = localStorage.getItem('obsNinjaSettings');
              if (settingsJson) {
                  try {
                      const settings = JSON.parse(settingsJson);
                      if (settings.vdoNinjaConnected && (settings.vdoNinjaRoom || settings.vdoNinjaStreamIds)) {
                          // This logic was for auto-reconnect, but vdoNinjaConnected is not saved anymore to start fresh.
                          // If desired, this could be re-enabled, but ensure updateVdoNinjaButtonState is called.
                      }
                  } catch (e) { /* ignore */ }
              }
              if (sourceSizingSelect.value === 'autoGrid') {
                  setTimeout(() => rearrangeAllStreamsInScene(getTargetScene()), 1000);
              }
          });
      }

      function onObsDisconnected() {
          logMessage("OBS Disconnected.");
          Object.values(activeStreams).forEach(s => s.sourceCreated = false);
          updateStreamList();
      }

      async function fetchObsScenes() {
          if (!obsConnected || !obs) return;
          logMessage("Fetching OBS scenes...");
          try {
              const response = await sendRequest('GetSceneList');
              if (response && response.scenes) {
                  obsScenes = response.scenes; 
                  updateSceneDropdowns(); // This populates dropdowns

                  // Restore selections AFTER dropdowns are populated
                  const savedSettingsJson = localStorage.getItem('obsNinjaSettings');
                  if (savedSettingsJson) {
                      const savedSettings = JSON.parse(savedSettingsJson);
                      if (savedSettings.obsSceneName && obsScenes.some(s => s.sceneName === savedSettings.obsSceneName)) {
                          obsSceneSelect.value = savedSettings.obsSceneName;
                      }
                      const screenShareSelectElement = document.getElementById('screenShareSceneSelect');
                      if (screenShareSelectElement && (savedSettings.screenShareScene === "" || obsScenes.some(s => s.sceneName === savedSettings.screenShareScene))) {
                          screenShareSelectElement.value = savedSettings.screenShareScene;
                      }
                  }
                  
                  updateOtherScenesList(); // This uses loadedSelectedOtherScenes which is set in loadSettings

                  // Restore mapping scene selections
                  const savedMappingsJson = localStorage.getItem('obsNinjaStreamMappings');
                   if (savedMappingsJson) {
                      const mappings = JSON.parse(savedMappingsJson);
                      document.querySelectorAll('.mapping-scene-name').forEach((select, index) => {
                          if (mappings[index] && mappings[index].sceneName && obsScenes.some(scene => scene.sceneName === mappings[index].sceneName)) {
                              select.value = mappings[index].sceneName;
                          }
                      });
                  }
              }
          } catch (error) { logMessage(`Error fetching OBS scenes: ${error.message}`); }
      }

      function populateSceneDropdown(scenesData, selectElement) {
          const currentValue = selectElement.value; // Preserve current selection if valid
          selectElement.innerHTML = selectElement.id === 'screenShareSceneSelect' ?
              '<option value="">Same as main</option>' :
              '<option value="">Select a scene...</option>';
          if (!scenesData || !scenesData.length) return;

          scenesData.forEach(scene => { // Add scenes, usually you'd want them sorted or grouped
              const option = document.createElement('option');
              option.value = scene.sceneName;
              option.textContent = scene.sceneName;
              selectElement.appendChild(option); // Appending keeps order, prepending reverses it
          });

          // Try to restore previous valid selection
          if (currentValue && Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
              selectElement.value = currentValue;
          } else if (selectElement.options.length > 1 && selectElement.id !== 'screenShareSceneSelect' && selectElement.id !== 'obsSceneSelect') {
              // For mapping dropdowns, if previous was invalid, don't auto-select first scene. Keep "Select a scene..."
          } else if (selectElement.id === 'obsSceneSelect' && selectElement.options.length > 1) {
             // For main obsSceneSelect, if no valid previous, don't auto-select.
          }
      }


      function getTargetScene() { return obsSceneSelect.value || ''; }

      function getVdoNinjaViewUrl(streamId, includeCommonParams = true) {
          const room = vdoNinjaRoomInput.value.trim();
          const ninjaPassword = vdoNinjaPasswordInput.value;
          const baseUrl = getVdoNinjaBaseUrl();
          let url = `${baseUrl}/?`;
          if (room) url += `view=${encodeURIComponent(streamId)}&solo&room=${encodeURIComponent(room)}`;
          else url += `view=${encodeURIComponent(streamId)}`;
          if (ninjaPassword) url += `&password=${encodeURIComponent(ninjaPassword)}`;
          if (includeCommonParams) url += "&cleanoutput&proaudio&ab=160&transparent&autoplay&codec=h264"; // Add other params as needed
          return url;
      }

      function initializeVdoNinjaIframe() {
          const room = vdoNinjaRoomInput.value.trim();
          const streamIds = vdoNinjaStreamIdsInput.value.trim();
          if (!room && !streamIds) { logMessage("VDO.Ninja: Room or Stream ID(s) needed."); return; }
          
          const baseUrl = getVdoNinjaBaseUrl();
          let vdoNinjaUrl = `${baseUrl}/?`;

          if (room) {
              vdoNinjaUrl += `room=${encodeURIComponent(room)}`;
              if (streamIds) vdoNinjaUrl += `&view=${encodeURIComponent(streamIds.split(',').map(s => s.trim()).join(','))}&solo`;
          } else if (streamIds) {
              vdoNinjaUrl += `view=${encodeURIComponent(streamIds.split(',').map(s => s.trim()).join(','))}`;
          }
          if (vdoNinjaPasswordInput.value) vdoNinjaUrl += `&password=${encodeURIComponent(vdoNinjaPasswordInput.value)}`;
          vdoNinjaUrl += "&cleanoutput&dataonly&nocursor&nopush&debug&noaudio&novideo&cors="+encodeURIComponent(window.location.origin);
          
          logMessage(`Loading VDO.Ninja iframe: ${vdoNinjaUrl}`);
          vdoNinjaIframe.src = 'about:blank'; // Clear previous content
          vdoNinjaIframe.setAttribute('crossorigin', 'anonymous'); // Ensure this is appropriate
          // Consider if 'allow' attribute needs to be dynamically set based on base URL if not default
          setTimeout(() => { vdoNinjaIframe.src = vdoNinjaUrl; }, 10);
          // saveSettings(); // Settings are saved on input change or connect button explicitly
      }


      window.addEventListener("message", (event) => {
          const expectedOriginBase = getVdoNinjaBaseUrl(); // Get current base URL
          // Ensure event.origin matches the scheme and host/port of expectedOriginBase
          let parsedExpectedOrigin;
          try { parsedExpectedOrigin = new URL(expectedOriginBase); } catch (e) { return; } // Invalid base URL

          if (event.origin !== parsedExpectedOrigin.origin || event.source !== vdoNinjaIframe.contentWindow) return;
          
          const data = event.data;
          vdoNinjaLastActivityTime = Date.now();
          if (!vdoNinjaConnected) { // First message after initiating connection
              vdoNinjaConnected = true;
              updateVdoNinjaButtonState(vdoNinjaConnected); // This enables inputs again
              if (vdoNinjaConnectionCheckTimer) { clearTimeout(vdoNinjaConnectionCheckTimer); vdoNinjaConnectionCheckTimer = null; }
              logMessage("VDO.Ninja connection established.");
          }

          if (data && data.streamID) {
              const streamId = data.streamID;
              const label = data.label || `Stream ${streamId}`; // Use a default if label is missing
              if ((data.action === "view-connection" && data.value === true) || (data.action === "guest-connected") || (data.action === "push-connection" && data.value === true)) {
                  logMessage(`VDO.Ninja stream connected: ${label} (ID: ${streamId})`);
                  activeStreams[streamId] = { label, sourceCreated: false, streamId, uuid: data.UUID || null, connected: true };
                  updateStreamList();
                  if (autoAddSourcesCheckbox.checked) {
                      const targetInfo = getTargetSceneForStream(streamId, label);
                      addStreamToObs(streamId, label, targetInfo);
                  }
              } else if ((data.action === "view-connection" && data.value === false) || (data.action === "push-connection" && data.value === false)) {
                  if (activeStreams[streamId]) {
                      logMessage(`VDO.Ninja stream disconnected: ${label} (ID: ${streamId})`);
                      if (autoRemoveSourcesCheckbox && autoRemoveSourcesCheckbox.checked) {
                          removeStreamFromObs(streamId);
                      }
                      delete activeStreams[streamId];
                      updateStreamList();
                  }
              } else if (data.action === "view-connection-info" && data.value && data.value.label) {
                  if (activeStreams[streamId]) {
                      activeStreams[streamId].label = data.value.label;
                      updateStreamList();
                  }
              }
          }
      }, false);

      function startVdoNinjaConnectionMonitor() {
          setInterval(() => {
              if (vdoNinjaConnected && Date.now() - vdoNinjaLastActivityTime > 45000) { // 45 seconds
                  logMessage("VDO.Ninja connection lost (no activity).");
                  vdoNinjaConnectionStatus.textContent = 'Status: Connection Lost';
                  vdoNinjaStatusIndicator.classList.remove('connected');
                  // vdoNinjaConnectBtn.textContent = 'Reconnect'; // Keep disconnect text
                  disconnectFromVdoNinja(); // This will set button to "Connect" and update state
              }
          }, 30000); // Check every 30 seconds
      }


      async function addStreamToObs(streamId, streamLabel, targetInfo = null) {
          if (!obsConnected || !obs) { logMessage("Cannot add stream: Not connected to OBS."); return; }

          const resolvedTargetInfo = targetInfo || getTargetSceneForStream(streamId, streamLabel);
          const targetSceneName = resolvedTargetInfo.scene;
          const mappingRule = resolvedTargetInfo.mapping;

          if (!targetSceneName) { logMessage("Cannot add stream: Target OBS scene name is required."); return; }

          const sourceName = `${getFullCameraPrefix()}_${streamId}`;
          const mainDefaultScene = getTargetScene();
          let shouldCloneThisStreamToMain = (mappingRule && mappingRule.sceneName !== mainDefaultScene && mappingRule.cloneToMain);
          let shouldSwitchToThisScene = (mappingRule && mappingRule.switchToScene);

          const vdoNinjaStreamUrl = getVdoNinjaViewUrl(streamId);
          let canvasWidth = 1920, canvasHeight = 1080;
          try {
              const videoSettings = await sendRequest('GetVideoSettings');
              if (videoSettings && videoSettings.baseWidth && videoSettings.baseHeight) {
                  canvasWidth = videoSettings.baseWidth; canvasHeight = videoSettings.baseHeight;
              }
          } catch (error) { logMessage(`Canvas size error: ${error.message}, using default.`); }

          const inputSettings = { url: vdoNinjaStreamUrl, width: canvasWidth, height: canvasHeight, fps: 30, reroute_audio: true, restart_when_active: false, shutdown: false };
          logMessage(`Adding source '${sourceName}' to scene '${targetSceneName}'. Cloning: ${shouldCloneThisStreamToMain}. Switching: ${shouldSwitchToThisScene}`);

          try {
              let sourceExistsGlobally = false; let initialSceneItemId = null; let clonedSceneItemId = null;
              try { sourceExistsGlobally = (await sendRequest('GetInputList')).inputs.some(input => input.inputName === sourceName); } catch (e) {/*ignore*/}

              if (!sourceExistsGlobally) {
                  await sendRequest('CreateInput', { sceneName: targetSceneName, inputName: sourceName, inputKind: 'browser_source', inputSettings, sceneItemEnabled: true });
                  try { initialSceneItemId = (await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName })).sceneItemId; } catch (e) {/*ignore*/}
                  if (shouldCloneThisStreamToMain && mainDefaultScene && mainDefaultScene !== targetSceneName) {
                      try { clonedSceneItemId = (await sendRequest('CreateSceneItem', { sceneName: mainDefaultScene, sourceName: sourceName })).sceneItemId; } catch (e) {/*ignore*/}
                  }
              } else {
                  await sendRequest('SetInputSettings', { inputName: sourceName, inputSettings });
                  try { initialSceneItemId = (await sendRequest('GetSceneItemId', { sceneName: targetSceneName, sourceName: sourceName })).sceneItemId; } 
                  catch (e) { if (e.message.toLowerCase().includes("not found")) initialSceneItemId = (await sendRequest('CreateSceneItem', { sceneName: targetSceneName, sourceName: sourceName })).sceneItemId; else throw e; }
                  if (shouldCloneThisStreamToMain && mainDefaultScene && mainDefaultScene !== targetSceneName) {
                      try { clonedSceneItemId = (await sendRequest('GetSceneItemId', { sceneName: mainDefaultScene, sourceName: sourceName })).sceneItemId; } 
                      catch (e) { if (e.message.toLowerCase().includes("not found")) clonedSceneItemId = (await sendRequest('CreateSceneItem', { sceneName: mainDefaultScene, sourceName: sourceName })).sceneItemId; }
                  }
              }

              if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = true;
              if (initialSceneItemId) await applyTransformAndGrid(targetSceneName, sourceName, canvasWidth, canvasHeight, initialSceneItemId);
              if (clonedSceneItemId) await applyTransformAndGrid(mainDefaultScene, sourceName, canvasWidth, canvasHeight, clonedSceneItemId);

              document.querySelectorAll('.other-scene-checkbox:checked').forEach(async checkbox => {
                  const otherSceneName = checkbox.value;
                  if (otherSceneName && otherSceneName !== targetSceneName && (!shouldCloneThisStreamToMain || otherSceneName !== mainDefaultScene)) {
                      try { 
                          let otherItemId = null;
                          try { otherItemId = (await sendRequest('GetSceneItemId', { sceneName: otherSceneName, sourceName: sourceName })).sceneItemId; } catch(e) {/* ok if not found */}
                          if (!otherItemId) {
                            otherItemId = (await sendRequest('CreateSceneItem', { sceneName: otherSceneName, sourceName: sourceName })).sceneItemId;
                            if (otherItemId) await applyTransformAndGrid(otherSceneName, sourceName, canvasWidth, canvasHeight, otherItemId);
                          }
                      } catch (e) { logMessage(`Error cloning to other scene '${otherSceneName}': ${e.message}`); }
                  }
              });

              if (shouldSwitchToThisScene) await sendRequest('SetCurrentProgramScene', { sceneName: targetSceneName });
          } catch (error) {
              logMessage(`Error adding stream '${sourceName}' to OBS: ${error.message}`);
              if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = false;
          } finally { updateStreamList(); }
      }

      async function applyTransformAndGrid(sceneName, sourceName, canvasWidth, canvasHeight, sceneItemId = null) {
          if (!sceneName) return;
          let itemIdToTransform = sceneItemId;
          if (!itemIdToTransform) {
              try { itemIdToTransform = (await sendRequest('GetSceneItemId', { sceneName, sourceName })).sceneItemId; } 
              catch (error) { logMessage(`Error fetching item ID for transform ('${sourceName}' in '${sceneName}'): ${error.message}`); return; }
          }
          if (!itemIdToTransform) return;

          if (sourceSizingSelect.value === 'autoGrid') {
              await rearrangeAllStreamsInScene(sceneName);
          } else {
              try {
                  const transform = calculateTransform(sourceSizingSelect.value, canvasWidth, canvasHeight, canvasWidth, canvasHeight);
                  await sendRequest('SetSceneItemTransform', { sceneName, sceneItemId: itemIdToTransform, sceneItemTransform: transform });
              } catch (error) { logMessage(`Error applying non-grid transform to '${sourceName}': ${error.message}`); }
          }
      }

      async function rearrangeAllStreamsInScene(sceneName) {
          if (!obsConnected || !obs || !sceneName || sourceSizingSelect.value !== 'autoGrid') return;
          logMessage(`Rearranging streams in scene '${sceneName}' using autoGrid.`);
          try {
              let canvasWidth = 1920, canvasHeight = 1080;
              try {
                  const videoSettings = await sendRequest('GetVideoSettings');
                  if (videoSettings && videoSettings.baseWidth && videoSettings.baseHeight) {
                      canvasWidth = videoSettings.baseWidth; canvasHeight = videoSettings.baseHeight;
                  }
              } catch (error) { /* use default */ }

              const sceneItemsResponse = await sendRequest('GetSceneItemList', { sceneName });
              const camPrefix = getFullCameraPrefix() + "_"; // Add underscore for precise startswith
              const vdoNinjaSourcesInScene = sceneItemsResponse.sceneItems.filter(item =>
                  item.sourceName.startsWith(camPrefix) &&
                  Object.values(activeStreams).some(as => `${camPrefix}${as.streamId}` === item.sourceName && as.connected)
              );

              if (!vdoNinjaSourcesInScene.length) return;
              const positions = calculateGridPositions(vdoNinjaSourcesInScene.length, canvasWidth, canvasHeight);
              for (let i = 0; i < vdoNinjaSourcesInScene.length; i++) {
                  const item = vdoNinjaSourcesInScene[i];
                  const transform = calculateTransform('autoGrid', canvasWidth, canvasHeight, canvasWidth, canvasHeight, positions[i]);
                  await sendRequest('SetSceneItemTransform', { sceneName, sceneItemId: item.sceneItemId, sceneItemTransform: transform });
              }
          } catch (error) { logMessage(`Error rearranging streams in '${sceneName}': ${error.message}`); }
      }


      function calculateTransform(sizingMode, sourceWidth, sourceHeight, canvasWidth, canvasHeight, gridPosition = null) {
          let transform = { alignment: 5, boundsType: "OBS_BOUNDS_NONE", boundsAlignment: 0, boundsWidth: sourceWidth, boundsHeight: sourceHeight, positionX: 0, positionY: 0, scaleX: 1.0, scaleY: 1.0, rotation: 0.0, cropTop: 0, cropBottom: 0, cropLeft: 0, cropRight: 0, sourceWidth, sourceHeight, width: sourceWidth, height: sourceHeight };
          switch (sizingMode) {
              case 'stretchToFill': transform.boundsType = "OBS_BOUNDS_STRETCH"; transform.boundsWidth = canvasWidth; transform.boundsHeight = canvasHeight; transform.width = canvasWidth; transform.height = canvasHeight; break;
              case 'bestFit':       transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; transform.boundsWidth = canvasWidth; transform.boundsHeight = canvasHeight; transform.width = canvasWidth; transform.height = canvasHeight; break;
              case 'autoGrid':
                  if (gridPosition) {
                      transform.boundsType = "OBS_BOUNDS_SCALE_INNER";
                      transform.positionX = gridPosition.x; transform.positionY = gridPosition.y;
                      transform.boundsWidth = gridPosition.width; transform.boundsHeight = gridPosition.height;
                      transform.width = gridPosition.width; transform.height = gridPosition.height;
                  } else { transform.boundsType = "OBS_BOUNDS_SCALE_INNER"; transform.boundsWidth = canvasWidth; transform.boundsHeight = canvasHeight; transform.width = canvasWidth; transform.height = canvasHeight; }
                  break;
              case 'defaultSize': default: transform.positionX = (canvasWidth - sourceWidth) / 2; transform.positionY = (canvasHeight - sourceHeight) / 2; break;
          }
          return transform;
      }

      async function removeStreamFromObs(streamId) {
          if (!obsConnected || !obs || !activeStreams[streamId]) return;

          const sourceNameBase = `${getFullCameraPrefix()}_${streamId}`;
          const highlightedSourceNameFull = `${getFullHighlightPrefix()}_${streamId}`;
          logMessage(`Removing stream '${streamId}' (sources: '${sourceNameBase}', '${highlightedSourceNameFull}')`);

          const streamInfo = activeStreams[streamId];
          const targetInfo = getTargetSceneForStream(streamId, streamInfo ? streamInfo.label : '');
          const scenesToClean = new Set();
          if (targetInfo && targetInfo.scene) scenesToClean.add(targetInfo.scene);
          if (getTargetScene()) scenesToClean.add(getTargetScene());
          document.querySelectorAll('.other-scene-checkbox:checked').forEach(cb => scenesToClean.add(cb.value));

          let itemRemoved = false;
          for (const sceneName of scenesToClean) {
              if (!sceneName) continue;
              let nameInScene = highlightedStreamId === streamId ? highlightedSourceNameFull : sourceNameBase;
              if (await tryRemoveFromScene(nameInScene, sceneName)) itemRemoved = true;
              else if (nameInScene === highlightedSourceNameFull && await tryRemoveFromScene(sourceNameBase, sceneName)) itemRemoved = true; // Fallback
          }

          if (highlightedStreamId === streamId) highlightedStreamId = null;
          if (screenShareId === streamId) await removeScreenShareFromObs(streamId); // This calls updateStreamList

          if (activeStreams[streamId]) activeStreams[streamId].sourceCreated = false;
          
          if (sourceSizingSelect.value === 'autoGrid' && itemRemoved) {
              scenesToClean.forEach(sceneName => { if(sceneName) setTimeout(() => rearrangeAllStreamsInScene(sceneName), 250);});
          }
          if (screenShareId !== streamId) updateStreamList(); // Avoid double update if removeScreenShareFromObs was called
          saveSettings();
      }

      async function removeScreenShareFromObs(streamIdToRemove) {
          if (!obsConnected || !obs || !streamIdToRemove) {
             if (screenShareId === streamIdToRemove) { screenShareId = null; updateStreamList(); }
             return;
          }

          const sourceName = `${getFullReactionPrefix()}_${streamIdToRemove}:s`;
          logMessage(`Removing screen share source '${sourceName}'`);
          try {
              const scenesResponse = await sendRequest('GetSceneList');
              if (scenesResponse && scenesResponse.scenes) {
                  for (const scene of scenesResponse.scenes) {
                      await tryRemoveFromScene(sourceName, scene.sceneName);
                  }
              }
              try { // Remove input itself
                  await sendRequest('GetInputSettings', { inputName: sourceName }); // Check existence
                  await sendRequest('RemoveInput', { inputName: sourceName });
              } catch (e) { /* Might not exist or be removable */ }
          } catch (error) { logMessage(`Error removing screen share '${sourceName}': ${error.message}`); }
          finally {
              if (screenShareId === streamIdToRemove) screenShareId = null;
              updateStreamList();
          }
      }

      async function tryRemoveFromScene(sourceName, sceneName) {
          if (!sceneName) return false;
          try {
              const itemInfo = await sendRequest('GetSceneItemId', { sceneName, sourceName });
              if (itemInfo && itemInfo.sceneItemId) {
                  await sendRequest('RemoveSceneItem', { sceneName, sceneItemId: itemInfo.sceneItemId });
                  return true;
              }
          } catch (error) { /* Not found is okay */ }
          return false;
      }

      function loadJsShaLibrary() {
          return new Promise((resolve, reject) => {
              if (typeof jsSHA !== 'undefined') { resolve(); return; }
              const script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jsSHA/3.3.0/sha256.js';
              script.onload = resolve;
              script.onerror = () => reject(new Error('Failed to load jsSHA library'));
              document.head.appendChild(script);
          });
      }

      const otherScenesContainer = document.getElementById('otherScenesContainer');
      const otherScenesListDiv = document.getElementById('otherScenesList'); // Ensure this is defined for updateOtherScenesList
      const screenShareSceneSelect = document.getElementById('screenShareSceneSelect');


      obsSceneSelect.addEventListener('change', () => {
          obsSceneNameInput.value = obsSceneSelect.value; 
          saveSettings();
          updateOtherScenesList(); // Update available "other scenes" based on new main
          updateStreamList(); // Update target scene display for active streams
      });
      [obsWsUrlInput, obsWsPasswordInput, vdoNinjaBaseUrlInput, vdoNinjaRoomInput,
       vdoNinjaPasswordInput, vdoNinjaStreamIdsInput, autoAddSourcesCheckbox,
       autoRemoveSourcesCheckbox].forEach(el => el.addEventListener('change', saveSettings));

      sourceSizingSelect.addEventListener('change', () => {
          saveSettings();
          if (sourceSizingSelect.value === 'autoGrid') {
              rearrangeAllStreamsInScene(getTargetScene());
              // Potentially rearrange other scenes too if they are affected
              document.querySelectorAll('.other-scene-checkbox:checked').forEach(checkbox => {
                  rearrangeAllStreamsInScene(checkbox.value);
              });
          }
      });
      loadScenesBtn.addEventListener('click', fetchObsScenes);

      if (screenShareSceneSelect) {
          screenShareSceneSelect.addEventListener('change', saveSettings);
      }
      document.getElementById('screenShareWidth').addEventListener('change', saveSettings);
      document.getElementById('screenShareHeight').addEventListener('change', saveSettings);


      document.addEventListener('DOMContentLoaded', () => {
          loadSettings(); // Load all settings, including prefixes and VDO base URL
          logMessage("VDO.Ninja OBS Control Dock Initialized.");
          
          // Initial UI setup for VDO.Ninja connection
          updateVdoNinjaButtonState(false); // Ensure it starts as disconnected, inputs enabled
          toggleVdoNinjaInputs(false); // Explicitly enable VDO.Ninja inputs

          const secureFields = document.querySelectorAll('#vdoNinjaRoom, #vdoNinjaStreamIds');
          secureFields.forEach(field => {
              field.classList.add('blur-field');
              field.addEventListener('focus', () => field.classList.remove('blur-field'));
              field.addEventListener('blur', () => field.classList.add('blur-field'));
          });
          startVdoNinjaConnectionMonitor();
      });
    </script>
  </body>
</html>